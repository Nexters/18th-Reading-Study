## 아이템 10. equals는 일반 규약을 지켜 재정의하라

다음과 같은 상황 중 하나에 해당한다면 equals를 재정의하지 않는 것이 최선이다.

- 각 인스턴스가 본질적으로 고유하다.
- 인스턴스의 '논리적 동치성(logical equality)'을 검사할 일이 없다.
- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
- 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.

equals를 재정의해야 할 때는 객체 식별성이 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 equlas가 논리적 동치성을 비교하도록 재정의되지 않았을 때다.

equals 메서드를 재정의 할 때는 반드시 일반 규약을 따라야 한다.

- 반사성 : 객체는 자기 자신과 같아야 한다.
- 대칭성 : 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다.
- 추이성 : 첫 번재 객체와 두 번재 객체가 같고, 두 번째 객체와 세 번째 객체가 같다면, 첫 번째 객체와 세 번째 객체도 같아야 한다.
- 일관성 : 두 객체가 같다면 앞으로도 영원히 같아야 한다. 클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안 된다.
- 모든 객체가 null과 같지 않아야 한다.

양질의 equals 메서드 구현 방법

1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
2. instanceof 연산자로 입력이 올바른 타입인지 확인한다.
3. 입력을 올바른 타입으로 형변환 한다.
4. 입력 객체와 자기 자신의 대응되는 '핵심' 필드들이 모두 일치하는지 하나씩 검사한다.

## 아이템 11. equals를 재정의하려거든 hashCode도 재정의하라

equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다. 그렇지 않으면 hashCode 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 HashMap이나 HashSet같은 컬렉션의 원소로 사용할 때 문제를 일으킬 것이다.

- equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.
- equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
- equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.

hashCode 재정의를 잘못했을 때 크게 문제가 되는 조항은 두 번째다. 즉, 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다.

해시 충돌이 적은 방법을 써야한다면 구아바의 com.google.common.hash.Hashing을 참고하면된다.

Objects 클래스는 임의의 개수만큼 객체를 받아 해시코드를 계산해주는 정적 메서드인 hash를 제공해주지만, 속도는 더 느리다. 입력 인수를 담기 위한 배열이 만들어지고, 입력 중 기본 타입이 있다면 박싱과 언박싱도 거쳐야 하기 때문이다.

성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해서는 안 된다. 속도야 빨라지겠지만, 해시 품질이 나빠져 해시테이블의 성능을 심각하게 떨어뜨릴 수도 있다.

hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말자. 그래야 클라이언트가 이 값에 의지하지 않게 되고, 추후에 계싼 방식을 바꿀 수도 있다.

## 아이템 12. toString을 항상 재정의하라

Object의 기본 toString 메서드가 적합한 문자열을 반환하는 경우는 거의 없다. 이 메서드는 단순히 클래스_이름@16진수로_표시한_해시코드를 반환할 뿐이다. toStrin의 일반 규약에 따르면 '간결하면서 사람이 읽기 쉬운 형태의 유익한 정보'를 반환해야 한다. 또한 toString의 규약은 "모든 하위 클래스에서 이 메서드를 재정의하라"고 한다.

toString을 구현할 때면 반환값의 포맷을 문서화할지 정해야 한다. 전화번호나 행렬 같은 값 클래스라면 문서화하기를 권한다. 

단점은 포맷을 한번 평생 그 포맷에 얽매이게 된다. 포맷을 명시하든 아니든 의도는 명확히 밝혀야 한다.

포맷 명시 여부와 상관없이 toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공하자.

## 아이템 13. clone 재정의는 주의해서 진행하라

Cloneable은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스이다.

하지만 clone 메서드가 선언된 곳이 Cloneable이 아닌 Object이고, 그마저도 protected이다. 그래서 Cloneable을 구현하는 것만으로는 외부 객체에서 clone 메서드를 호출할 수 없다. 리플렉션을 사용하면 가능하지만, 100% 성공하는 것도 아니다. 해당 객체가 접근이 허용된 clone메서드를 제공한다는 보장이 없기 때문이다.

Clonable 인터페이스는 Object의 protected 메서드인 clone의 동작 방식을 결정한다. Clonable을 구현한 클래스의 인스턴스에서 clone을 호출하면 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하며 CloneNotSupportedException을 던진다. 이는 인터페이스를 상당히 이례적으로 사용한 예이니 따라하면 안된다.

clone 메서드는 사실상 생성자와 같은 효과를 낸다. 즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.

생성자에서는 재정의될 수 있는 메서드를 호출하지 않아야 하는데 clone 메서드도 마찬가지다. 만약 clone이 하위 클래스에서 재정의한 메서드를 호출하면, 하위 클래스는 복제 과정에서 자신의 상태를 교정할 기회를 잃게 되어 원본과 복제본의 상태가 달라질 가능성이 크다.

상속해서 쓰기 위한 클래스 설계 방식 중 어느 쪽에서든, 상속용 클래스는 Cloneable을 구현해서는 안 된다. 

Cloneable을 구현한 스레드 안전 클래스를 작성할 때는 clone 메서드는 역시 적절히 동기화해줘야 한다.

Cloneable을 구현하는 모든 클래스는 clone을 재정의해야 한다. 이때 접근 제한자는 public으로, 반환 타입은 클래스 자신으로 변경한다. 이 메서드는 가장 먼저 super.clone을 호출한 후 필요한 필드를 전부 적절히 수정한다. 일반적으로 이 말은 그 객체의 내부 '깊은 구조'에 숨어 있는 모든 가변 객체를 복사하고, 복제본이 가진 객체 참조 모두가 복사된 객체들을 가리키게 함을 뜻한다.

Cloneable을 사용하지 않은 상황이라면 복사 생성자와 복사 팩터리라는 복사 방식을 제공할 수 있다.
