**클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다.**

싱글톤을 만드는 방식은 보통 생성자는 private로 감춰두고, 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해둔다.

```java
public class Elvis {
	public static final Elvis INSTANCE = new Elvis();
	private Elvis() {...}

} 
```

권한이 있는 클라이언트는 리플렉션 API AccessibleObject.setAccessible을 사용해 private 생성자를 호출 할 수 있다. 이러햔 공격을 방어하려면 생성자를 수정하여 두 번째 객체가 생성되려 할 때 예외를 던지게 하면 된다.

```java
public class Elvis {
	private static final Elvis INSTATNCE = new Elvis();
	private Elvis() { ... }
	public static Elvis getInstance() { return INSTANCE; }
}
```

public 필드 방식의 큰 장점

- 해당 클래스가 싱글턴임이 API에 명백히 드러난다
- 간결함

정적 팩터리 방식의 장점

- API를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다.
- 유일한 인스턴스를 반환하던 팩터리 메서드가 호출하는 스레드별로 다른 인스턴스를 넘겨주게 할 수 있다.
- 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다.
- 정적 팩터리의 메서드 참조를 공급자(supplier)로 사용할 수 있다.

둘 중 하나의 방식으로 만든 싱글턴 클래스를 직렬화하려면 모든 인스턴스 필드를 일시적(transient)이라고 선언하고 readResole 메서드를 제공해야 한다. 이렇게 하지 않으면 직렬화된 인스턴스를 역직렬화할 때마다 새로운 인스턴스가 만들어진다.

싱글턴을 만드는 세 번째 방법은 원소가 하나인 열거 타입을 선언하는 것이다.

```java
public enum Elvis{
	INSANCE;
	public void leaveTheBuilding() {...}
}
```

public 필드 방식과 비슷하지만, 더 간결하고, 추가 노력 없이 직렬화할 수 있고, 심지어 아주 복잡한 직렬화 상황이나 리플렉션 공격에서도 제 2의 인스턴스가 생기는 일을 완벽히 막아준다. 조금 부자연스러워 보일 수는 있으나 대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다. 단, 만들려는 싱글턴이 Enum외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없다.

## 아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용하라

정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한 게 아니다. 하지만 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어준다. 

추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다. 

private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다. 이 방식은 상속을 불가능하게 하는 효과도 있다.

## 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.

 대신 클래스가 여러 자원 인스턴스를 지원해야 하며, 클라이언트가 원하는 자원을 사용해야 한다. 이 방식은 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식이다. 이는 의존 객체 주입의 한 형태로, 맞춤법 검사기를 생성할 때 의존 객체인 사전을 주입해주면 된다.

이 패턴의 변형으로, 생성자에 자원 팩터리를 넘겨주는 방식이 있다.  Supplier<T> 인터페이스가 팩터리를 표현한 완벽한 예다.
