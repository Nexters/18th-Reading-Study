## 조건 큐 캡슐화

  조건 큐를 클래스 내부에 캡슐화해서 클래스 상속 구조의 외부에서는 조건 큐를 사용할 수 없도록 막는 게 좋다. 클래스를 사용하는 외부 프로그램에서 조건 큐에 대한 대기와 알림 규칙을 추측한 상태에서 의도와는 다른 방법으로 호출할 가능성이 있다. 

  

## 진입 규칙과 완료 규칙

  wait와 notify에 적용하는 규칙은 진입 규칙과 완료 규칙이다. 상태를 변경하는 연산을 할 때 항상 진입 규칙과 완료 규칙을 정의해야 한다.

  진입 규칙은 연산의 조건을 뜻한다. 

  연산이 상태 값을 변경하면 다른 연산의 조건도 함께 변경됐을 가능성이 있다. 완료 규칙은 다른 연산의 조건이 변경되면 조건 큐에 알림 메세지를 보내야 한다는 규칙이다.

## 명시적인 조건 큐

  명시적인 조건 큐는 `Condition`클래스다. 암묵적인 조건 큐는 다음과 같은 단점이 있다. 암묵적인 락 하나는 조건큐를 하나밖에 가질 수 없다. 여러 조건을 가지는 경우가 발생해 단일 대기 조건을 만족할 수 없다. → notify 사용 불가, notifyAll만 사용 가능

  명시적인 조건 큐는 `Lock.newCondition`와 같은 형태로 생성한다. 생성에 사용한 Lock 객체의 공정성을 그대로 물려받는다. 명시적인 조건 큐에서는 `await`, `signal`, `signalAll` 연산을 가지고 있다.  하지만 wait, notify, notifyAll도 같이 가지고 있으므로 사용에 주의해야 한다.

  암묵적인 조건 큐를 사용해 여러 조건을 처리하는 것 보다 조건 별로 Condition 객체를 생성하면 가독성이 좋아진다. → 단일 알림 조건 만족

  조건에 관련한 모든 변수는 Lock의 보호 아래 동기화돼 있어야 한다. 조건을 확인하거나 `await`, `signal` 메소드를 호출하는 시점에서는 Lock을 확보한 상태여야 한다.

## AbstractQueuedSynchronizer

  `ReentrantLock`과 `Semaphore`의 인터페이스는 비슷하다. 두 클래스 모두 `AbstractQueuedSynchronizer`(AQS)를 상속해 구현했다. 

  AQS를 사용하면 대기중인 스레드를 FIFO 큐에서 관리하는 기능을 직접 구현하지 않아도 된다. AQS 기반으로 만들어진 동기화 클래스는 대기 상태에 들어갈 수 있는 지점이 하나이다. 컨텍스트 스위칭을 줄이고 성능을 높일 수 있다.

  기본이 되는 연산은 확보와 해제이다. 확보는 상태 기반으로 동작하며 항상 대기 상태에 들어갈 가능성이 있다. 해제는 대기 상태에 들어가지 않으며 확보에서 대기 중인 스레드를 풀어준다. 동기화 클래스에서 확보 연산을 허용할 수 있는 상태인지 확인한다. 허용하지 못하면 대기 상태에 들어가거나 실패한다. 다음은 상태를 업데이트 한다.

  상태 변수를 관리하는 작업을 하고 있다. `getState`, `setState`, `compareAndSetState`으로 상태를 관리한다.
