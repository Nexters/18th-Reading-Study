배타적인 확보 연산이 아닐 경우 suffix로 `Shared` 가 붙는다.

배타적인 확보 연산 → Write Lock처럼 혼자 써야하는 락을 확보하는 연산?

모든 wait, signal 연산은 실행하기 전 `try*` 로 락을 확보할 수 있는지 확인한다.

AQS를 직접 상속하는 것 보다 Composition을 통해 구현하는 것을 추천 (위임)

실제 java.util.concurrent 내 모든 클래스는 AQS를 내부 변수로 두어 기능을 위임해서 구현한다.

## ReentrantLock

- 재진입 여부를 확인하기 위해 상태변수 `owner`를 확인한다.
- 만약 확보하려고 하는 락의 `owner` 가 자기 자신이라면 바로 진입할 수 있다 (재진입)

## Semaphore와 CountDownLatch

- 상태 변수를 통해 퍼밋의 개수를 관리한다.
- 퍼밋의 개수는 한 번에 여러 개를 줄일 수 있다.
- 퍼밋을 확보할 때 까지 적절한 회수만큼 반복한다.

## FutureTask

- 작업을 처리하고 있는 스레드에 대한 참조를 가지고 있다.→ 인터럽트 처리
- 작업의 상태, 결과 값, 예외 객체를 상태변수로 가지고 있다.

## ReentrantReadWriteLock

- 상태 변수 32비트 중 16비트는 쓰기 락, 16비트는 읽기 락을 관리한다.
- 쓰기 락은 독점적인 연산으로 처리하고 읽기 락은 독점적이지 않은 연산으로 처리한다.
- 대기중인 스레드를 큐로 관리한다. 스레드가 독점적인 연산을 요청했는 지 독점적이지 않은 연산을 요청했는 지도 알 수 있다.
- 쓰기락이 항상 우선순위를 가진다. 읽기 락은 락을 공유해서 사용한다.
