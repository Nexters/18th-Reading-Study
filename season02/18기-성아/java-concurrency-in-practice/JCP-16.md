## 활동성을 최대로 높이기

- 안전성과 활동성 사이에는 trade-off가 존재
    - 안전성을 위해서는 락을 사용해야 하지만, 활동성이 낮아짐

### 데드락

- 락 순서가 꼬였을 때 발생
- 순서를 올바르게 제어하는 게 중요하다.
    - 방향이 있는 그래프로 표현 가능 -> 종속성 그래프
    - 노드는 스레드
    - 엣지는 스레드에 필요한 자원을 점유하려는 경우
- `A - > B -> C -> A` 와 같이 사이클이 될 때 데드락 발생
- 데이터베이스는 데드락 복구 기능이 있음. 데드락 발생을 확인하면 일정 시간이 지난 후에 임의의 트랜잭션을 종료시켜서 데드락에서 벗어남
- JVM은 데드락 상태를 확인할 수 없어서 데드락이 발생하면 스레드들이 영원히 멈춘다. 강제로 종료할 수 밖에 없다. -> 예방 밖에 방법이 없음
- 데드락은 처음에 모습을 거의 드러내지 않는다. 시스템에 부하가 걸리는 경우와 같이 최악의 상황에서 모습을 드러낸다.

### 락 순서에 의한 데드락

- 락이 클래스 내부 변수로 존재하는 경우
- 프로그램 내부의 모든 스레드에서 필요한 락을 모두 같은 순서로 사용한다면 락 순서에 의한 데드락은 발생하지 않는다.

### 동적인 락 순서에 의한 데드락

- 락이 파라미터로 들어오는 경우
- 락을 특정 순서에 맞춰 확보하도록 유도, 프로그램 전반적으로 확보하는 순서를 고정시키면 된다
    - `System.idntityHashCode`를 사용해서 프로그램 내 고정된 인스턴스의 해시 값을 이용해 락을 확보하는 순서를 결정한다.
    - 해시 값이 동일한 경우는 `타이 브레이킹 락` 을 사용한다.
        - 두 개의 락을 임의 순서로 확보하는 위험한 작업을 특정 순간에 하나의 스레드에서만 할 수 있도록 막는다.

        ```java
        synchronized (tieLock) {
          synchronized (fromAcct) {
            synchronized (toAcct) {
        	     // Task
            }
          }
        }
        ```

        - 객체 내부에 유일하고 불변하면서 비교 가능한 값을 가지고 있다면 쉽게 락 순서를 지정할 수 있다.
