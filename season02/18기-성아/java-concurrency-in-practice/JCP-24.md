## 조건 큐 활용

조건 큐를 사용하면 효율적이면서 응답속도도 빠른 상태 종속적인 클래스를 구현할 수 있다. 하지만 올바르지 않은 방법으로 사용할 가능성도 높다. 조건 큐를 제대로 활용하려면 지켜야할 몇가지 규칙이 있다.

### 조건 서술어

  조건 서술어는 기능이 상태 종속적이 되게 만드는 선행조건을 의미한다. 해당 객체가 대기하게 될 조건 서술어를 명확하게 정의해야 한다.   `take` 메소드의 조건 서술어는 "버퍼에 값이 있어야 한다" 이다. 조건 큐와 연결된 조건 서술어를 항상 문서로 남겨야하며 조건 서술어에 영향을 받는 메소드를 명시해야 한다. wait을 호출할 때 호출자는 조건 서술어에 연결된 조건 큐에 대한 락을 확보한 상태여야 한다.

### 너무 일찍 깨어나기

 하나의 암묵적이 조건 큐를 두 개 이상의 조건 서술어를 대상으로 사용할 수 있다. wait 메소드가 리턴했다고 해서 wait하기 직전에 확인한 조건 서술어를 만족했다는 것은 아니다. wait 메소드는 notify 해주지 않아도 리턴되는 경우도 있다. 동일한 조건 큐를 대상으로 하는 다른 조건 서술어가 만족돼 notify 됐을 수 있다. wait 메소드가 깨어나 리턴되고 나면 조건 서술어를 한번 더 확인해야 한다.

- wait 메소드를 사용할 때는
    - 조건 서술어를 확인해야 한다.
    - wait 메소드 호출 전에 조건 서술어를 확인하고 리턴한 후에도 조건 서술어를 확인해야 한다.
    - wait 메소드는 반복문 내부에서 호출해야 한다.
    - 조건 서술어와 관련한 변수는 조건 큐의 락에 의해 동기화돼 있어야 한다.
    - wait, notify, notifyAll 메소드를 호출할 때는 조건 큐에 해당하는 락을 확보하고 있어야 한다.
    - 작업을 실행해 작업이 끝날 때 까지 락을 해제해서는 안된다.

### 놓친 신호

  특정 스레드가 조건 서술어가 참임에도 대시 상태에 들어가는 상황을 놓친 신호라고 한다. 영원히 대기 상태에 빠질 수 있다. 스레드에 대한 알림이 일시적이라 놓침 신호가 발생한다. e.g. A notify → B wait 인 경우

### 알림

  대기가 아닌 한쪽을 알림이라고 지칭한다. notify를 호출하면 JVM은 해당하는 조건 큐에 대기 상태에 들어가 있는 다른 메소드의 대기 상태를 풀어준다. notifyAll은 대기 상태에 있는 모든 스레드를 풀어 준다. notify, notifyAll을 호출할 때는 조건 큐 객체에 대한 락을 확보해야 하고 wait 메소드를 호출한 후에도 락을 확보해야 한다. 따라서 notify, notifyAll을 호출한 후에 락을 빨리 놓아줘야한다.

notify는 다음과 같은 두 조건을 만족하는 상황에서만 사용한다.

- 단일 조건에 따른 대기 상태에서 깨우는 경우
- 한 번에 하나씩만 처리하는 경우
