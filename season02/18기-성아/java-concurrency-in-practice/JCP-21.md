공유한 데이터에 여러 스레드가 접근했을 때 조율할 수 있는 방법 `synchronized` , `volatile` 이 있음. Java 5.0 부터 `ReentrantLock` 이 추가됨.

## 명시적인 락

  Lock 인터페이스는 암묵적인 락 (synchornized) 와 달리 조건 없는 락, 폴링 락, 타임아웃이 있는 락, 락 확보 대기 상태에서 인터럽트를 걸 수 있는 방법을 포함함. 락을 확보하고 해제하는 모든 작업이 명시적이다. Lock을 구현하는 클래스는 암묵적인 락과 동일한 메모리 가시성을 제공해야 한다. ReentrantLock을 확보하는 건 synchronized 블록에 진입하는 것과 같고 ReentrantLock을 해제하는 건 synchronized 블록을 빠져나가는 것과 동일하다. 성능과 활동성을 높이려면 synchronized 구문보다 유연성이 높은 락 방법이 필요하다. ReentrantLock을 사용할 때 주의할 점은 `finally` 구문에서 반드시 락을 해제해야 한다는 점이다. synchronized 구문은 락을 해제할 필요가 없다.

  

## 폴링과 시간 제한이 있는 락 확보 방법

  tryLock 메소드가 지원하는 `폴링 락 확보 방법`이나 `시간 제한이 있는 락 확보 방법` 은 오류가 발생했을 때 오류를 잡아내기 좋은 방법이다. 암묵적인 락을 사용할 때 데드락이 발생하면 프로그램이 멈춘다. 프로그램이 멈추지 않게 하려면 올바르지 않은 락 순서를 맞춰 데드락을 예방하는 방법 밖에 없다. 락에 문제가 생기더라도 제어할 수 있는 통제권을 가진다. 

`라이브락`→ 서로 양보하려고 하면서 락 확보, 해제를 반복하는 상황

## 인터럽트 걸 수 있는 락 확보 방법

  암묵적인 락을 확보하는 작업은 인터럽트에 전혀 반응하지 않는다. `lockInterruptibly` 메소드는 인터럽트를 처리할 수 있는 상태에서 락을 확보한다. 

## 블록을 벗어나는 구조의 락

  복잡한 구조 프로그램에서 락을 적용할 때는 블록이 아닌 유연하게 락을 걸 수 있어야 한다. 락을 적용하는 코드를 세분화하면 애플리케이션의 확장성이 높아진다. 해시 기반 컬렉션에서 여러 개의 해시 블록으로 나누어 블록 별로 다른 락을 사용하는 락 스트라이핑 방법 등이 예시다. 링크드 리스트처럼 링크를 가지는 경우 개별 노드마다 다른 락을 사용할 수 있다. 특정 노드에 대한 락은 해당 노드가 갖고 있는 링크 포인터와 실제 값을 보호한다. 링크에 접근할 때는 특정 노드에 대한 락을 확보하고 노드에 연결한 다른 노드에 락을 확보하고 원래 노드의 락을 해제한다. 이 방법을 `핸드 오버 락`, `락 커플링`이라고 한다.
