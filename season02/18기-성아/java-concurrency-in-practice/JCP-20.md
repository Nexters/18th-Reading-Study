## 성능 테스트

  성능 테스트를 하기 전, 기능 테스트가 필수적이다. 오류가 있는 코드의 성능을 테스트할 수 없기 때문이다. 성능 테스트는 특정한 사용 환경 시나리오를 정하고 통과하는 데 얼마나 시간이 걸리는지 측정하는 목적을 가지고 있다. 테스트가 의미를 가지기 위해서는 사용 환경 시나리오가 실제 애플리케이션에서 사용되는 환경와 동일해야 한다. 성능과 관련있는 하드웨어 지표를 알 필요도 있다. 예를 들어, 스레드 개수, 버퍼 크기에 따라 성능이 달라질 수 있다. 하드웨어 지표를 통해 어떤 지점에서 병목이 있는지 확인할 수 있다.  절대적인 성능 지표가 중요한 것이 아니라 대략적으로 얼마만큼의 성능을 낼 수 있는지, 병목이 있다면 어디 있는지 알아낼 수 있다는 게 의미가 있다.

  연결 리스트와 배열 리스트의 예. 일반적으로 연결 리스트가 요소를 추가할 때 메모리 공간을 추가적으로 할당하기 때문에 비용이 크다. 배열 리스트는 할당한 배열 공간에 집어 넣기만 하면 된다. 하지만 병렬 처리 환경에서는 연결 리스트의 head와 tail을 병렬적으로 처리할 수 있어 배열 리스트보다 성능이 뛰어날 수 있다. 메모리 할당 작업이 공유 자원을 사용하지 않고 스레드 내부에만 한정되있어 스레드 간 경쟁을 줄일 수 있는 알고리즘의 확장성이 높다. 반면에 배열 리스트는 배열이라는 공유된 공간을 사용해 경쟁에 민감하다. 전통적인 성능 튜닝에서의 상식이 확장성에서는 통하지 않을 수 있다.

  응답성이 중요한 경우도 있다. 응답성은 단일 작업을 처리 하는 데 얼마만큼의 시간이 걸리는지 나타내는 지표이다. 응답성은 다음과 같은 문제점을 주의해야 한다. `가비지 컬렉션`, `동적 컴파일`, `비현실적인 코드 경로 샘플링`, `비현실적인 경쟁 수준`, `의미없는 코드 제거`.

### 가비지 컬렉션

  테스트가 실행하는 동안 가비지 컬렉션 실행 여부가 실행 시간에 큰 영향을 끼친다. 테스트 실행 횟수를 살짝 변경해도 테스트 당 실행시간이 이상하게 변할 수 있다. 긴 시간 동안 테스트를 진행해 가비지 컬렉션을 여러 번 실행한다는 사실을 명확히 하는 방법이 있다.

### 동적 컴파일

  컴파일러에서 자주 실행하는 바이트코드는 인터프리트 하는 대신 컴파일하고 기계어를 실행하는 경우가 있다. 바이트 코드를 인터프리트 하는 속도와 컴파일 해서 실행하는 속도 차이가 크기 때문에 일관된 성능 측정이 어려울 수 있다. 실제 환경에서는 필요한 모든 메소드를 컴파일한다고 볼 수 있다. 테스트를 긴 시간동안 실행시켜 필요한 바이트코드를 모두 컴파일한 후 성능 지표를 측정하는 방법도 있다. `-XX: +PrintCompilation` 옵션을 사용하면 동적 컴파일 시점을 알 수 있다. 이전 컴파일 상황에서 가정사항이 변경되거나 실제 실행할 때 성능 평가 결과가 다른 최적화 방법이 적합할 수 있다. 그렇다면 컴파일한 바이트코드를 디컴파일하고 재컴파일한다.

### 비현실적인 코드 경로 샘플링

   런타임 컴파일러는 컴파일할 코드에 대한 최적화 정보를 얻기 위해 실행 과정에서 여러 가지 성능 값을 추출한다. JVM이 더 나은 코드를 생성하도록 프로그램 실행에 관련한 특정 정보를 사용한다. 특정 프로그램에서 사용하는 메소드와 다른 프로그램에서 사용하는 동일한 메소드의 컴파일 결과가 다를 수 있다. (동일한 프로그램을 여러 개 키는 경우를 말하는 듯?)

  단일 스레드에서 동작했어야 할 프로그램에 병렬성에 필요한 최적화 기법을 사용해 코드를 컴파일해서 문제가 생길 수 있다. 단일 스레드 프로그램의 성능을 테스트하고자 할 때도 단일 스레드 프로그램의 성능 뿐만 아니라 멀티 스레드 애플리케이션의 성능도 같이 측정하는 게 좋다.

### 비현실적인 경쟁 수준

- 공유한 데이터에 접근하는 작업
- 스레드 내부 데이터만 실행하는 작업

각각 얼마만큼의 비율을 차지하는지에 따라 경쟁 수준이 달라지고 성능과 확장성 측면에서 다른 결과가 나온다. 공유 데이터에 접근하는 작업이 비중이 크다면 동기화 비용이 크고, 스레드 내부 데이터 실행 작업이 비중이 크면 동기화 비용은 적다. 테스트에서는 실제 환경과 동일한 비율을 설정하는 게 중요하다.

### 의미없는 코드 제거

  최적화 컴파일러는 의미없는 코드 (실행 결과에 영향을 주지 않는 코드)를 제거 한다. 성능 측정을 하는 동안에 사용하지 않는 로직은 제거할 수 있다. 정적으로 컴파일하는 언어에서도 유사한 문제가 발생한다. 하지만 기계어를 보면 얼마나 제거했는지 확인할 수 있다. 동적 컴파일 언어는 코드 제거가 얼마나 됐는지 알기 어렵다.

  테스트할 때도 최적화 능력이 뛰어난  `-server` 모드로 실행하는 게 좋다.  최적화 능력이 뛰어나 테스트에서 실제 환경보다 더 많은 최적화가 일어날 수 있는 문제가 있다. 테스트에서 의미없는 코드로 제거하지 않도록 테스트를 신경쓴다면 문제를 해결할 수 있다. 성능 측정상 필요한 부분까지 제거하지 않도록 약간의 편법을 사용해야 할 때도 있다. 

e.g. `if(foo.x.hashCode() == System.nanoTime())` 와 같이 실행할 확률이 희박한 조건에서만 코드 실행하기

컴파일러에서 결과 값을 예측할 수 있다면 매번 계산하는 대신 미리 계산한 값을 사용할 수 있다. 특히 정적인 입력 값일 경우 주의해야 한다.
