`java.util.concurrent`의 클래스들은 `synchronized` 구문보다 속도가 빠르고 확장성이 좋다. 성능이 좋은 이유는 단일 연산 변수(atomic variable)와 넌블로킹 동기화 기법이다.

여러 스레드가 동작하는 환경에서 데이터의 안정성을 보장하는 방법으로 락보다 하드웨어에서 제공하는 `compare-and-swap`을 사용한다. 

넌블로킹 알고리즘은 락을 사용하는 방법보다 설계와 구현 모두 복잡하지만 확장성과 활동성을 높여준다. 넌블로킹은 경쟁 상태에서 대기 상태에 들어가지 않아 스케줄링 부하가 줄어든다. 또한 개별 스레드에서 발생하는 오류에 의해 다른 스레드가 영향을 받지 않는다.

단일 연산 변수는 넌블로킹 알고리즘 구현뿐만 아니라 나은 volatile 변수 역할로 사용할 수도 있다.

`++i`같은 연산은 단일 연산처럼 보이지만 실제로는 세 가지 연산의 조합이다. 세 가지 작업을 단일 연산으로 묶을면 락을 사용해야 했다. 단순히 카운터 값을 증가하는 데 락을 사용하는 건 무거운 방법이다. 락에 대한 경쟁이 심해질수록 동기화 작업에 필요한 시간이 작업을 처리하는 시간보다 길어질 수 있다. 따라서 volatile처럼 가벼우면서 단일 연산 조건을 만족하는 단일 연산 변수가 나왔다.

락은 보수적인 동기화 기법이다. 최악의 상황을 가정하고 처리하기 전까지는 다른 스레드가 접근하지 못한다. 낙관적인 방법은 값을 먼저 변경하고 변경하는 도중에 다른 스레드의 간섭이 있었는지 확인한다. (충돌 검출 collision detection) 간섭이 있었으면 연산이 실패하고 재시도할 수 있다. 멀티프로세서 연산을 염두에 두고 만들어진 프로세서는 공유된 변수를 두고 사용하는 다양한 연산을 제공하고 있다. `compare-and-swap`, `load-linked`, `store-conditional` 

락 기반 프로그램은 코드는 간결하지만 JVM과 운영체제에서 락을 처리하기 위한 작업은 간단하지 않다. 락 내부에서 CAS과 스레드 대기, 컨텍스트 스위칭 등의 기능을 사용한다. 최적의 경우라면 CAS 연산 한 번이면 족한 상황이라면 락을 사용하는 것보다 직접 CAS 연산을 실행시키는 게 좋다. CAS 연산의 단점은 호출하는 프로그램에서 직접 스레드 경쟁 조건에 대한 처리를 해야 한다. (재시도 혹은 나중에 처리 혹은 무시)
