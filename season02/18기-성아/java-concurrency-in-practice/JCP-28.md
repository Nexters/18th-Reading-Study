### 넌블로킹 알고리즘

- CAS 연산을 독점적으로 사용하는 알고리즘을 올바르게 구현하면 대기 상태에 들어가지 않고 락 프리 특성을 가진다.
- 데드락이나 우선 순위 역전 같은 문제가 발생하지 않는다.
- 실패할 수 있으나 성공할 때 까지 재시도 한다.

### 넌블로킹 자료구조

넌블로킹 알고리즘을 활용해 자료구조를 구현할 때 주의해야할 점

- 단일 연산 변경 작업의 범위를 하나의 변수로 제한한다
- 추가, 제거 등을 단일 연산으로 변경하도록 강제해야 한다.

큐, 스택은 간단하게 구현 가능하지만 연결 리스트가 문제다.

연결 리스트에서 새로운 항목을 추가할 때 새로운 항목을 두 개의 참조를 업데이트해야 한다. 

- 기존 마지막 노드의 Next
- Tail 노드

연산을 두 가지 작은 연산으로 쪼개고(a,b) 어느 연산까지 실행됐는지 안다면, 다른 스레드에서 나머지 연산 (b)를 실행해줄 수 있다. 현재 tail node의 next의 null 여부를 식별하면 된다.

- a는 기존 Tail Node의 Next Node를 update → 중간 상태
- b는 TailNode 참조를 새로운 노드로 update → 평온한 상태

단일 연산 필드 업데이터를 사용할 수도 있다.

`AtomicReferenceFieldUpdater` 

→ 클래스를 여러 번 인스턴스화 했을 때 메모리를 줄이는 용도

[https://jupiny.com/2020/06/23/use-atomicreferencefieldupdater/](https://jupiny.com/2020/06/23/use-atomicreferencefieldupdater/)

### ABA 문제

A에서 B로 변경한 후에 A로 다시 변경했음을 확인할 수 있는가?

참조와 버전 번호를 같이 업데이트하면 식별 가능

혹은 boolean 값과 참조를 같이 업데이트 → `AtomicMarkableReference`
