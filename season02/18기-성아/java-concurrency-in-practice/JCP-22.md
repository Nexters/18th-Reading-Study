## 암묵적인 락과 명시적인 락

  지금 와서는 암묵적인 락 `synchronized`이나 명시적인 락 `ReentrantLock` 성능이 크게 차이나지 않는다. 초기에는 명시적인 락  `ReentrantLock` 의 성능이 월등히 빨랐지만 JDK6에서 차이가 많이 줄었다. 성능은 빠르게 변화하는 대상이다. 바로 어제 X가 Y보다 빠르다는 결과를 산출했던 성능 테스트를 오늘 실행해보면 다른 결과를 얻을 수 있다.

  락에는 공정성이 존재한다. 공정한 락과 불공정한 락이 존재하고 대체적으로 불공정한 락의 성능이 좋다. 스레드간 경쟁이 심할 때 공정한 락보다는 불공정한 락을 사용하는 게 좋다. 처리량이 크게 늘어진다. 공정한 락은 락을 확보하고 사용하는 시간이 길거나 스레드 간 경쟁이 약할 때 유리하다. JVM 에서는 명세에 공정성에 대한 강제사항이 없기 때문에 암묵적인 락은 대체로 불공정한 락을 기본적으로 사용한다.

  암묵적인 락으로 처리할 수 없는 상황에서만 `ReentrantLock` 사용을 추천한다. `synchronized` 는 JVM 내부에 내장되있기 때문에 최적화를 적용하기 쉽다. 자바 라이브러리에 포함된 클래스는 최적화 적용하기는 어렵다. 성능이 명시적인 락을 사용하는 이유가 되서는 안된다.

## ReadWriteLock

  대부분 읽기 작업이 쓰기 작업보다 많이 발생한다. 읽기 락 조건과 쓰기 락 조건을 다르게 적용하여 읽기 작업은 한 번에 여러 번 처리할 수 있지만 쓰기 락은 한 번만 사용하도록  `ReadWriteLock`  에서 처리해준다. 락 객체는 두 개가 아닌 하나만 사용한다. 읽기가 많은 환경에 최적화된 형태로 설계된 락이다. 그 외에 상황에서는 일반적인 락보다 성능이 떨어질 수 있다.

  ReadWriteLock을 구현할 때 적용할 수 있는 특성

- 읽기, 쓰기 락 해제 방법
- 일긱 순서 뛰어넘기
- 재진입 특성
- 다운그레이드
    - 쓰기 락 → 읽기 락
    - 대체로 허용한다.
- 업그레이드
    - 읽기 락 → 쓰기 락
    - 데드락 위험이 있어 일반적으로 제공하지 않는다.
