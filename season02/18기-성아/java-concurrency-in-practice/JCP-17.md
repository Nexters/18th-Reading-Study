캐시를 대충 만들면 단일 스레드로 처리할 때 성능이 높아질 수는 있겠지만, 나중에는 확장성의 병목이 될 수 있다. 효율적이면서 쉽게 확장할 수 있는 캐시를 만드는 방법을 단계 별로 알아본다.

첫 번째 방법, HashMap에 동시에 접근하지 못하도록 compute 메소드를 동기화한다. 스레드 안전성을 쉽게 확보할 수 있지만 확장성에서 문제가 생긴다.

두 번째 방법, ConcurrentHashMap를 사용한다. ConcurrentHashMap은 스레드 안전성을 확보하고 있어 동기화하지 않아도 된다. 두 개 이상의 스레드가 같은 값을 compute 메소드의 매개변수로 사용해 호출해 같은 값을 얻을 수 있다. 즉, compute를 호출 회수만큼 실행한다. 내부에 같은 객체를 두 번 저장한다.

세 번째 방법, FutureTask를 사용한다. ConcurrentHashMap<A, Future<V>>의 형태로 사용한다. FutureTask는 이미 끝났거나 끝날 예정인 연산 작업을 표현한다. 연산 도중이라면 끝날 때 까지 기다렸다가 결과를 알려준다. 하지만 여전히 여러 스레드가 같은 값에 대한 연산을 할 수 있다. 두 스레드가 compute 내부의 if문을 동시에 실행하는 경우. putIfAbsent 같은 원자적 연산을 사용하도록 해서 해결한다.
