# 동시성

- 동시성은 무엇과 언제의 결합을 분리하는 전략이다.
- 스레드가 하나라면 무엇과 언제는 밀접하다.
- 무엇과 언제를 분리해 구조와 효율을 높인다.

## 동시성이 필요한 이유

- 단일 스레드라면 필요한 정보를 수집하는 시간이 아주 길어진다.
- 사용자가 늘어날 수록 응답 속도도 늦어진다.
- 정보를 나눠 여러 컴퓨터에서 돌리면 즉, 병렬로 처리하면 빨라진다.

### 미신과 오해

- 동시성은 항상 성능을 높여준다?
    - 때때로 그렇다.
    - 대기 시간이 아주 길어서 여러 스레드가 프로세서를 공유할 수 있을 때
    - 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많을 때
- 동시성을 구현해도 설계는 변하지 않는다?
    - 무엇과 언제를 분리하면 시스템 구조가 크게 달라진다.
- 웹 컨테이너를 사용하면 동시성을 이해할 필요가 없다?
    - 실제 동작 방식을 알아야만 한다.
    
반대로 타당한 생각은 아래와 같다.

- 동시성은 부하를 유발한다.
- 동시성은 복잡하다.
- 일반적으로 동시성 버그는 재현하기 어렵다.
- 동시성을 구현하려면 근본적인 설계 전략을 재고해야 한다.

## 난관

```java
public class X {
    private int lastIdUsed;
    
    public int getNextId() {
        return ++lastIdUsed;
    }
}
```

lastIdUsed가 42일 때 두 스레드가 인스턴스를 공유하면 아래 중 하나가 발행한다.

- 한 스레드는 43, 다른 스레드는 44를 받는다. lastIdUsed는 44가 된다.
- 한 스레드는 44, 다른 스레드는 43을 받는다. lastIdUsed는 44가 된다.
- 두 스레드 모두 43을 받는다. lastIdUsed는 43이 된다.

두 스레드가 같은 변수를 동시에 참조하면, 수 많은 코드 중 일부 경로가 잘못된 값을 내놓는다.

## 동시성 방어 원칙

### 단일 책임 원칙

- 동시성 코드는 다른 코드와 분리해야 한다.
    - 독자적인 개발, 변경, 조율 주기가 있다.
    - 다른 코드와는 종류가 다른 난관을 겪으며 훨씬 어렵다.
    - 동시성 하나로 다양하게 실패할 수 있다.
    
### 자료 범위를 제한하라

- 공유 객체를 사용하는 코드 내의 임계 영역을 `synchronized` 키워드로 보호한다.
  - 임계 영역은 동시 사용을 막아야 프로그램이 올바로 동작하는, 보호받아야 할 코드 영역을 말한다.
- 임계 영역의 수를 최대한 줄여야 실수 가능성이 줄어든다.

### 자료 사본을 사용하라

- 처음부터 데이터를 공유하지 않는 게 제일 좋다.
- 각 스레드가 객체를 복사해 사용하고 사본에서 결과를 가져온다.

### 스레드는 가능한 독립적으로 구현하라

- 독자적은 스레드를 구현하고 다른 스레드와 자료를 공유하지 않는다.
- 모든 정보는 공유하지 않는 출처에서 가져와 로컬 변수에 저장한다.
- 세상에 자신만 있는 듯이 돌아갈 수 있고 다른 스레드와 동기화 할 필요가 없다.

## 라이브러리를 이해하라

- 자바 5부터 제공하는 스레드에 안전한 컬렉션을 사용한다.
- 서로 무관한 작업을 할 때는 executor 프레임워크를 사용한다.
- 스레드가 blocking 되지 않는 방법을 가능한 사용한다.

### 스레드 환경에 안전한 컬렉션

- ConcurrentHashMap
    - 안전하고 HashMap보다 성능이 좋다.
- java.util.concurrent
- java.util.concurrent.atomic
- java.util.concurrent.locks

## 실행 모델을 이해하라

### 한정된 자원
  
- 다중 스레드에서 사용하는 자원
- 크기나 숫자가 제한적이다.
- ex) DB 연결, 길이가 일정한 읽기/쓰기 버퍼

### 상호 배제

- 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 잇는 경우

### 기아

- 하나 혹은 여러 스레드가 오랫동안 혹은 영원히 자원을 기다리는 것
- 항상 짧은 스레드에게만 자원을 준다면 긴 스레드는 기아 상태에 빠진다.

### 데드락

- 여러 스레드가 서로 끝나기만을 기다리는 것
- 각자 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 진행하지 못한다.

### 라이브락

- 락을 거는 단계에서 각 스레드가 서로를 방해하는 것
- 스레드는 계속 진행하려 하지만 오랫동안 혹은 영원히 진행하지 못한다.

## 다중 스레드 실행 모델

### 생산자-소비자

- 생산자 스레드가 정보를 버퍼나 큐에 넣는다.
- 소비자 스레드가 큐에서 정보를 가져와 사용한다.
- 큐는 한정된 자원이므로 빈 공간이 생길 때까지 기다린다.
- 생산자는 소비자에게 큐에 정보가 있다고, 소비자는 생산자에게 큐에 데이터를 넣을 빈 공간이 있다고 시그널을 보낸다.
- 잘못하면 서로에게서 시그널만 기다릴 가능성이 있다.

### 읽기-쓰기

- 읽기 스레드가 공유 자원을 주로 사용하고 쓰기 스레드는 이따금 갱신한다.
- 처리율을 강조하면 기아 현상이 발생하거나 오래된 정보가 쌓인다.
- 갱신을 허용하면 처리율에 영향을 미친다.
- 대개는 쓰기 쓰레드가 버퍼를 오랫동안 점유해서 읽기 스레드를 기다리느라 처리율이 떨어진다.
- 간단한 해법으로 읽기 스레드가 없을 때까지 쓰기 스레드가 버퍼를 기다리게 한다.
    - 읽기 스레드만 계속되면 쓰기 스레드는 기아 상태가 될 수 있다.
    - 쓰기 스레드에게 우선권을 주어서 계속 되면 처리율이 떨어진다.
    - 균형을 잡는 방법이 필요하다.
    
### 식사하는 철학자들

- 원탁에 철학자가 앉아있고 양쪽에 포크가 있을 때만 식사할 수 있다.
- 옆 사람이 먹고 있다면 기다려야 한다.

---

대다수의 다중 스레드 문제는 위의 세 가지 중 하나에 속한다. 각 알고리즘을 공부하고 해법을 구현하면 나중에 실전에서 해결이 쉬워진다.

## 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

- synchronized 메서드 사이에 의존성이 존재하면 버그를 찾기 어렵다.
- 공유 객체 하나에는 메서드 하나만 사용한다.

여러 메서드를 사용해야 한다면 다음 방법을 고려한다.

- 클라이언트에서 잠금
    - 클라이언트에서 첫번째 메서드를 호출하기 전에 서버를 잠근다.
    - 마지막 메서드를 호출할 때까지 잠금을 유지한다.
- 서버에서 잠금
    - 서버에 서버를 잠그고 모든 메서드 호출 뒤에 잠금을 헤제하는 메서드를 구현한다.
    - 클라이언트는 이 메서드를 호출한다.
- 연결(Adapted) 서버
    - 잠금을 수행하는 중간 단계를 생성한다.
    - 서버에서 잠금과 유사하지만 서버를 변경하지는 않는다.
    
## 동기화하는 부분을 작게 만들어라

- 자바에서 synchronized를 쓰면 락을 설정하는데, 락은 스레드를 지연시키고 부하를 가중시킨다.
- 임계 영역은 반드시 보호한다.
    - 임계영역 수를 최대한 줄여야 한다.
    - 크기를 키우면 스레드 간 경쟁이 늘어나고 성능이 떨어진다.
    
## 올바른 종료 코드는 구현하기 어렵다

- 자식 스레드가 데드락에 걸렸다면 부모 스레드는 영원히 기다리다 시스템을 종료하지 못한다.
- 종료 코드를 개발 초기부터 고민하고 동작하도록 구현한다.

## 스레드 코드 테스트하기

- 문제를 노출하는 테스트 코드를 작성한다.
- 설정과 부하를 바꿔가며 자주 돌린다.
- 테스트가 실패했을 때 다시 돌리면 통과한다고 넘어가면 안된다.

### 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라

- 시스템 실패를 일회성이라 치부하지 마라

### 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만든다

- 스레드가 호출하는 POJO를 먼저 만든다.
- 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라.
    - 스레드 환경 밖에서 먼저 코드를 올바로 돌려라.

### 다중 스레드를 쓰는 코드를 다양한 환경에 쉽게 끼워 넣을 수 있도록 구현하라

- 여러 스레드로 실행하거나 실행 중에 스레드 수를 바꿔본다.
- 실제 환경이나 테스트 환경에서 돌려본다.
- 테스트 코드를 빨리, 천천히 다양한 속도로 돌려본다.
- 반복이 가능하도록 작성한다.

### 다중 스레드를 쓰는 코드를 상황에 맞게 조율할 수 있도록 한다

- 스레드 개수를 조율하기 쉽게 한다.
- 실행 중에 바꿀 수 있게 한다.
- 처리율과 효율에 따라 개수를 스스로 조율하게 해본다.

### 프로세서 수보다 많은 스레드를 돌려보라

- 스레드를 스와핑할 때 문제가 발생한다.
- 프로세서 수보다 많은 스레드를 돌린다.
    - 스와핑이 많을 수록 임계 영역을 빼먹거나 데드락인 코드를 찾을 수 있다.
    
### 다른 플랫폼에서 돌려보라

- 운영체제에 따라 스레드 정책이 달라 결과가 다를 수 있다.

### 코드에 보조 코드를 넣어 돌리고 강제로 실패하게 해보라

- 스레드 버그는 소수여서 발견과 재현이 어렵다.
- Object.wait(), sleep(), yield(), priority()를 이용해 다양한 순서로 코드를 실행해본다.

```java
public class Example {
    public synchronized String nextUrlOrNull() {
        if(hasNext()) {
            String url = urlGenerator.next();
            
            // 테스트를 위해 추가한다.
            Thread.yield();
            
            updateHasNext();
            return url;
        }
        
        return null;
    }
}
```

yield()를 넣으면 코드 실행 경로가 바뀌어 실패 케이스를 알아낼 수 있다. 하지만 이 방법은 코드를 어디에 넣어야할지 찾기 어렵고 배포 환경에 그대로 남길 수 없는 등의 문제가 있다.

```java
public class Example {
    public synchronized String nextUrlOrNull() {
        if(hasNext()) {
            ThreadJigglePoint.jiggle();
            String url = urlGenerator.next();
            
            ThreadJigglePoint.jiggle();
            
            updateHasNext();
            ThreadJigglePoint.jiggle();
            
            return url;
        }
        
        return null;
    }
}
```

보조 도구를 사용해 무작위로 호출하도록 자동화할 수 있다.

## 결론

- 다중 스레드 코드는 구현하기 어렵다.
- SRP를 준수한다.
- 동시성 오류를 일으키는 원인을 철저히 알아낸다.
- 사용하는 라이브러리와 기본 알고리즘을 이해한다.
- 보호할 코드를 찾아내는 방법과 잠그는 방법을 이해한다.
- 테스트 코드를 계속 반복한다.