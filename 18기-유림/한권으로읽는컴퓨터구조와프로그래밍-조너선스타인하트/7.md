7장. 데이터 구조와 처리 - 어떻게 해야 프로그램에서 데이터를 잘 구성하고 처리할까



데이터 구조: 데이터를 조직화하는 표준적인 방법. 데이터 구조 중 상당수는 여러 유형의 메모리를 더 효율적으로 사용하기 위해 존재한다.

참조 지역성: 필요한 데이터를 메모리에서 서로 근처에 유지하고, 금방 사용할 데이터라면 더 가까운 곳에 저장하라는 의미



- 기본 데이터 타입

포인터를 잘못 사용하고 이 코드를 새로 등장한 아키텍처로 포팅하면 프로그램이 깨지고 종종 디버깅하기 어려운 방식으로 잘못되는 경우가 있다. 이를 해결하기 위해 사람들은 이식성에 관심을 기울이기 시작했다. 또는 자바처럼 포인터를 없앤 언어를 만들었다.



- 배열

배열을 바라보는 다른 관점은 상대 주소 지정이라는 렌즈를 통하는 것이다. 각 원소는 기저 주소로부터 얼마나 멀리 떨어져 있는지 오프셋으로 나타낸다.



- 비트맵

비트맵에 대해 수행할 수 있는 기본 연산은 네가지, 그 연산 방법은

set 비트 설정하기(1로 만들기): 비트들 = 비트들 OR 마스크,

clear 비트 지우기(0으로 만들기): 비트들 = 비트들 AND (NOT 마스크),

비트가 1인지 검사하기: 비트들 AND 마스크 = not 0,

비트가 0인지 검사하기: 비트들 AND 마스크 = 0



- 문자열

문자열 길이를 추적할 가장 편한 방법은 문자열 데이터 안에 문자열 길이를 어찌어찌 넣는 것이다.



- 복합 데이터 타입

구조체: 편의 문법



- 단일 연결 리스트

목록에 들어갈 원소 개수를 모르는 경우 유용하다. 구조체를 사용해 만들 수 있다.



- 동적 메모리 할당

정적으로 할당된 데이터 영역 다음에 프로그램 런타임 라이브러리가 설정해주는 힙 영역이 있다. 별도의 메모리 관리 유닛(MMU)이 없는 컴퓨터라면 이 힙 영역이 프로그램에 사용할 수 있는 모든 데이터 메모리다.

배열 등의 변수가 사용하는 메모리는 정적이다. 리스트 노드와 같은 존재는 동적이다. 동적인 대상에 사용할 메모리를 힙에서 얻는다.

프로그램은 힙을 관리할 수 있어야 한다. C에는 malloc과 free 함수가 있다.

malloc  구현 중에는 단일 연결 리스트 데이터 구조를 사용해 작동하는 구현이 있다. 힙은 여러 블록으로 나뉘고, 각 블록에는 크기와 다음 블록에 대한 포인터가 포함된다.

프로그램이 메모리를 요청하면 malloc이 충분한 크기의 블록을 찾아서 요청받은 공간에 대한 포인터를 돌려준다. free로 메모리를 해제하면 메모리가 다시 연결 리스트에 추가된다.



- 더 효율적인 메모리 할당

노드에 문자열을 가리키는 포인터가 포함된 연결 리스트가 있다. 이런 경우 노드와 문자열을 동시에 할당하면 부가 비용을 줄일 수 있다. 이는 노드를 삭제할 때도 더 효율적이다.



- 가비지 컬렉션

자바나 자바스크립트 같은 언어에는 포인터가 없지만 직접 malloc이나 free를 하지 않으면서도 동적 메모리 할당을 지원한다. 대신에 가비지컬렉션을 구현한다.

포인터 대신 참조를 사용한다. 참조는 포인터를 추상화해서 거의 비슷한 기능을 제공하지만 실제 메모리 주소를 노출하지는 않는다.

가비지 컬렉션의 트레이드 오프는, 프로그래머가 가비지 컬렉션 시스템을 제어할 수 없다는 점이다. 이로 인해 프로그램이 아주 중요한 일을 하는 도중에 가비지 컬렉션 시스템이 작동돼서 문제가 생기는 경우도 있다.



- 이중 연결 리스트

단일 연결 리스트처럼 노드에 다음 원소에 대한 포인터뿐만 아니라 이전 원소에 대한 포인터도 들어 있다. 이중 연결 리스트에서 노드 삭제나 삽입 연산을 할 때는 리스트를 순회할 필요가 없다.



- 대용량 저장장치

디스크의 기본 단위는 블록, 연속적인 블록은 클러스터라고 부른다.

어떤 데이터를 저장하기 위한 저장소 블록을 찾는 대신, 어떤 데이터를 저장하기에 충분한 크기가 되도록 고정된 크기의 블록을 여럿 확보해서 데이터를 나눠 담아야 한다.

파일 이름이 필요하고, 이름과 데이터가 담긴 디스크 블록을 연결해줄 방법이 필요하다. 유닉스에서 블록 중 일부를 아이노드(인덱스+노드)로 따로 지정한다. 아이노드에는 직접 블록 포인터가 12개 있다. 직접 블록을 통해서 49,152바이트까지 데이터를 보관할 수 있다. 파일이 더 커지면 간접 블록을 사용한다. 

아이노드 정보 중에는 블록에 데이터가 있는지 디렉터리 정보가 있는지를 표시하는 것도 있다. 계층적 파일 시스템.

여러 아이노드가 같은 블록을 참조할 수 있다. 각 참조를 링크라고 부른다. 디렉터리에 링크를 하면 편리하다는 사실을 통해 심볼릭 링크가 생겨났다. 하지만 이로 인해 시스템 그래프에 루프가 생겨 무한루프를 감지하기 위한 특별한 코드가 필요하다.

가용 공간을 추적하는 효율적인 방법으로 각 블록을 1비트로 표현하는 비트맵을 사용한 방식을 들 수 있다. 하지만 파일 시스템 그래프와 가용 공간을 나타내는 비트맵 사이에 동기화가 깨질 수 있다는 문제가 있다. 



- 데이터베이스

2진 트리는 데이터를 메모리에 저장할 때는 훌륭한 방법이지만, 메모리 안에 들어갈 수 없을 정도로 커다란 데이터를 저장할 때는 별로다. 트리 노드는 크기가 작아서 디스크 섹터에 잘 들어맞지 않기 때문이다.

데이터베이스는 B트리라는 데이터 구조를 활용한 시스템이다. 균형 트리이지만 2진 트리는 아니다. 2진 트리보다는 공간을 덜 효율적으로 사용하지만 성능이 더 낫고, 특히 디스크에 데이터를 저장할 때 균형 2진 트리보다 더 성능이 좋다. B트리는 메모리 아키텍처에 대한 이해가 더 효율적인 코드를 작성하는 데 도움이 되는 또 다른 경우라 할 수 있다.



- 인덱스

인덱스의 경우 유지보수를 해야한다는 트레이드 오프가 있다. 데이터가 바뀔 때마다 모든 인덱스를 갱신해야 한다. 하지만 데이터 변경보다 검색이 더 자주 일어나기 때문에 갱신 비용은 지불할 만한 비용이다.



- 데이터 이동

페이지 테이블을 MMU에 넣거나 꺼낼 때, 디스크 비트맵을 디스크에 저장하거나 읽어올 때와 같은 시점에 복사를 해야 한다.



- 벡터를 사용한 I/O

시스템에게 프레임의 각 부분을 가리키는 포인터의 집합을 전달하고, 시스템이 오디오장치에 데이터를 쓸 때 각 부분을 하나로 합쳐주면 더 효율적이다.



- 객체 지향의 함정

객체에는 함수에 해당하는 메서드와 데이터에 해당하는 프로퍼티가 들어 있다. 어떤 객체에 필요한 모든 데이터와 함수는 한 데이터 구조 안에 모여 있다. C는 타입 캐스팅과 포인터, 특히 함수를 가리키는 포인터를 지원하기 때문에 이런 데이터 구조에서 큰 이점을 제공한다.

객체와 관련된 부가 비용이 어느 정도 존재한다. 객체는 전역적으로 알려진 함수 대신에 자신이 사용할 메서드에 대한 포인터를 가지고 다녀야 한다. 따라서 객체 내의 데이터가 데이터만 저장하는 구조처럼 꽉 짜여 있지 않다. 성능이 결정적으로 중요할 때는 전통적인 배열을 활용하라.



- 정렬

우선, 정렬 대상이 포인터 크기보다 크다면 데이터를 직접 정렬하는 대신 데이터를 가리키는 포인터를 재배열하는 방식으로 정렬해서 데이터 자체가 여기저기로 움직이지 않게 해야 한다.

아스키코드를 바탕으로 하는 strcmp는 다른 locale, 언어(자연어)를 지원하게 되면서 부작용이 생겼다.



- 해시

해시 함수의 결괏값을 사용해 키에 대응하는 데이터를 메모리에 저장할 수 있다. 따라서 해시 함수는 메모리 크기보다 작은 범위의 값을 만들어내야 한다. 키에 대한 사전 정보가 없기 때문에 완벽한 해시 함수를 만드는 것은 불가능하다.

좋은 해시 함수는 계산하기 쉬워야 하고, 키를 골고루 버킷에 뿌려줘야 한다. 텍스트에 대해 꽤 잘 동작하는 해시 함수로는 문잣값을 모두 더하는 함수가 있다. 이런 함수는 합계가 해시 테이블 인덱스 최댓값보다 커질 수 있다는 문제가 있지만, 합계를 해시 테이블 크기로 나눈 나머지를 사용하면 쉽게 이 문제를 해결할 수 있다. 문잣값을 모두 더한 값이 골고루 분포하기 위해서는 해시 테이블 크기를 소수로 만들면 좋다.

저장할 데이터 개수를 미리 알지 못하면 해시 테이블 크기를 잘 고르기는 어렵다. 체인 길이를 추적하다가 체인이 너무 길어지기 전에 해시 테이블을 확장할 수 있다. 이는 비용이 많이 드는 연산이지만 검색에 비해 자주 발생하는 연산은 아니므로 이익이다.

해시 함수에서 성배(holy grail)는 완전 해시다. 각 키를 유일한 버킷에 연결해준다.



- 효율성과 성능

덜 효율적인 알고리즘을 돌려도 더 많은 프로세서를 사용하면 더 효율적인 알고리즘을 더 적은 프로세서에서 실행할 때보다 나은 성능을 얻을 수도 있다.

데이터베이스 샤딩. 수평 파티셔닝. 인터페이스를 통해 요청이 들어온 데이터베이스 연산을 모두 샤드에 전달한다. 컨트롤러가 결과를 하나로 모은다. 작업을 병렬적으로 수행하여 성능이 향상된다.

샤딩의 변종으로 맵리듀스가 있다. 근본적으로 컨트롤러가 중간 결과를 모으는 방법을 코드로 직접 작성할 수 있게 해준다.



- 정리

하드웨어에 대한 내용을 응용해 데이터를 더 잘 조직화하는 방법을 소개

