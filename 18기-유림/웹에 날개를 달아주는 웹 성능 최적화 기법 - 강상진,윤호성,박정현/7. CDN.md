> p241-255

### 7. CDN



**CDN을 사용하는 이유**

서버 용량은 서비스 가용성 및 안정성에 큰 영향을 미친다. 이를 해결할 쉬운 방법은 

첫번째로 기존 서버의 용량을 증설하는 것이다. 비용이 들지만 기존 아키텍처를 크게 변경하지 않는다. 하지만 원본 사용자와 해외 사용자들 간 지리적 위치가 멀어서 로딩 속도를 보장하기 어렵다.

두번째로 해외에 직접 데이터 센터를 구축한다. 막대한 예산 투입. 철저한 시장 조사와 수요 예측 필요. 복잡한 아키텍처 설계.

세번째 해외에 있는 호스팅 서버 이용. 많은 비용 절감, 하지만 원본 앱 수정, 테스트 및 배포에 대한 계획을 꼼꼼히 세워야 함. 동기화 이슈.

반면에 CDN은 성능 및 안전성을 보장하며 아키텍처를 특별히 변경하지 않아도 된다. 가격이 저렴함.

동적 콘텐츠 가속이 가능하고, 프런트엔드 최적화, 동영상 라이브 스트리밍 서비스에 유용, 클라우드 보안이 특징.



**CDN 서비스 아키텍처**

CDN 서비스는 리버스 프록시 서버 형태로 존재한다. 웹 캐시 서버의 아키텍처와 유사하다. 캐시된 콘텐츠들을 최종 사용자에게 빠르게 전달하기 위해서는 사용자와 가까운 곳에 서버가 위치해야 하므로, CDN 업체들은 많은 곳에 많은 서버들을 배치한다. 이를 **에지 서버** 라고 부르며 업체들은 여러 개의 POP을 만들어 에지 노드들을 구성한다.



**CDN 동작 방법**

일반적으로

브라우저 url 입력 -> DNS 웹 사이트 IP 주소 조회 -> 도메인 네임 조회 -> IP 주소로 콘텐츠 요청. (RTT)

CDN 사용하면

url 입력 -> IP 주소 조회 -> CDN 서비스 제공자의 도메인명 반환 -> 도메인 네임 조회 -> 가까이 위치한 에지 서버 IP로 콘텐츠 요청 -> 캐시되지 않은 경우 원본 서버에서 받아와서 브라우저에 응답



**CDN 적용 방법**

1. 원본 서버로 사용할 호스트명과 IP를 네임 서버의 A 레코드로 추가한다.
2. CDN 설정에 원본 서버의 호스트명 등록
3. 도메인명에 부여돼있던 IP정보를 CDN 서비스 제공자의 도메인명으로 변경



**다중 캐시 전략**

캐시 축출: 정해진 우선순위에 따라 낮은 순위의 콘텐츠를 삭제한다.

롱테일 콘텐츠: 생성 초기 많이 조회되다가 시간이 흐르면 거의 조회되지 않는 콘텐츠 -> 축출



**캐시 서버 간 캐시 콘텐츠 공유**

에지 서버 간 캐시 공유는 ICP 같은 특별한 프로토콜을 사용해 빠르게 이루어져야 한다. 따라서 동일한 백본 네트워크에 연결된 서버 사이에서 이루어진다. 일반적으로 동일한 POP 서버들은 캐시된 콘텐츠를 서로 공유할 수 있다.



**다중 계층 캐시**

에지 서버들과 원본 서버 사이에 추가 캐시 서버 계층을 두어 같은 콘텐츠를 여러 번 캐시하는 방식.

1. 부모 계층은 원본 서버에 가까이 존재해야 하고
2. 부모 계층의 캐시 서버 수가 자식 계층의 캐시 서버 수보다 훨씬 적어야 한다.

과도한 트래픽으로부터 원본 서버 보호 가능

사용자 요청에 대한 응답 속도 향상

/////

**전달 경로 최적화**

**캐시 가능한 콘텐츠 구분하기**

정적 콘텐츠: URL을 호출할 때마다 변함없이 같은 응답을 주는 콘텐츠 (이미지, CSS, JS)

동적 콘텐츠: 사용자가 요청할 때마다 서버에 의해 다시 생성, 응답되는 콘텐츠 (HTTP 요청, Ajax요청, 개인화된 웹 페이지들, JSP, ASP, PHP)

캐시하기 어려운 콘텐츠: 

- 개인화된 콘텐츠- 원본서버에서 가공
- API 호출이나 Ajax 요청에 대한 콘텐츠- 인증이나 결제 등 서버의 작업이 필요하거나 시간에 따라 빠르게 변하는 정보
- Beacon 전달 또는 쿠키 설정을 위한 호출- ?



**올바른 캐시 정책 설정하기**

캐시할 콘텐츠들의 성격을 파악하고 그룹화한다.

1 먼저 캐시할 수 있는 콘텐츠인지 판단한다.

2 캐시할 수 있는 콘텐츠들은 매번 원본 서버에 변경 사항을 확인해야 하는지 판단한다 : cache-control: no-cache / max-age=0

3 캐시할 콘텐츠들의 성격을 판단한다 : cache-control: public / private

4 캐시 주기를 설정하고 max-age를 추가한다



**캐시 주기 결정하기**

1 캐시 주기는 콘텐츠 타입별로 다르게 설정할 수 있다.

이미지나 동영상 등 미디어 파일은 웹 페이지에 게시되면 쉽게 변경되지 않는다. 혹은 링크 자체가 바뀌면 캐시 서버가 해당 콘텐츠를 불러와 캐시하므로 추가 조치가 필요하지 않다. 이미지, 폰트 파일 등은 캐시 주기를 1년 정도로 길게 설정하는 것을 권장.

2 링크 변경 없이 이미지 내용만 바뀐다면 캐시 무효화 방식으로 캐시에 업데이트.

스타일 시트나 스크립트처럼 화면 렌더링에 관련된 파일들은 캐시 주기를 상대적으로 짧게 설정.

3 모든 정적 파일에 캐시 주기를 길게 설정하고 수동으로 관리한다.

파일명 뒤에 해시값을 자동으로 붙여 파일명을 변경하기

파일 요청 시에 쿼리 스트링으로 버전을 지정하기



고객 반응에 민감한 웹 사이트 관리자들은 정적 리소스도 캐시하지 않으려고 한다. 이런 경우 no-storee보다 no-cache, max-age=0을 권한다. 



**캐시에 적합한 디렉터리 구조 구성하기**

/static/image...css...js

/static/*

캐시 주기별로

/static/js/lib

/static/js/module/A

/static/js/module/B



**캐시 키 올바르게 사용하기**

일반적인 캐시 키는 클라이언트가 요청하는 url을 사용한다.

원본 서버에 하나의 원본 파일만 존재하는데 캐시에 복사본이 여러 개 존재하는 것을 **캐시 오염**이라고 한다. 

캐시 오염 제거를 위해서는

1 URL에 붙은 특정 쿼리 스트링 값이 달라지더라도 응답이 항상 같다면 캐시 키에서 쿼리 스트링을 무시하도록 설정한다.

2 쿼리 스트링의 순서를 동일하게 정렬한다. 

3 Vary 헤더를 바르게 사용한다. 

**캐시 충돌**이란 요청 URL이 하나인데 브라우저 환경에 따라 서버에서 제공하는 응답이 달라져 결국 최초 요청한 브라우저의 응답만 캐시되는 것을 의미한다.

캐시 충돌 방지를 위해서는

기본적으로 동적 페이지에는 캐시를 적용하지 않아야 한다.

홈페이지의 첫 HTML은 캐시하지 않는다. 일부 동적 페이지에 캐시를 사용하고자 한다면 Cache-Control: private으로 사용자 브라우저에만 캐시하여 페이지 로딩 시간을 단축할 수 있다.



**CDN 사용하기**

캐시는 사용자에게 가깝게. 글로벌 사용자를 대상으로 웹 사이트를 운영하게 된다면 CDN 서비스로 콘텐츠를 사용자 가까이 캐시할 것을 권장.

CDN을 사용하면 세계 여러 지역 데이터 센터들에 리버스 프록시 캐시 서버를 두고 필요한 정적 콘텐츠들을 저장해놓을 수 있다.



**동적 콘텐츠 캐시**

서버에서 동적 콘텐츠를 처리하는 시간이 전체 응답 중 많은 부분을 차지한다. 이들을 캐시하면 사용자 체감 응답 시간을 단축시키고 서버의 리소스를 절약할 수 있다. 정적 콘텐츠를 캐시하는 것보다 더 많은 성능 개선 효과를 얻는다.

1. 동적 정보를 쿠키에 넣어 보낸다
2. Ajax 요청으로 관련 정보를 동적으로 받아온다

요청 쿠키, 헤더 혹은 쿼리 스트링에 동적 콘텐츠가 있으면 이 정보들을 캐시 키에 추가함으로써 동적 콘텐츠를 캐시할 수 있다.

이 때 보안에 주의해야 하는데, 개인화 콘텐츠에는 사생활을 침해하는 개인 정보가 포함되어 있을 수 있어 캐시 전에 이를 확인해야 한다. 대부분의 개인 정보는 POST 요청으로 보내고, POST 요청에 대한 응답은 캐시하지 않는 것이 일반적.

캐시 서버 용량에 유의, 캐시 서버의 용량이 소진되면 이전 객체를 지우기 위해 CPU 사용량이 늘어나 결국 캐시 효율이 떨어진다. 과도한 캐시는 지양해야 한다. 로그인 전, 브라우저 타입, 사용자 성별에 따른 콘텐츠 등 크게 그룹화할 수 있는 콘텐츠들에 국한에 사용하는 것을 권장한다.

캐시 주기로 0 TTL을 사용하려면 서버에서 해당 콘텐츠에 대한 If-Modified-Since(IMS) 요청을 지원해야 한다. 지원하지 않으면 캐시 서버는 모든 요청을 서버로 보내고 서버는 매 요청마다 새로운 콘텐츠로 응답하므로 캐시하지 않는 것과 동일하다.



**POST 응답 캐시**

HTTP 페이로드 메시지에 쿼리 스트링을 포함시켜 보낼 때 사용한다. 데이터 크기에 제한이 없고 보안 측면에서도 상대적으로 안전하다.

일반적으로 POST 요청 본문에 포함된 매개 변수들에 의해 결정된다. 입력 매개 변수가 동일할 때 서버로부터 항상 동일한 응답이 반환되면, 그 응답 내용이 공개되어도 안전한 내용이라면 캐시할 수 있다. 단 캐시 키에 요청 매개 변숫값들이 모두 포함되어야 캐시 오염, 충돌 같은 오류 현상을 방지할 수 있다. 캐시 키에 매개 변숫값들이 노출되지 않아야 하므로 MD5 같은 해시 알고리즘을 이용해 타인이 쉽게 알 수 없도록 값을 암호화해야 한다.



**고급 캐시 전략**

**Edge Side Include**

HTML이 서버에서 브라우저에 도달하는 시간을 Time To First Byte라고 하며 웹 사이트 성능을 측정하는 중요한 지표이다. 페이지에서 동적으로 변하는 프로필 부분은 매우 작지만, 이 부분 때문에 전체 HTML 페이지를 캐시할 수 없어 페이지 로딩 속도에 영향을 미친다. 이 부분을 따로 떼어 별도로 수행시킨 후 캐시된 나머지 부분과 다시 조합할 수 있다면 로딩 성능이 개선된다.



**ESI?**

ESI는 Ajax처럼 서버를 주기적으로 호출할 수 없어 주기적 업데이트가 많이 필요한 용도에는 적합하지 않다. 동적 콘텐츠 생성에 너무 많은 시간이 소요되거나 응답이 없을 경우 오히려 성능 저하를 일으키거나 단일 실패 지점이 발생할 위험이 있다. 과도한 연산이 필요한 페이지에도 적합하지 않다.

서로 다른 성격의 콘텐츠를 각각의 캐시 정책을 사용해 캐시하고자 할 때 유용하다. 각 콘텐츠를 다르게 캐시하기 위해 웹 캐시 설정에 콘텐츠별 캐시 주기를 다르게 지정하고 메인 HTML 안에 ESI를 사용해 나머지 콘텐츠들을 적절히 조합하면 된다.



**HTML5 로컬 스토리지**

최소 5Mb 크기의 웹 스토리지 API로 더 많은 데이터를 안전하게 저장할 수 있다. 프로토콜을 포함한 도메인별로 저장되며 같은 도메인 내에서는 모든 리소스에서 접속할 수 있다.

쿠키는 네트워크를 통해 전달되어 보안에 취약하다. 별도 제한이 없다면 같은 도메인의 모든 요청에 쿠키가 추가되어 네트워크 대역폭을 낭비한다.

폰트 파일 역시 로컬 스토리지에 저장하면 폰트로 인한 사이트 로딩 지연을 방지할 수 있다.

