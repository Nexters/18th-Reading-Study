> p189-221

### 6. 캐시 최적화



**캐시**

특정 요청에 대한 데이터를 메모리나 메모리에 가까운 저장소에 Key, Value 형태로 저장하고 인덱스로 빠르게 찾아 응답한다면 서버의 부담이 줄고 응답 시간도 크게 단축할 수 있다.

브라우저가 사용하는 브라우저 캐시 또는 로컬 캐시

서버에서 성능 향상을 위해 별도로 사용하는 리버스 프록스 형태의 캐시 서버

리버스 프록시 서버 - 웹 서버, 리버스 프록시 캐시 서버 - 웹 캐시



오픈 소스 웹 캐시 서버

- Apache Traffic Server: 아파치 웹 서버, 성능 확장성 뛰어남
- Nginx: 대중적인 웹 서버, 콘텐츠 캐시 기능 제공
- Vamish Cache: 캐시를 통한 HTTP 가속이 목적



**웹 캐시 동작 원리**

웹 캐시는 **웹 서버**와 **웹 브라우저** 중간에 존재하면서 최초 원본 콘텐츠 요청을 최종 서버에 보내 응답을 받은 후 복사본을 만들어 저장하고 사용자에게 응답한다.

이후 같은 콘텐츠에 대한 요청이 오면 복사본을 전달한다. 원본 서버로의 트래픽을 줄이고 사용자의 요청에 대한 반응 속도를 빠르게 한다.

요즘처럼 사용자 기호에 따라 웹 페이지가 개인화되어 있는 경우, 개인 정보 보호를 위해 그 콘텐츠를 캐시해선 안된다. 또한 캐시에 저장된 콘텐츠가 변경되면 캐시는 이를 감지해 다시 원본 서버에 원본 콘텐츠를 요청해야 한다.



**HTTP**

인터넷에서 데이터를 주고받기 위한 클라이언트/서버 모델을 따르는 프로토콜. 7계층이며 TCP/IP 위에서 동작. 일단 TCP Connection이 맺어지면 HTTP는 어떤 종류의 데이터든 전송할 수 있도록 설계됐다.

클라이언트가 특정 URL에 요청(req)을 보내면 서버는 요청을 처리해 URL에 해당하는 응답(res)을 돌려보낸다.

비연결성이며 상태를 유지하지 않는 프로토콜이다. HTTP 메시지를 주고받으며 통신한다. 메시지는 헤더와 바디 부분으로 구분되어 전송된다.

헤더에는 메시지를 전송할 호스트명, URL 패스 등 메시지 전송 및 처리에 필요한 데이터들이 포함되어 있다. 페이로드(바디)에는 html, 이미지 등 서버가 실제 전송하고자 하는 데이터를 포함한다.



**HTTP의 캐시 제어 방식**

HTTP/1.0 - Expire 헤더를 사용해 원본 서버 콘텐츠의 유효 기간을 지정, Expire와 Date 헤더를 함께 보내며, Time To Live(TTL) = Expire_value - Date_value 이다.

HTTP/1.1 - Cache-Control: max-age 헤더를 사용해 캐시에서 특정 콘텐츠를 얼마나 오래 유지하고 있어야 하는지 명시적으로 설정한다. 기간이 지나면 해당 콘텐츠 변경 여부를 체크하거나 새로 갱신해야 한다.

HTTP/1.0 기반 서버는 1.1을 지원하지 않고, HTTP/1.1 기반 서버는 Cache-Control을 우선 사용한다.

Cache-Control: public 사용자 제한 없이 모든 사용자에게 응답이 전달된다

Cache-Control: private 응답은 요청한 사용자만 캐시할 수 있고 CDN 같은 범용 캐시에서는 캐시할 수 없다. 범용 캐시 서버에서도 캐시할 수 있지만 그 응답을 모든 사용자에게 공유할 수 없다. 개인정보를 보호하는 장치가 되지는 않는다.

Cache-Control: no-cache '캐시된 응답을 받지 않겠다'는 메시지를 전달한다. max-age=0을 사용하는 것과 비슷하지만 미묘한 차이가 있다. no-cache를 설정하면 캐시 서버는 항상 원본 서버로부터 최신 응답을 받아와야 한다. 그러나 max-age=0은 캐시 서버가 원본 서버에서 전체 응답을 가져오기보다 이후 설명할 조건부 요청을 이용해 캐시된 콘텐츠에 변경이 있는지를 먼저 검증한다.

Cache-Control: no-store 서버가 로컬 저장소에 메시지를 저장하지 않도록 지시한다. 개인 정보 수준이 조금 향상될 수 있지만 완벽한 보안 메커니즘으로 신뢰하기는 어렵다.



**캐시 유효성 체크**

저장된 응답 TTL이 만료되었을 경우에도 콘텐츠에 변화가 없을 시에 새 응답을 받아오지 않는다. 301(Not-modified) 코드만 헤더에 설정하여 보내서 서버와 네트워크 자원 낭비를 방지한다.

- 시간 기반의 조건부 요청

어떤 요청에 대한 원본 서버의 콘텐츠가 캐시에 저장된 후 변경되었는지 여부를 콘텐츠의 최종 변경 시간 중심으로 확인하는 방법. 저장된 객체가 변경되어 새로 저장되면 그 날짜와 시간을 메타 데이터로 남긴다. 원본 서버가 콘텐츠에 대한 응답을 만들어 보낼 때 Last-Modified라는 헤더에 최종 변경 날짜와 시간을 적어 보낸다.

- 콘텐츠 기반의 조건부 요청

콘텐츠 고윳값 중심으로 변경 여부를 확인한다. 주로 해시값으로 추출한다. 원본 서버는 미리 정의된 대로 이 값을 만들어 ETag 헤더에 이 고윳값을 넣어 보낸다. Etag는 임의의 문자들이 따옴표 안에 포함되도록 하며 이 값은 전적으로 원본 서버가 결정한다. 이 헤더는 원본 서버의 시계 문제로 날짜와 시간을 파악할 수 없을 때 유용하게 사용된다.



**캐시 콘텐츠 갱신**

웹 사이트가 개편되었거나 콘텐츠를 급하게 변경했다면 캐시에 저장된 복사본들을 강제로 갱신해야한다.

- 퍼지

저장소를 완전히 지우는 방식으로 대부분의 캐시 서버가 캐시를 모두 지우는 명령어나 API를 제공한다. CDN을 비롯한 캐시 서버에서 한꺼번에 많은 콘텐츠를 퍼지하려면 원본 서버에 충분한 자원이 있는지 확인하는 등 주의를 기울여야 한다. 캐시되지 않은 많은 요청이 한꺼번에 원본 서버로 몰려 서버 리소스가 많이 사용되는 부담이 있기 때문이다. 갑작스러운 퍼지는 피하고 테스트 툴을 이용해 서비스할 웹 페이지 리소스들을 캐시에 미리 저장해두는 것을 권한다. CDN에 많은 트래픽을 의존한다면 단계적으로 나누어 퍼지하거나 무효화 방안을 사용하는 것을 권장한다.

- 무효화

조건부 요청을 통해 캐시된 리소스들 중 변경이 있었던 리소스들만 새로 갱신하는 방법이다. 

```
// 캐시 서버의 내용을 강제로 무효화하는 방법
Cache-Control: max-age=0, must-revalidate
```

원본 서버나 웹 캐시 서버에서 이러한 무효화 정책을 사용할 경우 퍼지와 동일하게 새 콘텐츠를 받아가려는 트래픽이 잠시 증가할 수 있다. 하지만 대부분 if-modified-since나 if-none-match 요청일 것이라 대역폭 낭비를 줄인다.



**비동기 캐시 갱신**

```
Cache-Control: max-age=600, stale-while-revalidate=30
```

600초 동안은 캐시에 저장된 리소스를 서비스 받고, 이후 30초는 만료되었지만 여전히 캐시되어 있는 리소스를 서비스 받는다. 캐시는 그동안 서버와 통신해 새로운 콘텐츠를 비동기적으로 받아오게 한다.



**캐시 최적화 방안**

**캐시 가능한 콘텐츠 구분하기**

정적 콘텐츠: URL을 호출할 때마다 변함없이 같은 응답을 주는 콘텐츠 (이미지, CSS, JS)

동적 콘텐츠: 사용자가 요청할 때마다 서버에 의해 다시 생성, 응답되는 콘텐츠 (HTTP 요청, Ajax요청, 개인화된 웹 페이지들, JSP, ASP, PHP)

캐시하기 어려운 콘텐츠: 

- 개인화된 콘텐츠- 원본서버에서 가공
- API 호출이나 Ajax 요청에 대한 콘텐츠- 인증이나 결제 등 서버의 작업이 필요하거나 시간에 따라 빠르게 변하는 정보
- Beacon 전달 또는 쿠키 설정을 위한 호출- ?



**올바른 캐시 정책 설정하기**

캐시할 콘텐츠들의 성격을 파악하고 그룹화한다.

1 먼저 캐시할 수 있는 콘텐츠인지 판단한다.

2 캐시할 수 있는 콘텐츠들은 매번 원본 서버에 변경 사항을 확인해야 하는지 판단한다 : cache-control: no-cache / max-age=0

3 캐시할 콘텐츠들의 성격을 판단한다 : cache-control: public / private

4 캐시 주기를 설정하고 max-age를 추가한다



**캐시 주기 결정하기**

1 캐시 주기는 콘텐츠 타입별로 다르게 설정할 수 있다.

이미지나 동영상 등 미디어 파일은 웹 페이지에 게시되면 쉽게 변경되지 않는다. 혹은 링크 자체가 바뀌면 캐시 서버가 해당 콘텐츠를 불러와 캐시하므로 추가 조치가 필요하지 않다. 이미지, 폰트 파일 등은 캐시 주기를 1년 정도로 길게 설정하는 것을 권장.

2 링크 변경 없이 이미지 내용만 바뀐다면 캐시 무효화 방식으로 캐시에 업데이트.

스타일 시트나 스크립트처럼 화면 렌더링에 관련된 파일들은 캐시 주기를 상대적으로 짧게 설정.

3 모든 정적 파일에 캐시 주기를 길게 설정하고 수동으로 관리한다.

파일명 뒤에 해시값을 자동으로 붙여 파일명을 변경하기

파일 요청 시에 쿼리 스트링으로 버전을 지정하기



고객 반응에 민감한 웹 사이트 관리자들은 정적 리소스도 캐시하지 않으려고 한다. 이런 경우 no-storee보다 no-cache, max-age=0을 권한다. 



**캐시에 적합한 디렉터리 구조 구성하기**

/static/image...css...js

/static/*

캐시 주기별로

/static/js/lib

/static/js/module/A

/static/js/module/B



**캐시 키 올바르게 사용하기**

일반적인 캐시 키는 클라이언트가 요청하는 url을 사용한다.

원본 서버에 하나의 원본 파일만 존재하는데 캐시에 복사본이 여러 개 존재하는 것을 **캐시 오염**이라고 한다. 

캐시 오염 제거를 위해서는

1 URL에 붙은 특정 쿼리 스트링 값이 달라지더라도 응답이 항상 같다면 캐시 키에서 쿼리 스트링을 무시하도록 설정한다.

2 쿼리 스트링의 순서를 동일하게 정렬한다. 

3 Vary 헤더를 바르게 사용한다. 

**캐시 충돌**이란 요청 URL이 하나인데 브라우저 환경에 따라 서버에서 제공하는 응답이 달라져 결국 최초 요청한 브라우저의 응답만 캐시되는 것을 의미한다.

캐시 충돌 방지를 위해서는

기본적으로 동적 페이지에는 캐시를 적용하지 않아야 한다.

홈페이지의 첫 HTML은 캐시하지 않는다. 일부 동적 페이지에 캐시를 사용하고자 한다면 Cache-Control: private으로 사용자 브라우저에만 캐시하여 페이지 로딩 시간을 단축할 수 있다.



**CDN 사용하기**