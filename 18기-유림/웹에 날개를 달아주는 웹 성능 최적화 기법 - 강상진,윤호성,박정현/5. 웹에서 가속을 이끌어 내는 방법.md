> p145-168

### 5. 웹에서 가속을 이끌어 내는 방법



**웹 브라우저 현황 알아보기**

데스크톱 1위 크롬, 2위 파이어폭스, 3위 사파리

모바일 1위 크롬, 2위 사파리, 3위 삼성 인터넷 (!!)



**웹 브라우저 동작 이해하기**

사용자가 입력창에 접속하고자 하는 웹 사이트 주소를 입력함으로써 브라우저의 동작이 시작된다.

1 브라우저는 가장 먼저 도메인 서버와 통신하여 접속하려는 호스트의 IP를 찾는다.

2 해당 IP를 가진 서버와 통신을 시도해 TCP 연결을 맺는다. (HTTPS에선 암호화된 연결을 생성하려는 협의 단계가 더 추가된다.)

3 연결이 맺어지면 브라우저는 서버로부터 필요한 리소스들을 다운로드해 이를 화면에 표현한다.

이때 HTML의 구문을 분석(parsing)하면서 HTML 태그에 참조된 CSS, JS, img, font 등의 하위 리소스들을 차례로 다운로드한다.

브라우저는 리소스들을 다운로드하며 동시에 개발자가 원하는 대로 화면에 페이지를 그리는 작업을 수행한다. 이 작업 절차를 렌더링 경로라고 한다.



**브라우저 아키텍처**

- 브라우저 엔진: 렌더링 상태를 조회하고 렌더링 작업을 제어
- 렌더링 엔진: 실제 웹 콘텐츠를 원하는 대로 브라우저 창에 그림 (Webkit-safari, Gecko-firefox, Blink-chrome, Trident-IE)
- 네트워킹: HTTP 요청을 보내고 응답받는 역할. DNS 조회, TCP 연결 등의 작업을 수행. 브라우저별로 6-10개 스레드고 동시에 TCP 연결을 생성해 리소스를 다운로드
- 자바스크립트 해석기: V8, Spider Monkey 등의 엔진, 자바스크립트 분석과 해석
- 데이터 저장소: 쿠키 값을 로컬 디스크에 저장, HTML5에서는 로컬 스토리지, 인덱스 DB 등을 이용해 데이터 저장, 데이터 지속성을 유지하기 위한 컴포넌트



**중요 렌더링 경로**

렌더링 엔진이 웹 페이지를 구문 분석해 화면에 표현하는 작업은 단일 스레드에 의해 수행된다. 

1 HTML을 가장 처음 구문 분석하면서 DOM트리를 만든다.

​	DOM(Documents Object Model)은 C#이나 자바같은 객체 지향적 프로그램 언어들로 HTML이나 XML형태의 마크업 문서들을 손쉽게 프로그래밍하기 위해 표준으로 규정한 인터페이스이다. DOM트리에서는 원하는 태그를 조회하고 수정할 수 있다.

​	DOM은 다른 프로그래밍 인터페이스와 마찬가지로 객체 속성과 메소드 그리고 이벤트 등을 정의한다.

2 CSS를 구문 분석하여 CSSOM트리를 만든다.

​	DOM과 비슷하게 CSS를 처리하기 위한 트리 구조의 프로그래밍 인터페이스이다. 브라우저가 HTML을 구문 분석하며 CSS를 참조하는 링크를 만나면 해당 CSS 리소스를 다운로드하고 구문 분석기가 CSS를 분석하기 시작한다.

​	렌더링 경로상에서 DOM트리와 CSSOM트리는 각각 별도로 생성되고 이후 통합된다. 서로의 구문 분석 과정에 영향을 끼치지 않고 방해받지 않는다.

3 두 개의 트리 모델을 결합해 최종 렌더 트리를 만든다.

​	렌더링을 위한 최종 정보를 가진 렌더 객체들을 생성해 이들의 상하 관계를 트리 모양으로 구성한 것이 렌더 트리이다.

4 이를 기반으로 페이지 구조를 결정하고 화면에 표현한다.

​	레이아웃은 렌더 트리 노드들의 위치 정보가 계산되는 단계이다. 렌더 트리의 루트 노드부터 계산이 시작되는데 루트 노드의 너비는 뷰포트의 크기로 지정된다. **너비는 부모 노드에서 자식 노드로 재귀**하여 반복 수행된다. **높이는 역으로 자식 노드의 높이에 따라 부모 노드의 높이를 계산**한다. 이 역시 재귀적으로 반복 수행하며 위치가 계산된다.

​	페인트는 렌더 트리 정보를 바탕으로 브라우저 창에 표현하는 단계이다. GPU를 이용해 그리기만 하면 된다.



자바스크립트는 DOM과 CSSOM을 동적으로 변경할 수 있으며 이 경우 렌더 트리가 변경되고 레이아웃, 페인트 단계가 다시 수행된다.



**브라우저 렌더링 최적화하기**

**DOM 최적화하기**

HTML은 구문 체크에 관대하다. 다양한 오류를 포용하기 위해 수많은 오류 사항에 대한 예외 처리 방안을 구현한다. 예를 들어 제한된 숫자 이상 중첩된 태그가 많거나, 태그를 열고 닫지 않거나, 테이블 안에 테이블이 겹치는 등의 오류가 발생하면 내부 알고리즘에 의해 중첩된 태그를 제거하고, 적절한 위치에서 태그를 닫고, 겹친 테이블을 분리하는 일련의 작업을 수행한다. 따라서 웹 페이지 내에 오류가 많을수록 브라우저는 예외 처리를 위해 더 많은 메모리와 CPU파워를 소모한다.

일반적으로 중첩된 태그들이 15단계를 넘지 않도록 HTML을 작성하는 것을 권장한다.

[DOM을 분석해 최적화 방안을 알려주는 무료 도구](http://mir.aculo.us/dom-monster/)



**자바스크립트와 CSS 배치하기**

자바스크립트는 이미 생성된 DOM을 변경시킬 수 있기 때문에 HTML 구문 분석기가 자바스크립트를 만나면 이 수행이 완료될 때까지 DOM 생성 작업을 중단한다.

하지만 그 시점에 특정 CSS에 대한 구문 분석 처리 및 CSSOM 생성 작업이 진행 중이라면 자바스크립트가 변경하려는 스타일 시트가 아직 생성되지 않았을 수 있다. 해당 자바스크립트는 CSSOM 생성이 완료될 때까지 수행을 중지하고 대기한다.

만약 원하는 스타일 시트가 채 생성되기도 전에 자바스크립트가 이를 수정하려는 경우 스크립트 오류가 발생하고 웹 페이지가 생성되지 않는다. CSS가 JS보다 더 높은 우선순위를 가진다.

CSS를 소스 위쪽에, JS를 소스 아래쪽에.



**자바스크립트 최적화하기**

하지만 자바스크립트를 HTML 위쪽에 배치해야 하는 경우도 부지기수이다. 자바스크립트 수행이 렌더링 스레드를 방해하지 않도록 별도 스레드로 자바스크립트를 수행시킬 수 있다. 또는 렌더링 작업이 어느 정도 끝난 후 스크립트를 수행한다. 관련 속성을 활용한다.

```html
<script src="async_script.js" async></script>
<script src="defer_script.js" defer></script>
```

async 속성은 HTML 구문 분석과 동시에 자바스크립트를 다운로드하고 수행되도록 한다.

defer 속성은 구문 분석 중에 별도의 스레드로 자바스크립트를 다운로드하고 구문 분석이 끝난 이후에 수행되도록 한다.

async 속성은 지연 수행 시 스크립트 간 선후 관계를 따지지 않지만 defer 속성은 스크립트가 호출된 순서에 따라 차례로 수행된다.

주의할 점은 모든 자바스크립트가 지연 처리의 대상이 될 수 없다는 것이다. 자바스크립트는 많은 경우 렌더링에 관여하도록 구현된다. 또한 스크립트 사이에 종속 관계가 있을 수 있으므로 비동기 처리나 지연 처리를 무분별하게 적용하면 원치 않게 화면이 일그러지는 현상이 발생한다. 때문에 초기 렌더링에 꼭 필요한 그룹과 그렇지 않은 그룹으로 분류해 후자의 그룹에 async, defer 속성을 적용해야 한다.

더 확실한 방법은 브라우저가 페이지 로딩을 명시적으로 끝낸 후 나머지 스크립트를 수행시키는 방법이다. onload 이벤트 이후에 스크립트를 수행시키는 것이 페이지 로딩 시간을 단축시키는 확실한 방법이다.



CSS 최적화하기

CSS는 렌더링 순서가 가장 높으면서 동시에 렌더링을 가장 방해하는 리소스다. 때문에 필요한 정보만 빠르게 다운로드하고 실행해야 브라우저 렌더링을 가속시킬 수 있다. 

1 CSS를 적절히 분리하여 필요한 페이지에 필요한 파일만 포함해야 한다.

2 첫 화면에 사용될 CSS 파일과 숨겨진 화면에 사용될 CSS 파일을 분리해 후자의 CSS는 지연 수행시켜야 한다.

```html
<link rel="stylesheet" type="text/css" media="screen and (max-device-width: 480px)" href="styles_base.css">
```

혹은 onload 이벤트 발생 이후 적용되도록 처리한다.

```html
<link ... />
<script>
function deferOnload() {
    var style = document.getElementsByTagName("Link");
    for (var i=0; i<style.length; i++) {
        var a = style[i].getAttribute("defer-ref");
        if (a) style[i].href = a;
    }
}
    
if (window.addEventListener) {
    window.addEventListener("load", deferOnload, false);
} else if (window.attachEvent) {
    window.attachEvent("onload", deferOnload);
} else {
    window.onload = deferOnload();
}
</script>
```



**이미지 로딩 최적화하기**

이미지 압축 이외의 다른 방법들

`display:none` 속성의 이미지를 미리 다운로드 하지 않으려면?

1 `css: background-image` 속성을 사용

2 자바스크립트를 이용한 지연 로딩 방식 적용 - 첫 화면에 등장하지 않거나 숨겨진 이미지들을 다운로드 하는데만 사용

3 Progressive JPG 활용. 고품질 이미지를 분할 전송하는 방식



