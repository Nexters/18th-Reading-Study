> p145-187

### 5. 웹에서 가속을 이끌어 내는 방법



**웹 브라우저 현황 알아보기**

데스크톱 1위 크롬, 2위 파이어폭스, 3위 사파리

모바일 1위 크롬, 2위 사파리, 3위 삼성 인터넷 (!!)



**웹 브라우저 동작 이해하기**

사용자가 입력창에 접속하고자 하는 웹 사이트 주소를 입력함으로써 브라우저의 동작이 시작된다.

1 브라우저는 가장 먼저 도메인 서버와 통신하여 접속하려는 호스트의 IP를 찾는다.

2 해당 IP를 가진 서버와 통신을 시도해 TCP 연결을 맺는다. (HTTPS에선 암호화된 연결을 생성하려는 협의 단계가 더 추가된다.)

3 연결이 맺어지면 브라우저는 서버로부터 필요한 리소스들을 다운로드해 이를 화면에 표현한다.

이때 HTML의 구문을 분석(parsing)하면서 HTML 태그에 참조된 CSS, JS, img, font 등의 하위 리소스들을 차례로 다운로드한다.

브라우저는 리소스들을 다운로드하며 동시에 개발자가 원하는 대로 화면에 페이지를 그리는 작업을 수행한다. 이 작업 절차를 렌더링 경로라고 한다.



**브라우저 아키텍처**

- 브라우저 엔진: 렌더링 상태를 조회하고 렌더링 작업을 제어
- 렌더링 엔진: 실제 웹 콘텐츠를 원하는 대로 브라우저 창에 그림 (Webkit-safari, Gecko-firefox, Blink-chrome, Trident-IE)
- 네트워킹: HTTP 요청을 보내고 응답받는 역할. DNS 조회, TCP 연결 등의 작업을 수행. 브라우저별로 6-10개 스레드고 동시에 TCP 연결을 생성해 리소스를 다운로드
- 자바스크립트 해석기: V8, Spider Monkey 등의 엔진, 자바스크립트 분석과 해석
- 데이터 저장소: 쿠키 값을 로컬 디스크에 저장, HTML5에서는 로컬 스토리지, 인덱스 DB 등을 이용해 데이터 저장, 데이터 지속성을 유지하기 위한 컴포넌트



**중요 렌더링 경로**

렌더링 엔진이 웹 페이지를 구문 분석해 화면에 표현하는 작업은 단일 스레드에 의해 수행된다. 

1 HTML을 가장 처음 구문 분석하면서 DOM트리를 만든다.

​	DOM(Documents Object Model)은 C#이나 자바같은 객체 지향적 프로그램 언어들로 HTML이나 XML형태의 마크업 문서들을 손쉽게 프로그래밍하기 위해 표준으로 규정한 인터페이스이다. DOM트리에서는 원하는 태그를 조회하고 수정할 수 있다.

​	DOM은 다른 프로그래밍 인터페이스와 마찬가지로 객체 속성과 메소드 그리고 이벤트 등을 정의한다.

2 CSS를 구문 분석하여 CSSOM트리를 만든다.

​	DOM과 비슷하게 CSS를 처리하기 위한 트리 구조의 프로그래밍 인터페이스이다. 브라우저가 HTML을 구문 분석하며 CSS를 참조하는 링크를 만나면 해당 CSS 리소스를 다운로드하고 구문 분석기가 CSS를 분석하기 시작한다.

​	렌더링 경로상에서 DOM트리와 CSSOM트리는 각각 별도로 생성되고 이후 통합된다. 서로의 구문 분석 과정에 영향을 끼치지 않고 방해받지 않는다.

3 두 개의 트리 모델을 결합해 최종 렌더 트리를 만든다.

​	렌더링을 위한 최종 정보를 가진 렌더 객체들을 생성해 이들의 상하 관계를 트리 모양으로 구성한 것이 렌더 트리이다.

4 이를 기반으로 페이지 구조를 결정하고 화면에 표현한다.

​	레이아웃은 렌더 트리 노드들의 위치 정보가 계산되는 단계이다. 렌더 트리의 루트 노드부터 계산이 시작되는데 루트 노드의 너비는 뷰포트의 크기로 지정된다. **너비는 부모 노드에서 자식 노드로 재귀**하여 반복 수행된다. **높이는 역으로 자식 노드의 높이에 따라 부모 노드의 높이를 계산**한다. 이 역시 재귀적으로 반복 수행하며 위치가 계산된다.

​	페인트는 렌더 트리 정보를 바탕으로 브라우저 창에 표현하는 단계이다. GPU를 이용해 그리기만 하면 된다.



자바스크립트는 DOM과 CSSOM을 동적으로 변경할 수 있으며 이 경우 렌더 트리가 변경되고 레이아웃, 페인트 단계가 다시 수행된다.



**브라우저 렌더링 최적화하기**

**DOM 최적화하기**

HTML은 구문 체크에 관대하다. 다양한 오류를 포용하기 위해 수많은 오류 사항에 대한 예외 처리 방안을 구현한다. 예를 들어 제한된 숫자 이상 중첩된 태그가 많거나, 태그를 열고 닫지 않거나, 테이블 안에 테이블이 겹치는 등의 오류가 발생하면 내부 알고리즘에 의해 중첩된 태그를 제거하고, 적절한 위치에서 태그를 닫고, 겹친 테이블을 분리하는 일련의 작업을 수행한다. 따라서 웹 페이지 내에 오류가 많을수록 브라우저는 예외 처리를 위해 더 많은 메모리와 CPU파워를 소모한다.

일반적으로 중첩된 태그들이 15단계를 넘지 않도록 HTML을 작성하는 것을 권장한다.

[DOM을 분석해 최적화 방안을 알려주는 무료 도구](http://mir.aculo.us/dom-monster/)



**자바스크립트와 CSS 배치하기**

자바스크립트는 이미 생성된 DOM을 변경시킬 수 있기 때문에 HTML 구문 분석기가 자바스크립트를 만나면 이 수행이 완료될 때까지 DOM 생성 작업을 중단한다.

하지만 그 시점에 특정 CSS에 대한 구문 분석 처리 및 CSSOM 생성 작업이 진행 중이라면 자바스크립트가 변경하려는 스타일 시트가 아직 생성되지 않았을 수 있다. 해당 자바스크립트는 CSSOM 생성이 완료될 때까지 수행을 중지하고 대기한다.

만약 원하는 스타일 시트가 채 생성되기도 전에 자바스크립트가 이를 수정하려는 경우 스크립트 오류가 발생하고 웹 페이지가 생성되지 않는다. CSS가 JS보다 더 높은 우선순위를 가진다.

CSS를 소스 위쪽에, JS를 소스 아래쪽에.



**자바스크립트 최적화하기**

하지만 자바스크립트를 HTML 위쪽에 배치해야 하는 경우도 부지기수이다. 자바스크립트 수행이 렌더링 스레드를 방해하지 않도록 별도 스레드로 자바스크립트를 수행시킬 수 있다. 또는 렌더링 작업이 어느 정도 끝난 후 스크립트를 수행한다. 관련 속성을 활용한다.

```html
<script src="async_script.js" async></script>
<script src="defer_script.js" defer></script>
```

async 속성은 HTML 구문 분석과 동시에 자바스크립트를 다운로드하고 수행되도록 한다.

defer 속성은 구문 분석 중에 별도의 스레드로 자바스크립트를 다운로드하고 구문 분석이 끝난 이후에 수행되도록 한다.

async 속성은 지연 수행 시 스크립트 간 선후 관계를 따지지 않지만 defer 속성은 스크립트가 호출된 순서에 따라 차례로 수행된다.

주의할 점은 모든 자바스크립트가 지연 처리의 대상이 될 수 없다는 것이다. 자바스크립트는 많은 경우 렌더링에 관여하도록 구현된다. 또한 스크립트 사이에 종속 관계가 있을 수 있으므로 비동기 처리나 지연 처리를 무분별하게 적용하면 원치 않게 화면이 일그러지는 현상이 발생한다. 때문에 초기 렌더링에 꼭 필요한 그룹과 그렇지 않은 그룹으로 분류해 후자의 그룹에 async, defer 속성을 적용해야 한다.

더 확실한 방법은 브라우저가 페이지 로딩을 명시적으로 끝낸 후 나머지 스크립트를 수행시키는 방법이다. onload 이벤트 이후에 스크립트를 수행시키는 것이 페이지 로딩 시간을 단축시키는 확실한 방법이다.



CSS 최적화하기

CSS는 렌더링 순서가 가장 높으면서 동시에 렌더링을 가장 방해하는 리소스다. 때문에 필요한 정보만 빠르게 다운로드하고 실행해야 브라우저 렌더링을 가속시킬 수 있다. 

1 CSS를 적절히 분리하여 필요한 페이지에 필요한 파일만 포함해야 한다.

2 첫 화면에 사용될 CSS 파일과 숨겨진 화면에 사용될 CSS 파일을 분리해 후자의 CSS는 지연 수행시켜야 한다.

```html
<link rel="stylesheet" type="text/css" media="screen and (max-device-width: 480px)" href="styles_base.css">
```

혹은 onload 이벤트 발생 이후 적용되도록 처리한다.

```html
<link ... />
<script>
function deferOnload() {
    var style = document.getElementsByTagName("Link");
    for (var i=0; i<style.length; i++) {
        var a = style[i].getAttribute("defer-ref");
        if (a) style[i].href = a;
    }
}
    
if (window.addEventListener) {
    window.addEventListener("load", deferOnload, false);
} else if (window.attachEvent) {
    window.attachEvent("onload", deferOnload);
} else {
    window.onload = deferOnload();
}
</script>
```



**이미지 로딩 최적화하기**

이미지 압축 이외의 다른 방법들

`display:none` 속성의 이미지를 미리 다운로드 하지 않으려면?

1 `css: background-image` 속성을 사용

2 자바스크립트를 이용한 지연 로딩 방식 적용 - 첫 화면에 등장하지 않거나 숨겨진 이미지들을 다운로드 하는데만 사용

3 Progressive JPG 활용. 고품질 이미지를 분할 전송하는 방식



**도메인 분할 기법 이용하기**

여러 도메인을 소유한 경우 웹 콘텐츠를 병렬적으로 동시에 다운로드할 수 있도록 하는 방법.

브라우저는 동일 호스트명의 동시 연결 개수를 제한하고 있는데, 한 도메인당 6~13개의 TCP 연결들을 동시 생성해 여러 리소스를 한 번에 다운로드할 수 있도록 허용한다.

일반적으로 브라우저에서는 6개의 동시 연결을 지원한다. 도메인 분할 방식을 통해 2개의 도메인을 이용하면 이론적으로는 12개의 연결이 가능하다.

```
www.feokorea.com
img.feokorea.com
script.feokorea.com
api.feokorea.com
```

도메인 분할 기법을 이용하면 사이트 전체의 쿠키 사이즈를 축소할 수 있는 장점이 있다. 최근 많은 기업의 웹 사이트는 사용자 개개인에 최적화된 페이지를 제공하는 맞춤형 전략을 사용한다. 사이트를 한 번이라도 방문한 고객을 붙잡기 위해 고객의 개인정보에 맞는 사이트를 구성하고 적절한 상품을 추천하기도 한다. 이에 쿠키를 사용한다.

도메인을 여러개로 분할하는 방법은 기술적으로 크게 어렵지 않다. 다만 도메인을 몇 개로 운용하는 것이 최적인지 결정하는 데는 좀 더 면밀한 계획과 테스트가 필요하다. 하나의 웹 페이지에 포함된 리소스 개수가 얼마나 많은가에 따라 추가할 서브 도메인의 숫자를 결정해야 한다. 너무 많이 추가하면 오히려 브라우저의 성능을 저하시킬 수 있다. 동시 다운로드 숫자가 많아질수록 브라우저는 더 많은 CPU 리소스를 사용하고 한계에 도달하면 오히려 다운로드 속도를 느리게 만든다. 또한 브라우저는 각 도메인에 대한 DNS 조회를 수행하고 TCP 연결을 생성하며 생성된 도메인에 대한 연결을 유지해야 하므로 이는 결국 페이지 로딩 속도를 떨어뜨린다.

결론적으로 최신 컴퓨터의 CPU 파워 및 네트워크 속도를 감안할 때 리소스 숫자에 따라 도메인 수를 결정하는 것이 바람직하다. 사용할 도메인의 개수가 정해지면 그 수에 맞도록 리소스들을 균등 분배한다. 특정 도메인에서 대부분의 리소스를 다운로드한다면 다른 도메인들은 오히려 TCP연결을 위한 리소스만 낭비하게 되므로 차라리 없애는 것을 추천한다.

리소스 성격에 따라 분류하는 방법과 동적으로 분류하는 방법이 있다.

성격에 따른 분류는 JS, CSS, 폰트 등 종류별로 구분하고 그 수를 파악해 그룹화한다.

하지만 보다 정확한 분배를 위해서는 배포 시점에 동적으로 도메인명을 결정하도록 하는 것을 권한다. 특정 리소스에 항상 같은 도메인이 배정되도록 해야만 캐시 적중률이 높아진다. 특정 리소스에 동일한 도메인을 배정하는 방안 중 하나로 해시 방식을 사용할 수 있다. 파일명을 숫자 배열로 변경하고 숫자에 따라 도메인을 결정한다. 배정될 도메인이 두 개일 때 '해시값의 끝자리가 홀수이면 1번, 짝수이면 2번' 같은 방식으로 분류할 수 있다.



**도메인 분할 기법과 HTTP/2**

Head Of Line Blocking. HTTP/2에서 멀티플렉싱 기술로 해결되어 도메인 분할 기법을 사용할 이유도 자연스럽게 사라졌다.

최근에는 HTTP/2의 기능을 저해하지 않으면서 다중 도메인을 사용할 수 있는 방안을 제공한다. TCP 연결을 병합하는 방식이다. 

연결 병합은 브라우저가 첫 번째 도메인과 맺은 TCP 연결을 나머지 도메인에 재사용한다. 고려해야할 사항은 1 브라우저가 DNS를 확인할 때 각 도메인은 모두 동일한 IP 주소를 반환해야 한다. 2 동일한 인증서를 사용한다. 와일드카드 인증서나 SAN 인증서를 사용하면 된다.



**사용자 경험 개선하기**

**사용자 요청에 빠르게 반응하기**

CSS, JS 크기 줄이기 : 공백과 주석 제거 (?!????????!!!!!!)

근본적으로 렌더링할 페이지에 필요한 부분만 남기고 필요하지 않은 부분은 제거하는 방법이 확실하다. 현재 페이지에서 실제 사용되고 있는 코드만 분리하는 것을 권장한다. 리소스 크기를 크게 줄일 수 있을 것이다.

화면 안쪽(above the fold)의 중요 리소스와 화면 바깥쪽(below the fold) 콘텐츠를 분류하여 중요 리소스들은 빠르게 로딩시킨다. preload를 사용하는 방법과 HTTP/2 서버 푸시를 활용하는 방법이 있다. 서버 푸시가 더 빠르다.

JS의 async나 defer 속성을 사용하거나 onload 이벤트 이후에 수행하도록 지연시킨다.



**사용자 시선 붙잡기**

일반적으로 브라우저의 프리로더 스레드가 메인 스레드와는 별도로 페이지 내의 리소스들을 미리 다운로드할 수 있다. 그러나 지연 로딩이 적용된 이미지들은 이 프리로더 대상에 포함되지 않는다. 따라서 이미지 지연 로딩은 Hero 이미지들을 제외한 나머지 이미지들에 적용해야 한다.

빠르게 나와야 하는 이미지는

1 HTML의 img, picture 태그를 사용하여 직접 다운로드 지연로딩X

2 CSS background-image 속성에 사용X

3 CSS 배경 이미지로 사용한다면 preload를 사용 일찍 다운로드

폰트도 preload를 사용하여 일찌감치 다운로드. 하지만 먼저 폰트 파일을 경량화해야 한다. 이미 무료로 제공되는 폰트를 찾거나 직접 툴로 경량화한다.

파이썬 기반의 fonttools 라이브러리가 잘 알려진 폰트 서브세팅 툴이다.



**사용자 상호 작용 방해하지 않기**

타사(3rd party) 리소스는 우리가 따로 최적화하기 어렵다. 실제로 많은 웹 사이트에서 무분별하게 많은 타사 리소스들을 삽입하영 성능 저하를 경험한다.

[RequestMap](https://requestmap.webperf.tools) 이나 [Ghostery](https://www.ghostery.com) 같은 툴로 현재 웹 사이트에서 사용하고 있는 타사 리소스들의 현황을 파악할 수 있다.

이 리소스들을 호출하는 스크립트들이 비동기적으로 다운로드되어야 한다.