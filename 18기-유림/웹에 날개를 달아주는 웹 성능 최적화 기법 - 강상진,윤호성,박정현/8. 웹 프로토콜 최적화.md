> p277-295

### 8. 웹 프로토콜 최적화



**HTTP의 발전**

HTTP/1.0부터는 HTTP 페이로드 외에도 헤더를 통해 클라이언트와 서버의 정보를 전달할 수 있었다. Content-Type 헤더를 이용해 이미지나 동영상 등 다양한 정보를 주고받았다. POST 메소드로 웹 서버로 클라이언트 정보를 전달했다. Content-Encoding 헤더를 통해 클라이언트 서버 간 압축 정보를 공유하며 HTML 등의 스크립트를 압축해 크기를 줄여 전송하고 클라이언트는 이를 압축 해제해 브라우징 했다.



**HTTP/1.1**

HTTP의 첫 번째 공식 표준 버전이다. PUT, DELETE를 이용해 파일을 업로드, 삭제했다. Via 헤더를 사용해 중계 서버 정보를 공유하고 Accept 헤더로 클라이언트가 어떤 형식의 콘텐츠를 지원하는지 미리 서버에 알려줬다. 하나의 TCP 연결을 재사용해 많은 콘텐츠를 전달할 수 있는 지속적 연결 기술이 추가됐다.

또 파이프라이닝 기술이 생겼다. 브라우저가 웹 서버에 여러 콘텐츠를 요청했을 때, 이전 응답을 완전하게 받지 못해도 지속적 연결로 확보한 하나의 TCP 연결 내에서 미리 다음 요청에 대한 처리를 시작하면서 전체적인 전달 시간을 줄이는 방식이다.

문제점은? 통신에는 순서가 있다. 어떤 요청이 지연되면 나머지 요청도 지연된다. 이것을 HOL(Head Of Ling blocking) 문제라고 한다.



**HTTP/2**

HTTP/2의 전신 기술은 개선된 웹 프로토콜을 만들기 위해 구글이 시작한 SPDY 프로젝트이다. 텍스트 방식의 프로토콜 메시지를 버리고 이진 포맷을 사용하면서 프로토콜 자체를 경량화 시도했다.

멀티플렉싱, 스트림 우선순위 설정, 헤더 압축, 서버 푸시같은 새로운 프로토콜 최적화 기능이 추가되었다. HOT의 문제를 해결할 수 있었지만 TCP의 HOL 문제는 해결하지 못했다.



**HTTP/3**

새로운 인터넷 프로토콜인 QUIC를 사용하는 HTTP 최상위 버전이다. QIC의 가장 큰 특징은 UDP(User Datagram Protocol) 사용이다. UDP 프로토콜 구조는 최적화를 진행하기 더 쉬운 형태이다. 클라이언트와 HTTP/3 서버 사이에 한 번 맺은 QUIC 연결을 최대한 재사용하는 구조이다. 연결을 만드는 과정에서 소모되는 시간이 대폭 줄어들었다. 가장 최근 버전.



**HTTP/2의 최적화 기술**

클라이언트 <-> 서버 간 콘텐츠를 주고받는 시간을 줄이고, 서버 응답이 느린 콘텐츠가 다른 정상적인 콘텐츠의 전달을 방해하지 않도록 하는 것.

기존 문자열 방식의 프로토콜을 이진 프레임으로 바꿨다. HTTP 요청과 응답에 중복 헤더 값은 걸러내고, 전송해야 하는 값을 압축해 헤더 크기를 최소화했다. 서버 푸시를 통해 요청하지 않은 콘텐츠도 미리 빠르게 전송하여 RTT를 최소화했다.

이 SPDY 프로토콜에서 시작된 기술들은 최대 55% 빠른 웹을 만들 수 있었다.



**이진 프레임**

이전에 HTTP의 요청과 응답은 메시지라는 단위로 구성되어 있었다. HTTP의 메시지는 상태 라인, 헤더와 페이로드로 이루어져 요청과 응답에 필요한 정보를 담고 있다. curl을 통해 메시지 구성을 확인할 수 있다.

HTTP/2에는 기존 버전의 메시지 단위 외에도 프레임, 스트림이라는 단위가 추가되었다.

- 프레임: 통신상 제일 작은 정보 단위이며 헤더나 데이터 중하나
- 메시지: 요청 혹은 응답 단위이며 다수의 프레임으로 이루어짐
- 스트림: 클라이언트와 서버 사이 맺어진 연결을 통해 양방향으로 주고받는 단,복수의 메시지

프레임 -> 메시지 -> 스트림이 되는 구조. 스트림에는 고유 번호가 있는데 하나의 요청이 스트림으로 보내지면 그 응답은 요청 스트림과 같은 스트림 번호를 가진다. 이 번호로 어떤 요청에 대한 응답인지 구분한다.

하나의 스트림이 다수의 요청을 포함하고 이에 대한 다수의 응답 정보를 포함하는 구조로 바뀌었다. 스트림의 유연한 구조 덕분에 서버에서 만들어지는 응답 프레임들이 요청 순서에 상관없이 만들어진 순서대로 클라이언트에게 전달된다. 즉 하나의 TCP 연결을 통해 다수의 클라이언트 요청과 서버 응답이 비동기 방식으로 이루어지는 멀티플렉싱이 사용된다. HOL 문제가 자연스레 해결됐다. 또, 크기가 크거나 처리가 오래 걸리는 콘텐츠를 전달할 때의 병목 현상도 피할 수 있게 됐다.



**헤더 압축**

클라이언트와 서버 사이에 가상 테이블을 만들어서 동일하고 중복되는 헤더 값들을 테이블에 저장하고 참고하는 방식을 사용해 중복 전달을 제거했다.

정적 테이블에는 미리 정의된 자주 사용되는 헤더 필드를 저장한다. 동적 테이블에는 통신하며 주고받는 값들을 업데이트한다. 각 테이블에는 인덱스 번호가 있는데, 동일한 값은 이 번호로 대체하여 보낸다.

헤더 압축 알고리즘인 HPACK을 사용해 허프만 알고리즘 방식으로 좀 더 경량의 데이터를 주고받을 수 있게 됐다. 자주 등장하는 값과 그렇지 않은 값마다 코드 값을 다르게 부여하는 알고리즘이다. 



**서버 푸시**

클라이언트의 요청이 없어도 서버가 여러 응답을 알아서 보내는 것을 말한다. 특정 컨텐츠 요청 이후 추가될 요청을 미리 요청하고 응답하는 것을 의미한다.

일반적으로 HTML을 호출한 후 CSS, JS, Img 파일 대상이 고정돼있다면 웹 서버에 서버 푸시 대상으로 미리 설정할 수 있다. 최근의 APM(Application Performance Management) 솔루션들은 서버 푸시 대상을 자동으로 설정해 주는 기능을 포함한다. 웹 페이지의 구조와 호출하는 후속 파일 대상이 변경되어도 이를 탐지하고 적용할 수 있다.



**HTTP/3의 최적화 기술**

HTTP/3은 RFC의 draft 17 이전 버전인 'HyperText Transfer Protocol over QUIC'의 내용을 바탕으로 하여 18 버전부터 공식 용어로 사용 중이다. QUIC는 구글이 개발한 OSI 네 번째 전달 계층 프로토콜이다.



**QUIC**

초창기엔 Quick UDP Internet Connections. UDP로 TCP를 개선하려는 기술. 전달 속도와 향상을 더불어 클라이언트와 서버 연결 수를 최소화하고 대역폭을 예상해 패킷 혼잡을 피하는 것이 특징.

이전에 클라이언트가 한 번이라도 접속했던 서버라면 별도의 정보 교환 없이 바로 데이터를 보내는 기술. Zero RTT.



**HTTP/3의 등장 배경, 특징**

멀티미디어 콘텐츠를 다양한 기기에 빠르게 전달하기 위해 TCP의 한계를 극복하고 최적화하는 것이 기업들의 도전 과제. 이진 형태의 HTTP/2 프로토콜이 선보인 HPACK, 서버 푸시 등은 어느 정도 성공했다.

새로운 기능을 추가하기보다 HTTP/2의 단점을 보완하는 데 중점을 뒀다.

HTTP를 QUIC 위로 위치시켰다. 'HTTP over QUIC, HQ'.

TCL HOL 문제 개선 뿐만아니라 UDP의 빠른 성능, QUIC의 효율성, TLS 1.3의 보안성의 장점을 가진다.



**새로운 프로토콜 적용 시 고려할 점**

대두되는 사안은 보안 취약점과 사례의 부족이다. 기존에도 넷플릭스와 구글 엔지니어가 HTTP/2의 여러 보안 취약점을 발견해 모든 업체가 이에 대한 보안 패치를 적용한 사례가 있었다.

또, 이미 이전 버전 기반 프론트엔드 최적화를 적용한 기업은 최적화 방안을 수정해야 한다. 예를 들어 브라우저의 병렬 다운로드를 통해 리소스를 빠르게 받아오는 도메인 분할 기법을 적용했다면, 멀티플렉싱 기반의 HTTP/2나 HTTP/3을 사용했을 때 오히려 성능이 반감될 수 있다. 브라우저의 프리페치 기능을 적용한 경우에는 이를 서버 푸시 기능으로 변경해야 할지 기술적으로 판단하고 충분한 성능 비교 테스트를 해야 한다.

시장의 레퍼런스가 부족하다. 여전히 HTTP/1.1을 사용하는 서비스들도 상당하다. HTTP/3의 UDP를 얼마나 많은 기업체들이 내부 네트워크에 지원할 지, 이에 맞는 보안 설정을 빠르게 적용할지 여부도 미지수이다.

