> p15-60, 93-95



###### 2.1. DI

- 의존성 주입(Dependency Injection)

하나의 처리를 수행하기 위해 여러 개의 컴포넌트를 통합할 때. 각 컴포넌트의 인스턴스를 생성하고 통합 관리

어떤 컴포넌트는 싱글턴 객체로 만들어야 하고 어떤 컴포넌트는 프로토타입 객체로 만들어야 하는 등의 스코프 관리

각 인스턴스가 필요로 하는 공통 처리 코드를 외부에서 자동으로 끼워넣는 AOP 기능

들을 DI 컨테이너가 대신 해줌

- IoC 디자인 패턴

인스턴스를 제어하는 주도권이 역전된다는 의미. 컴포넌트를 구성하는 인스턴스의 생성과 의존 관계의 연결 처리를 해당 소스코드가 아닌 DI 컨테이너에서 대신해주기 때문에 제어가 역전되었다고 한다.



###### 2.1.2. ApplicationContext와 빈 정의

@Configuration과 @Bean 애너테이션을 사용해서 DI 컨테이너에 컴포넌트를 등록하면 애플리케이션은 DI컨테이너에서 있는 빈을 ApplicationContext 인스턴스를 통해 가져올 수 있다.

DI 컨테이너에 등록하는 컴포넌트를 빈이라고 하고, 이 빈에대한 설정 정보를 '빈 정의'라고 한다. DI 컨테이너에서 빈을 찾아오는 행위를 '룩업'이라고 한다.



###### 2.1.3. 빈 설정

- 자바 기반 설정 방식 / XML 기반 설정 방식

자바 코드 / XML로 빈을 설정. 애플리케이션에서 사용되는 모든 컴포넌트를 빈으로 정의해야한다.

- 애너테이션 기반 설정 방식

빈을 정의하는 애너테이션을 빈의 클래스에 부여한다. 이후 애너테이션이 붙은 클래스를 탐색해서 DI 컨테이너에 자동으로 등록한다(Component Scan). 또한 의존성 주입도 애너테이션이 붙어있으면 자동으로 주입하게 한다(Auto Wiring).

컴포넌트 스캔을 수행할 때는 스캔할 범위를 지정한다.

DI 컨테이너에 등록되는 빈의 이름은 클래스명의 첫 글자를 소문자로 바꾼 이름과 같다.명시적으로 빈의 이름을 지정하고 싶다면 @Component("")에 원하는 이름을 넣어주면 된다.



###### 2.1.4. 의존성 주입

- 설정자 기반 의존성 주입 방식

설정자 메서드의 인수를 통해 의존성을 주입하는 방식이다. 세터 인젝션이라고 부른다.

애너테이션 기반 설정 방식으로 표현하면, 설정자 메서드에 @Autowired 애너테이션을 달아주기만 하면 된다. 자바나 XML 기반 설정 방식 등의 별도의 설정 파일을 둘 필요가 없다.

- 생성자 기반 의존성 주입 방식

생성자의 인수를 사용해 의존성을 주입하는 방식이다. 컨스트럭터 인젝션이라고 부른다.

애너테이션 기반 설정 방식에서는 생성자에 @Autowired를 부여한다.

필드를 final로 선언해서 생성 후에 변경되지 않게 만들 수 있다.

- 필드 기반 의존성 주입 방식

생성자나 설정자 메서드를 쓰지 않고 DI 컨테이너의 힘을 빌려 의존성을 주입하는 방식이다. 필드 인젝션이라고 부른다.

의존성을 주입하고 싶은 필드에 @Autowired 애너테이션을 달아주면 된다.

DI 컨테이너 없이 사용되는 독립형 라이브러리로 사용될 소스코드에서 필드 인젝션을 사용하고 있다면 잘못된 것이라고 판단해야 한다.



###### 2.1.5. 오토와이어링

빈을 정의하지 않고도 DI 컨테이너에 빈을 자동으로 주입하는 방식이다.

- 타입으로 오토와이어링하기 (autowiring by type)

세터 인젝션, 컨스트럭터 인젝션, 필드 인젝션의 세 가지 의존성 주입 방법에서 모두 활용할 수 있다. 기본적으로 의존성 주입이 반드시 성공한다고 가정한다. 

그래서 주입할 타입에 해당하는 빈을 DI 컨테이너 안에서 찾지 못한다면 NoSuchBeanDefinitionException이라는 예외가 발생한다. 이러한 필수 조건을 완화하고 싶다면 required 속성에 false를 설정하면 된다. 의존성 주입이 실패하고 해당 필드의 값은 null이 된다.

한편 같은 타입의 빈이 여러 개 발견된다면, NoUniqueBeanDefinitionException이 발생한다. @Qualifier 애너테이션으로 빈 이름을 지정하면 원하는 빈만 선택할 수 있다. 또는 @Primary로 우선적으로 선택될 빈을 지정할 수 있다.

- 이름으로 오토와이어링하기 (autowiring by name)

@Qualifier를 @Resource로 대체한다. 이 때 @Resource의 name 속성을 생략할 수 있다. 빈의 이름이 필드명이나 프로퍼티명과 일치할 경우에 빈 이름으로 필드 인젝션을 하는 방법이다. 세터 인젝션을 하는 경우에는 프로퍼티 이름과 같은 이름의 빈이 선택된다.

위의 어느 경우에도 해당되지 않으면 타입으로 오토와이어링을 시도한다. 컨스트럭터 인젝션에서는 @Resource를 사용할 수 없다.

- 컬렉션이나 맵 타입으로 오토와이어링하기

단 하나의 빈만 가져오는 방법 외에도 같은 인터페이스를 구현한 빈을 컬렉션이나 맵 타입에 담아서 가져오는 방법도 제공한다.



###### 2.1.6. 컴포넌트 스캔

컴포넌트 스캔은 클래스 로더를 스캔하면서 특정 클래스를 찾은 다음, DI 컨테이너에 등록하는 방법을 말한다.

대표적인 스캔대상 애너테이션: `@Controller` `@Service` `@Repository` `@Component`



###### 2.1.7. 빈 스코프

DI 컨테이너는 빈 간의 의존 관계를 관리할 뿐만 아니라 빈의 생존 기간도 관리한다. 빈의 생존 기간을 빈 스코프(bean scope)라고 하는데 개발자가 직접 빈의 스코프를 다루지 않아도 된다는 점은 DI 컨테이너를 사용하는 큰 이유이기도 하다.

빈 스코프를 관리하는 구현 코드는 상당히 중요한 부분이지만, 비즈니스 관점에서는 본질과는 동떨어진 관심 밖의 내용이다. 그래서 이러한 코드가 많으면 많을수록 애플리케이션 전체를 이해하기 어려워지고 기능을 예측할 수 없게 된다.

스프링 프레임워크에는 빈 스코프를 관리하는 기능이 있기 때문에 DI 컨테이너에 맡길 수 있다. 이 빈은 기본적으로 싱글턴으로 만들어진다.  `context.getBean(*.class);`로 가져올 수 있다.

- 스코프 설정

DI 컨테이너에서 빈을 가져오려 할 때 같은 것이 없으면 새로 만들고, 같은 것이 있으면 이미 만들어진 것을 공유한다. DI 컨테이너가 파괴될 때 그 안에 있던 빈도 파괴된다.

만약 기본 스코프 외 다른 스코프로 빈을 사용하고 싶다면 빈을 정의하는 단계에서 스코프를 명시한다.

자바 기반의 설정 방식에서는 @Bean 애너테이션이 붙은 메서드에 @Scope 애너테이션을 추가해서 스코프를 명시한다.

애너테이션 기반 방식에서는 스캔 대상이 되는 클래스에 @Scope 애너테이션을 추가해서 스코프를 명시한다.

- 다른 스코프의 빈 주입

스코프는 빈의 생존 기간을 의미한다. 빈 간의 스코프가 서로 다르다는 말은 곧 각 빈의 수명이 다르다는 말이기도 하다. 예를 들어, singleton 스코프가 prototype 스코프보다 더 오래 산다.

DI 컨테이너에서 빈 간의 의존 관계가 형성되는데, 만약 하나의 빈이 또 다른 빈에 의존하고 있다면 DI 컨테이너에 의해 주입된 빈은 자신의 스코프와 상관없이 주입받는 빈의 스코프를 따르게 된다.

해결 방법 -> 빈을 주입하지 않음 / 룩업 메서드 인젝션 / 스코프트 프락시 / 커스텀 스코프 만들기





###### 2.2.6. 스프링 프로젝트에서 활용되는 AOP 기능

- 트랜잭션 관리

@Transactional 애너테이션을 통해 복잡한 트랜잭션 관리를 스프링에게 맡길 수 있다. 해당 메서드가 정상적으로 종료한 것이 확인되면 트랜잭션을 커밋하고, 예외가 발생하면 감지하여 트랜잭션을 롤백한다.

- 인가

권한 제어가 필요한 메서드에 @PreAuthorize 애너테이션을 지정하면 해당 메서드가 호출되기 전에 특정 인가 조건을 만족하는지 확인할 수 있다.

- 캐싱

@Cacheable 메서드의 매개변수 등을 키로 사용해 메서드의 실행 결과를 캐시로 관리할 수 있다.

- 비동기 처리

@Async를 사용하고 반환값으로 CompletableFuture 타입의 값이나 DeferredResult 타입의 값을 반환하게 만들면 AOP방식의 별도 스레드에서 실행된다.

- 재처리

@Retryable 해당 메서드가 정상적으로 처리되지 않은 경우, 원하는 조건을 만족할 때까지 재처리하게 된다. 신뢰성을 보장하기 어려운 외부 시스템과 연계해야 할 때 상당히 유용하다.

