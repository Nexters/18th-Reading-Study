# 1. 실용주의 철학

## 1. 고양이가 내 소스코드를 삼켰어요

*가장 큰 약점은 약점을 보일 것에 대한 두려움이다. - 보쉬에 1709*

실용주의 철학의 초석 중 하나는 경력 향상, 프로젝트, 일상 업무의 면에서 자신과 자신의 행동에 책임을 지는 것이다. **실용주의 프로그래머는 경력에 대해 책임을 지고, 자신의 무지나 실수를 인정하기를 두려워 하지 않는다.**

만약 벤더가 끝까지 잘 해내지 못할 위험요소가 있다면 여러분이 그에 대한 대책(contingency plan)을 세워야 한다. 소스코드와 디스크가 다 망가져 버렸는데 백업이 없다면, 그것은 여러분의 잘못이다. <고양이가 내 소스코드를 삼켰어요>라고 상관에게 말하는 것은 별 도움이 안 될 것이다.

*Tip 어설픈 변명을 만들지 말고 대안을 제시하라 p32*

나쁜 소식을 전하러 가기 전에 뭔가 시도해 볼 만한 다른 것은 없을까? 때로는 사람들이 뭐라고 말할 지 빤히 보이는 경우가 있는데, 그럴 땐 그들의 수고를 덜어 주어라. **변명 대신 대안을 제시하라. 안된 다고 하지 말고 상황을 개선하기 위해 무엇을 할 수 있는지 설명하라.**

## 2. 소프트웨어 엔트로피

엔트로피는 시스템 내의 '무질서'한 정도를 가리키는 물리학 용어이다. 안됐지만, 열역학 법칙에 따르면 우주의 엔트로피는 점점 증가한다. 소프트웨어의 무질서도가 증가할 때 프로그래머는 이를 '소프트웨어의 부패'라고 일컫는다.

*Tip 깨진 창문을 내버려두지 말라. p35*

'깨진 창문'(나쁜 설계, 잘못된 결정, 혹은 형편없는 코드)을 고치지 않은 채로 내버려 두지 마라. 발견하자마자 바로 고쳐라. 적절히 고칠 시간이 충분치 않다면 판자로 덮는 것만이라도 하라. 불쾌한 코드를 주석처리하거나, 아직 구현되지 않음(Not Implemented)이라는 메시지를 표시하거나, 가짜 데이터로 대치해 놓거나 하라. 더 이상의 손상을 예방하기 위해 어떤 조치든 취하고 현 상황을 잘 관리하고 있다는 것을 보여줘라.

## 3. 돌멩이 수프와 삶은 개구리

무엇을 해야 하는지, 어떻게 해야 하는지 정확히 아는 상황이 있다. 전체 시스템이 눈 앞에 그냥 드러난다. 여러분은 그 시스템이 옳다는 걸 안다. 하지만 일을 착수하려고 허락을 구하는 때 부터, 뭔가가 지연되거나 사람들이 멍한 눈으로 여러분을 바라본다. 위원회가 생길 테고, 예산 승인이 필요하고, 일들이 복잡해지기 시작한다. 모든 사람이 각자 자신의 자원을 지키려고 할 것이다. 때때로 이걸 '시작 피로(start-up fatigue)'라고 한다.

돌멩이를 내놔야 할 때다. 큰 무리 없이 요구할 수 있을 만한 것을 찾아내라. 그리고 그걸 잘 개발해라. 일단 되면, 사람들에게 보여주고, 그들이 경탄하게 하라.

*허락을 얻는 것보다 용서를 구하는 것이 더 쉽다 - 그레이스 호퍼*

## 4. 적당히 괜찮은 소프트웨어

*우리는 종종 뭔가 나아지게 하려다가 괜찮은 것마저 망친다. - 리어왕*

'적당히 괜찮은' 이라는 문구는 너절하거나 형편없는 코드를 의미하지 않는다. 시스템이 성공하려면 사용자의 요구사항을 충족해야 한다. 단지 우리는 여러분이 생산해 낸 것이 어느 정도면 적당히 괜찮은지를 결정하는 과정에 사용자가 참가할 기회를 가져가야 한다는 걸 말하고 있는 것이다.

단순히 프로그램에 새 기능을 추가하거나 코드를 한 번 더 다듬는다던가 하기 위해서 사용자의 요구사항을 무시하는 것은 전문가답지 못한 것이다. 우리는 허둥대라고 주창하는 것이 아니다. 불가능한 시간 약속을 하거나 데드라인에 맞추기 위해 기본적인 걸 빼버리거나 하는 것 역시 똑같이 전문가답지 못하다. 여러분이 만드는 시스템의 범위와 품질은 해당 시스템 요구사항의 일부로 명기되어야 한다.

*Tip 품질을 요구사항으로 만들어라.*

오늘의 훌륭한 소프트웨어는 많은 경우, 내일의 완벽한 소프트웨어보다 낫다. 사용자들에게 뭔가 직접 만져볼 수 있는 것을 일찍 준다면, 피드백을 통해 종국에는 더 나은 솔루션에 도달할 수 있을 것이다.

## 5. 지식 포트폴리오

*지식에 대한 투자가 언제나 최고의 이윤을 낸다. - 벤자민 프랭클린*

여러분의 지식과 경험이야말로 가장 중요한 전문가적인 자산이다. 불행히도 그것들은 소진하는 자산(expiring assets)이다. 새로운 기술, 언어, 환경이 개발됨에 따라 지식은 옛 것이 된다. 여러분의 지식 가치가 점점 떨어짐에 따라, 회사나 클라이언트에 대한 여러분 자신의 가치 역시 떨어진다. 우리는 이런 일이 일어나는 걸 예방하고 싶다.

우리는 컴퓨터, 어플리케이션 도메인 등에 대해 프로그래머들이 알고 있는 모든 사실과 경험을 그들의 '지식 포트폴리오'로 생각해 보길 좋아한다. 지식 포트폴리오를 관리하는 것은 금융 포트폴리오를 관리하는 것과 매우 유사하다.

1. 진지한 투자자들은 주기적으로 투자하는 습관이 있다.
2. 장기간 성공의 열과는 다각화다.
3. 똑똑한 투자자들은 자신의 포트폴리오를 보수적인 투자, 위험성이 큰 투자, 보상이 높은 투자 사이에서 균형을 잘 맞춘다.
4. 최대 수익을 위해 투자자들은 싸게 사서 비싸게 팔려고 한다.
5. 포트폴리오는 주기적으로 재검토하고 재조정되어야한다.

여러분이 엄청난 다독가이고, 해당 분야의 최신 발전에 대해 낱낱이 알고 있는데, 누군가 질문을 한다. 여러분은 답이 뭔지 전혀 알지 못하고, 허물없이 그걸 인정한다. 거기에서 멈추지 마라. 답을 찾기 위한 개인적인 도전으로 생각하라. 구루(guru)에게 물어보라. 웹을 검색해 보라. 도서관을 가보라.

스스로 답을 찾지 못하거든, 누가 답을 찾아줄 수 있을지 그 사람을 찾아라. 중단하지 마라. 다른 사람들과 이야기함으로써 개인 네트워크를 구축하는데 도움이 되기도 하고, 답을 찾는 도중에 별로 관련이 없어 보이는 문제들에 대한 해답을 찾아서 놀라는 일도 생길 것이다. 마지막으로 답해주는 사람들 모두에게 고맙다는 말을 꼭 전하라. 그리고 사람들의 질문 중에 여러분이 답할 수 있는 게 있다면 참여해서 자신의 몫을 하라.

## 6. 소통하라!

최고의 아이디어, 최상의 코드 혹은 가장 실용주의적인 사고 등이 있다고 해도 다른 사람들과 소통할 수 없다면 그것들은 궁극적으로 아무 효용이 없다.

- 말하고 싶은게 무엇인지 알아라.
- 청중을 알아라.
- 때를 골라라.
- 스타일을 골라라.
- 멋져 보이게 하라.
- 청중을 참여시켜라.
- 청자가 되어라.
- 응답하라.

# 2. 실용주의 접근법

## 7. 중복의 해악

프로그래머로서 우리는 지식을 수집하고, 조직하고, 유지하며, 통제한다. 우리는 명세서(specification)에 지식을 문서화하고 실행 코드에서 그 지식이 생명을 갖고 살아나도록 한다. 그리고 그 지식에서 테스트 중에 점검할 사항들을 제공받는다.

**불행히도 지식은 고정적이지 않다. 그것은 변화한다. 종종 급격하게 말이다**.

대부분의 사람들은 유지보수가 버그를 고치고 기능을 개선하는 것을 의미하기 때문에, 어플리케이션이 출시되었을 때 비로소 유지보수가 시작된다고 믿는다. 우리는 이들이 틀렸다고 생각한다. 프로그래머들은 늘 유지보수 모드에 있다. 우리가 이해하고 있는 것들은 날마다 바뀐다. 설계를 하거나 코딩을 하는 중에 새로운 요구사항이 도착한다. 어쩌면 환경이 변할 수도 있다. 이유가 무엇이건 간에, 유지보수는 별개의 활동이 아니며, 전체 개발 과정의 일상적인 부분이다.

유지보수를 하려면, 사물의 표현양식, 즉 어플리케이션에 들어 있는 지식의 캡슐들을 찾아내고, 또 바꿔야 한다. 문제는 명세와 프로세스 그리고 프로그램을 개발하는 중에 지식을 중복해 넣기 쉽다는 것이다. 그렇게 된다면 어플리케이션이 선적되기 한참 전부터 유지보수의 악몽이 시작될 것이다.

소프트웨어를 신뢰성 높게 개발하고, 개발을 이해하고 유지보수하기 쉽게 만드는 유일한 길은 우리가 DRY 원칙이라고 부르는 것을 따르는 것 뿐이라 생각한다. DRY 원칙이란 이것이다.

모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을만한 표현 양식을 가져야 한다.

*DRY - 반복하지 마라 (Don't Repeat Yourself)*

중복을 피해서 각각의 지식을 한 곳에 두고 DRY 원칙을 따르는 길은 아래에 정리해 보았다.

- 정보의 다양한 표현양식 : 예를 들어 클라이언트-서버 어플리케이션을 작성하는 데 클라이언트 사이드와 서버 사이드에서 서로 다른 언어를 사용하지만, 공통된 구조를 양쪽에서 표현해야 할 때가 있다. 이럴 때 필터나 코드 생성기 등을 사용하여 소프트웨어가 빌드 될 때마다 간단한 코드 생성기를 사용하여 공동의 메타데이터 표현에 여러 개의 언어에 걸쳐있는 구조를 만들어 낼 수 있다.
- 코드 내의 문서화 : 나쁜 코드는 많은 주석을 필요로 한다. DRY 원칙은 낮은 차원의 지식은 그것이 속하는 코드에 놔두고, 주석은 다른 높은 차원의 설명을 위해 아껴두어야 한다고 말한다. 그렇지 않으면 지식을 중복하게 되며 변경할 때마다 매번 코드와 주석 모두를 바꾸어야 한다. 주석은 필연적으로 낡게 될 것이고, 믿을 수 없는 주석은 주석이 전혀 없는 것보다 더 심각한 문제를 만들어 낸다.
- 문서화와 코드 : 문서와 코드는 모두 동일 지식에 대한 표현이다. 우리는 일정 마감이 다가올 수록 문서의 갱신을 뒤로 미루기 쉽다는 것을 잘 안다. 이 부분은 소프트웨어가 항상 모든 통과가 되게 만들고, 테스트가 명세에 정확하게 반영되기 위해 문서 자체에서 테스트를 자동으로 생성되게 만드는 방법을 생각해 볼 수 있다.

때로는 부주의한 중복이 발생하기도 한다. 아래는 선을 대표하는 클래스이다.

```cpp
class Line {
	public:
		Point start;
		Point end;
		double length;
};
```

여기에는 중복이 있다. 길이는 언제나 시작과 끝 점으로 계산되는데 둘 중 하나를 바꾸면 길이도 자동으로 변한다. 또한 비용이 많이 드는 연산을 피하기 위해 데이터를 캐싱해야 하는 경우도 발생한다. 이러한 DRY 원칙을 반영하여 수정한 코드는 다음과 같다.

```cpp
class Line {
	private:
		bool changed;
		double length;
		Point start;
		Point end;
	public:
		void setStart(Point p) { start = p; changed = true; }
		void setEnd(Point p) { end = p; changed = true; }
		Point getStart(void) { return start; }
		Point getEnd(void) { return end; }
		double getLength() {
			if (changed) {
				length = start.distanceTo(end);
				changed = false;
			}
			return length;
		}
};
```

개발자들간의 소통도 중복을 피하기 위해 매우 중요하다. 재사용할 수 있는 코드를 많이 만들도록 하자.
