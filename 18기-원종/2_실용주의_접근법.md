# 2. 실용주의 접근법

## 7. 중복의 해악

프로그래머로서 우리는 지식을 수집하고, 조직하고, 유지하며, 통제한다. 우리는 명세서(specification)에 지식을 문서화하고 실행 코드에서 그 지식이 생명을 갖고 살아나도록 한다. 그리고 그 지식에서 테스트 중에 점검할 사항들을 제공받는다.

**불행히도 지식은 고정적이지 않다. 그것은 변화한다. 종종 급격하게 말이다**.

대부분의 사람들은 유지보수가 버그를 고치고 기능을 개선하는 것을 의미하기 때문에, 어플리케이션이 출시되었을 때 비로소 유지보수가 시작된다고 믿는다. 우리는 이들이 틀렸다고 생각한다. 프로그래머들은 늘 유지보수 모드에 있다. 우리가 이해하고 있는 것들은 날마다 바뀐다. 설계를 하거나 코딩을 하는 중에 새로운 요구사항이 도착한다. 어쩌면 환경이 변할 수도 있다. 이유가 무엇이건 간에, 유지보수는 별개의 활동이 아니며, 전체 개발 과정의 일상적인 부분이다.

유지보수를 하려면, 사물의 표현양식, 즉 어플리케이션에 들어 있는 지식의 캡슐들을 찾아내고, 또 바꿔야 한다. 문제는 명세와 프로세스 그리고 프로그램을 개발하는 중에 지식을 중복해 넣기 쉽다는 것이다. 그렇게 된다면 어플리케이션이 선적되기 한참 전부터 유지보수의 악몽이 시작될 것이다.

소프트웨어를 신뢰성 높게 개발하고, 개발을 이해하고 유지보수하기 쉽게 만드는 유일한 길은 우리가 DRY 원칙이라고 부르는 것을 따르는 것 뿐이라 생각한다. DRY 원칙이란 이것이다.

모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을만한 표현 양식을 가져야 한다.

*DRY - 반복하지 마라 (Don't Repeat Yourself)*

중복을 피해서 각각의 지식을 한 곳에 두고 DRY 원칙을 따르는 길은 아래에 정리해 보았다.

- 정보의 다양한 표현양식 : 예를 들어 클라이언트-서버 어플리케이션을 작성하는 데 클라이언트 사이드와 서버 사이드에서 서로 다른 언어를 사용하지만, 공통된 구조를 양쪽에서 표현해야 할 때가 있다. 이럴 때 필터나 코드 생성기 등을 사용하여 소프트웨어가 빌드 될 때마다 간단한 코드 생성기를 사용하여 공동의 메타데이터 표현에 여러 개의 언어에 걸쳐있는 구조를 만들어 낼 수 있다.
- 코드 내의 문서화 : 나쁜 코드는 많은 주석을 필요로 한다. DRY 원칙은 낮은 차원의 지식은 그것이 속하는 코드에 놔두고, 주석은 다른 높은 차원의 설명을 위해 아껴두어야 한다고 말한다. 그렇지 않으면 지식을 중복하게 되며 변경할 때마다 매번 코드와 주석 모두를 바꾸어야 한다. 주석은 필연적으로 낡게 될 것이고, 믿을 수 없는 주석은 주석이 전혀 없는 것보다 더 심각한 문제를 만들어 낸다.
- 문서화와 코드 : 문서와 코드는 모두 동일 지식에 대한 표현이다. 우리는 일정 마감이 다가올 수록 문서의 갱신을 뒤로 미루기 쉽다는 것을 잘 안다. 이 부분은 소프트웨어가 항상 모든 통과가 되게 만들고, 테스트가 명세에 정확하게 반영되기 위해 문서 자체에서 테스트를 자동으로 생성되게 만드는 방법을 생각해 볼 수 있다.

때로는 부주의한 중복이 발생하기도 한다. 아래는 선을 대표하는 클래스이다.

```cpp
class Line {
	public:
		Point start;
		Point end;
		double length;
};
```

여기에는 중복이 있다. 길이는 언제나 시작과 끝 점으로 계산되는데 둘 중 하나를 바꾸면 길이도 자동으로 변한다. 또한 비용이 많이 드는 연산을 피하기 위해 데이터를 캐싱해야 하는 경우도 발생한다. 이러한 DRY 원칙을 반영하여 수정한 코드는 다음과 같다.

```cpp
class Line {
	private:
		bool changed;
		double length;
		Point start;
		Point end;
	public:
		void setStart(Point p) { start = p; changed = true; }
		void setEnd(Point p) { end = p; changed = true; }
		Point getStart(void) { return start; }
		Point getEnd(void) { return end; }
		double getLength() {
			if (changed) {
				length = start.distanceTo(end);
				changed = false;
			}
			return length;
		}
};
```

개발자들간의 소통도 중복을 피하기 위해 매우 중요하다. 재사용할 수 있는 코드를 많이 만들도록 하자.

## 8. 직교성

설계, 빌드, 테스트, 그리고 확장하기에 쉬운 시스템을 만드는 데에 있어 직교성(Orthogonality)은 매우 중요한 개념이다. 직교성은 기하학에서 빌려온 용어이다. 그래프의 축과 같이 두 직선이 직각으로 만나는 경우 직교한다고 말한다. 컴퓨팅에서 이 용어는 일종의 독립성이나, 결합도 줄이기를 의미한다. 하나가 바뀌어도 나머지에 어떤 영향도 주지 않으면 서로 직교한다고 할 수 있다.

잘 설계된 시스템에서는 데이터베이스 코드가 사용자 인터페이스에 대해 직교할 것이다. 데이터베이스에 영향을 주지 않으면서 인터페이스를 바꿀 수 있고, 또한 인터페이스를 바꾸지 않으면서 데이터베이스를 교환할 수 있다.

*Tip. 관련 없는 것들 간에 서로 영향이 없도록 하라.*

우리는 자족적(self-contained)인 컴포넌트를 설계하기 원한다. 독립적이며, 단일하고, 잘 정리된 목적을 가진 컴포넌트. 컴포넌트들이 각기 격리되어 있으면 어느 하나를 바꿀 때 나머지 것들을 걱정하지 않아도 된다. 해당 컴포넌트의 외부 인터페이스를 바꾸지 않는 한, 전체 시스템으로 퍼져나가는 문제를 일으키지는 않으리라고 안심할 수 있다.

직교적인 시스템을 작성하면 두 가지의 큰 장점이 있다. 생산성 향상과 리스크 감소.

- 생산성 향상
    - 변화가 국소화(localize)되서 개발 시간과 테스트 시간이 줄어든다. 상대적으로 작고, 자족적인 컴포넌트를 작성하는 것이 하나의 커다란 코드 덩어리를 만드는 것보다 더 쉽다.
    - 직교적인 접근법은 또한 재사용을 촉진한다. 컴포넌트들에 명확하고 잘 정의된 책임이 할당되어 있다면 애초에 구현자들이 미처 생각하지 못했던 방식으로 새로운 컴포넌트와 결합할 수 있다. 시스템이 더 느슨하게 결합(coupling)되어 있을수록 재설정(reconfigure)하고 리엔지니어링하기 쉽다.
- 리스크 감소
    - 감염된 코드는 격리된다. 어떤 모듈이 병에 걸렸다 해도 시스템의 나머지 부분으로 증상이 전파될 확률이 낮다.
    - 시스템이 잘 깨어지지 않는다. 어떤 부분을 골라서 약간 바꾸고 수리해도 거기서 생기는 문제점들은 그 부분에만 한정될 것이다.

팀 내 업무가 겹치는 영역이 많다면 구성원들은 책임 영역에 대해 혼동하게 된다. 뭘 하나 바꾸려고 해도 그들 중 누구라도 영향을 받을 수 있기 때문에 전체 팀원이 모여야 한다. 우리는 어플리케이션에서 인프라를 분리하는 방식을 선호한다. 주된 인프라 컴포넌트(데이터베이스, 커뮤니케이션 인터페이스, 미들웨어 데이터 레이어 등등)마다 서브팀을 할당한다. 어플리케이션 기능의 분할 역시 유사하게 나뉜다. 그러고 나서 현재의 가용 인원을 확인하고 조직을 적절하게 개편한다.

개발자 대다수는 직교적인 시스템을 설계할 필요를 잘 안다. 그런 설계 과정을 설명할 때 모듈라(modular), 컴포넌트 기반, 레이어 같은 다른 용어를 사용하기도 한다. 시스템은 협력하는 모듈들의 집합으로 구성되어야 하고, 각 모듈은 다른 부분과 독립적인 기능을 구현해야 한다. 때로는 이런 컴포넌트들이 레이어로 조직되기도 하는데, 각 레이어는 하나의 추상화 층을 이루게 된다. 이 레이어식 접근은 직교적 시스템을 설계하는 강력한 방법이다. 각 레이어는 자기 밑에 있는 레이어들이 제공하는 추상화만을 사용하기 때문에, 코드에 영향을 끼치지 않으면서 아래에 있는 다른 구현들을 바꾸는 높은 유연성을 얻을 수 있다.

현실 세계의 변화와 설계 사이의 결합도를 얼마나 줄였는지에 대해서도 스스로 물어보아야 한다. 전화번호를 고객 식별자로 사용한다고 했을 때, 전화 회사가 지역 번호를 재할당한다면 어떻게 할 것인가? 자신의 힘으로 제어할 수 없는 속성에 의존하지 마라.

써드파티 툴킷이나 라이브러리를 도입할 때, 시스템의 직교성을 보존할 수 있는지 주의 깊게 살펴보자. 기술을 현명하게 선택해야 한다. 만약 툴킷이나 심지어 같은 팀의 다른 멤버가 작성한 라이브러리를 도입할 때에도 이것이 여러분의 코드에 있어서는 안 될 변화를 강요하고 있지는 않은지 검토해보자. 만약 객체 영속 방식(object persistence scheme)이 투명하다면, 이것은 직교적이다. 하지만 특별한 방식으로 객체를 생성하고 접근해야 한다면, 그렇지 않다. 이러한 세부 사항을 코드로부터 분리한다면 미래에 벤더가 바뀌더라도 쉽게 대처할 수 있다는 이점이 있다.

직교성에 대한 흥미로운 변형은 AOP(Aspect Oriented Programming)이다. AOP는 이를 사용하지 않았더라면 소스코드 이곳저곳에 분산되어 있을 코드를 한 곳에 모아준다. 예를 들면, 로그 메시지는 소스코드 이곳저곳에 흩뿌려져 있는 로그 함수 호출을 통해 기록된다. AOP를 사용하면 로깅되고 있는 코드와 직교적으로 로깅을 구현할 수 있다.

코드를 작성하고 있다면 언제나 어플리케이션의 직교성을 떨어트릴 수 있는 위험에 노출되어 있다. 직교성을 유지하기 위해서 사용할 수 있는 몇 가지 기법은 다음과 같다.

- 코드의 결합도를 줄여라 : 불필요한 어떤 것도 다른 모듈에 보여주지 않으며, 다른 모듈의 구현에 의존하지 않는 코드를 작성하라. 디미터 법칙(Law of Demeter)을 따르려고 노력해보자. 객체의 상태를 바꿀 필요가 있다면, 객체 스스로가 여러분을 위해 그러한 일을 수행하게 만들라.
- 전역 데이터를 피하라 : 코드가 전역 데이터를 참조할 때 마다, 코드는 해당 데이터를 공유하는 다른 컴포넌트와 묶이게 된다. 읽기 전용 목적으로 전역 데이터를 사용한다 하더라도 문제가 발생할 수 있다. 예를 들어 코드를 갑자기 멀티쓰레드로 바꿔야 한다면 어떻게 될까? 싱글턴 패턴은 특정 클래스의 객체가 단 하나의 인스턴스만을 갖도록 보장해준다. 하지만 많은 개발자들이 싱글튼 객체를 전역 데이터의 일종으로 남용한다.
- 유사한 함수를 피하라 : 스트래티지 패턴(strategy pattern)을 사용하여 더 나은 구현을 할 수는 없는지 고려해보자.

## 9. 가역성

*당신이 가진 생각이 딱 하나밖에 없다면, 그것만큼 위험한 것은 없다. - 에밀 사르티에, 종교론, 1938*

무언가를 구현하는 방법에는 여러 가지 길이 있고, 보통 하나의 솔루션에는 여러 벤더의 제품이 존재한다. 이것은 이 방법만으로 해결할 수 있어와 같은 근시안적인 생각을 갖고 프로젝트에 참여한다면 아마도 예상치 못했던 경우에 의해 한숨지을 일이 많을 것이다. 많은 프로젝트 팀들이 프로젝트를 진행하면서 어쩔 수 없이 고통스럽게 그들의 근시안을 조금씩 수정하게 된다.

일단 어떤 벤더의 데이터베이스나 아키텍처 패턴, 혹은 특정 배포 모델(예를 들면 클라이언트 서버, 독립형)을 사용하기로 결정했고, 이를 통해 프로젝트를 진행해 왔다면 큰 비용을 치루지 않고는 이러한 결정을 되돌릴 수 없다.

프로젝트 초기에 특정 벤더의 관계형 데이터베이스를 사용하기로 결정했다 가정해보자. 한참 후 성능 테스트를 하면서 다른 객체형 데이터베이스가 더 빠르다는 것을 알게 되었다. 이 때 만약 데이터베이스에 대한 아이디어를 올바르게 추상화하여 어떤 하나의 지점이 영속 서비스를 제공하도록 만들었다면 도중에 말을 갈아 탈 수 있는 유연성을 갖게 될 것이다.

보통 특정 벤더 제품에 대한 의존도 등은 잘 정의하고 추상화한 인터페이스를 통해 감출 수 있다. 사실 우리가 수행해 온 모든 프로젝트를 이런 식으로 수행할 수 있다. 만약 벤더 의존적인 코드를 깨끗하게 분리하지 않으면 어떻게 될까? 벤더 의존적인 수행문들이 코드 전반에 흩어져 있을 것이고, 이는 유지보수성, 유연성을 극도로 떨어뜨리게 된다. 요구사항을 메타데이터에 넣고, 필요한 수행문을 코드에 넣을 때 메커니즘을 자동화시켜라. 그리고 어떤 매커니즘을 이용하든 이를 되돌릴 수 있도록 하라. 무언가 자동으로 추가할 수 있다면, 역시 자동으로 빼낼 수도 있어야 한다.

양자 역학 분야의 유명한 메타포인 슈뢰딩거의 고양이 이야기를 소개하려 한다. 어떤 고양이가 밀폐된 상자에 갇혀 있다. 상자 안에는 1시간에 1/2의 확률로 알파 입자를 분해하는 알파 입자 가속기와 청산가리 통이 있다. 알파 입자가 분해되어 방출되면 청산가리 통의 센서에 감지되는데 이 경우 청산가리 통이 깨져 고양이는 죽게 된다. 1시간 후에 고양이는 살았을까? 죽었을까? 슈뢰딩거에 따르면 둘 다 옳은 답이다.

알파입자의 분해 주기마다 두 가지 가능한 결과가 있고, 이 때 마다 우주는 복사된다. 한 곳에서 분해가 일어나고, 한 곳에서는 그렇지 않다. 그러므로 고양이는 한 우주에서는 살아있고, 다른 우주에서는 죽는다. 상자를 열어보았을 때야 비로소 여러분이 어떤 우주에 속해있는지를 알 수 있게 된다.

하지만 모든 코드의 진화를 슈뢰딩거의 고양이로 가득한 상자로 생각하라. 각각의 결정은 다른 버전의 미래를 야기한다. 여러분의 코드는 몇 가지 가능한 미래를 지원할 수 있는가? 어떤 미래가 일어날 가능성이 높은가? 그 미래가 닥쳤을 때, 이를 지원하는 것이 얼마나 어려울까?

상자를 열 용기가 있는가?

## 10. 예광탄

어둠 속에서 기관총을 쏘는 방법은 두 가지가 있는데, 하나는 목표물이 어디 있는지 확인 후 모든 변수를 계산하여 쏘는 것이고 다른 하나는 예광탄을 쏘는 것이다. 예광탄은 탄창의 일반 탄환들 사이에 일정한 간격으로 끼어있다. 예광탄이 발사되면 그 안에 든 인 성분이 발화하여 (그것이 무엇이 되었든지 간에) 총알을 맞은 것과 총 사이에 빛의 궤적을 남긴다. 만약 예광탄이 목표물을 맞힌다면 일반 탄환도 마찬가지로 맞힐 것이다.

사람들이 힘든 계산보다 예광탄을 더 좋아한다는 사실은 놀랄 일이 아니다. 예광탄은 반응도 즉각적이고, 실제 탄환과 동일한 환경 조건에서 날아가기 때문에 외부의 영향도 최소화한다. 새로운 프로젝트에서도 이 사실은 마찬가지다. 전에 만들어진 적이 없는 전혀 새로운 것을 만들고 있다면 더욱 그렇다. 기관총 사수와 마찬가지로 어둠 속에서 목표물을 맞추어야 한다. 사용자들이 이전에 그런 시스템을 한 번도 본 적이 없기 때문에 요구사항이 막연할지도 모른다. 익숙하지 않은 알고리즘, 기술, 언어, 라이브러리들을 사용해야 할 지도 모르므로, 여러분은 수 많은 미지의 것과 맞닥뜨리게 된다. 그리고 프로젝트는 완성하는 데 시간이 걸리기 때문에, 일을 마치기 전에 여러분의 작업을 둘러싼 환경이 변화하리라는 것도 거의 확실히 장담할 수 있다.

예광탄이 효과가 있는 까닭은 일반 탄환과 동일한 환경과 제약 조건에서 발사되고 날아가기 때문이다. 탄환이 목표물에 도달하는 시간이 짧기 때문에, 기관총 사수는 즉각적인 반응을 얻을 수 있다. 그리고 실용적인 관점에서 봐도 예광탄은 상대적으로 비용이 적게 드는 방법이다. 코딩에서도 동일한 효과를 얻으려면, 우리를 요구사항으로부터 최종 시스템의 일부 측면에까지 빨리, 눈에 보이게, 반복적으로 도달하게 해줄 무언가를 찾아야 한다.

예광탄 코드 접근 방법에는 여러 장점이 있다.

- 사용자들은 뭔가 작동되는 것을 일찍부터 보게 된다.
- 개발자들은 들어가서 일할 수 있는 구조를 얻는다.
- 통합 작업을 수행할 기반이 생긴다.
- 보여줄 것이 생긴다.
- 진전 상황에 대해 더 정확하게 감을 잡을 수 있다.

예광탄은 지금 맞추고 있는 것이 무엇인지 보여준다. 그러나 그것이 꼭 목표물이라는 보장은 없다. **그럴 경우 목표물이 맞을 때 까지 조준을 옮겨야 한다. 이것이 핵심이다.**

예광탄 코드도 마찬가지다. 예광탄 코드 기법은 일이 어떻게 될지 100% 확신할 수 없는 상황에서 사용된다. 그러므로 처음 몇 번 시도 때 목표에 맞지 않더라도 놀랄 필요가 없다. 지금 있는 것을 목표물에 가져가려면 어떻게 바꾸어야 할지 생각해내고, 가벼운 개발 방법론을 선택했다는 사실에 감사하라. 코드의 크기가 작으면 관성 역시 약하므로 빠르고 쉽게 바꿀 수 있다.

### 예광탄 코드 vs 프로토타이핑

프로토타이핑을 예광탄과 비슷하다고 생각할 수 있겠지만 둘은 엄연히 다르다. 프로토타입은 최종 시스템의 어떤 특정한 측면을 탐사해 보는 것이 목표다. 즉 이걸 바탕으로 다시 새롭게 만들 각오를 하고 짜는 코드인 것이다. 진짜 프로토타이핑 방식을 따른다면, 어떤 개념을 구현해 보려고 시도할 때 대충 끼워 맞춘 것들을 모두 버린 다음, 실험 과정에서 얻은 교훈을 바탕으로 다시 코드를 만들게 된다.

예광탄 코드 접근 방법은 다른 종류의 문제에 대한 대응 방법이다. 어플리케이션이 전체적으로 어떻게 연결되는지를 알고 싶고, 사용자들에게 실제로 어플리케이션의 요소들이 어떻게 상호작용하는지 보이고 싶고, 개발자들에게는 코드를 붙일 아키텍처적 골격을 제시하고 싶다면, 이 경우 대강 구현한 컨테이너 채우는 알고리즘과 단순하지만 동작은 하는 사용자 인터페이스로 구성된 예광탄을 만들 것이다.

둘의 차이점을 다시 한 번 강조하면 프로토타입은 나중에 버릴 수 있는 코드를 만든다. 예광탄 코드는 기능은 별로 없지만, 완결된 코드이며, 최종 시스템 골격의 일부를 이룬다. 프로토타입을 예광탄이 하나라도 발사되기 전에 먼저 일어나는 정찰과 정보 수집 정도로 생각하면 좋다.
