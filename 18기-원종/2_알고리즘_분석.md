# 02 알고리즘 분석

## 04 알고리즘 시간 복잡도 분석

### 4.1 도입

두 알고리즘의 속도를 비교하는 가장 직관적인 방법은 각각을 프로그램으로 구현한 뒤 같은 입력에 대해 두 프로그램의 수행 시간을 측정하는 것이다.

하지만 프로그램의 실행 시간은 알고리즘의 속도를 일반적으로 이야기하는 기준이 되기에는 부적합하다. 

가장 큰 이유는 프로그램의 수행 시간은 사용한 프로그래밍 언어, 하드웨어는 물론이고 운영체제, 컴파일러까지 수 많은 요소에 의해 바뀔 수 있기 때문이다.

두 번째 이유는 실제 수행 시간이 다양한 입력에 대한 실행 시간을 반영하지 못하기 때문이다. 

알고리즘의 수행 시간을 지배하는 것은 **반복문**이다. 입력의 크기가 작을 때는 반복외의 다른 부분들이 갖는 비중이 클 수가 있지만, 입력의 크기가 커지면 커질 수록 반복문이 알고리즘의 수행시간을 지배하게 된다.

### 4.2 선형 시간 알고리즘

입력값 N에 대해 수행시간이 정비례 하는 알고리즘. 시간복잡도는 O(N). 선형 시간에 실행되는 알고리즘은 대개 우리가 찾을 수 있는 알고리즘 중 가장 좋은 알고리즘인 경우가 많다.

### 4.3 선형 시간 이하 알고리즘

입력의 크기가 커지는 것보다 수행 시간이 느리게 증가하는 알고리즘. 시간복잡도는 O(logN). 입력으로 주어진 자료에 대해 우리가 미리 알고 있는 지식을 활용하면 가능하다. 대표적으로 **이진 탐색(binary search)**이 있다.

이진 탐색 알고리즘이 하는 일을 정의하면 다음과 같다.

*binsearch* (A[], x) = 오름차순으로 정렬된 배열 A[]와 찾고 싶은 값 x가 주어질 때 A[i-1] < x < A[i]인 i를 반환한다. 이 때 A[-1] = - 무한대, A[N] = 무한대 로 가정한다.

이 함수는 배열 A[]에서 x를 삽입할 수 있는 위치 중 가장 앞에 있는 것을 반환한다고 생각하면 쉽다. 예를 들어 A = [1,2,4,5,6], x = 3 인 경우 *binsearch*(A, x) = 2 가 되는 것이다. (A[1] = 2 < x = 3 < A[2] = 4)
