# 4. 실용주의 편집증
*Tip. 완벽한 소프트웨어는 만들 수 없다.*

실용주의 프로그래머들은 자기 자신을 믿지 않는다. 어느 누구 심지어는 자기 자신도 완벽한 코드를 작성할 수 없음을 알기 때문에 실용주의 프로그래머는 자신의 실수에 대비해 방어적으로 코드를 짠다. 이에 대한 방법들을 챕터 하나씩 다뤄보려고 한다.

## 21. 계약에 의한 설계

*상식과 정직만큼 사람을 놀라게 하는 것은 없다. - 랄프 왈도 에머슨(Ralph Waldo Emerson) <에세이>*

### DBC

계약에 의한 설계(Designed By Contract, DBC)는 버트란드 마이어(Eiffel 언어 창시자)에 의해 개발된 개념이다. DBC는 단순하지만 강력한 기법으로, 프로그램의 정확성을 보장하기 위해 소프트웨어 모듈들의 권리와 책임을 문서화(및 이에 대해 동의) 하는 데에 초점을 맞춘다. **정확한 프로그램이란 무엇인가? 스스로 자신이 하는 일이라고 주장하는 것보다 많거나 적지도 않게 딱 그만큼만 하는 프로그램을 말한다.**

소프트웨어 시스템의 모든 함수와 메서드는 뭔가를 한다. 그 뭔가를 시작하기 전에 해당 루틴은 세상의 상태에 대해 어떤 기대를 갖고 있을 테고, 루틴이 끝난 후에 세상의 상태가 어떠해야 한다는 진술을 할 수 있을 것이다. 마이어는 이런 기대를 설명하면서 다음과 같이 주장한다.

- 선행조건(precondition) : 루틴이 호출되기 위해 참이어야 하는 것. 즉 루틴의 요구사항. 루틴의 선행조건이 위반된 경우에는 루틴이 호출되어서는 안 된다. 제대로 된 데이터를 전달하는 것은 호출하는 쪽의 책임이다.
- 후행조건(postcondition) : 루틴이 자기가 할 것이라고 보장하는 것. 즉 루틴이 완료되었을 때 세상의 상태. 루틴에 후행조건이 있다는 것은 곧 그것이 종국에는 종료될 것이라는 걸 암시한다. 무한 반복은 암시되지 않는다.
- 클래스 불변식(class invariant) : 호출자의 입장에서 볼 때는 이 조건이 언제나 참이라고 클래스가 보장한다. 루틴의 내부 처리 중에는 불변식이 참이 아닐 수도 있지만, 루틴이 종료하고 호출자로 제어권이 반환되는 때에는 불변식이 참이 되어야 한다. (불변식에 관여하는 어떤 데이터 멤버에게도 클래스가 무제한적인 쓰기 접근권을 줄 수 없다는 것을 기억하라.)

루틴과 그 루틴의 잠재적 호출자 간의 계약은 다음과 같다.

> 만약 호출자가 루틴의 모든 선행조건을 충족한다면, 해당 루틴은 종료시 모든 후행조건과 불변식이 참이 될 것을 보증해야 한다.

만약 계약 당사자 중 어느 한 쪽이든 이 계약 내용을 지키지 못하면 배상이 이루어진다. 예를 들면, 예외가 발생하거나 프로그램이 종료하거나 하는 것이다. 무슨 일이 벌어지든지 간에 계약에 부응하지 못하는 게 버그가 되어버리는 실수는 저지르지 마라.

상속과 다형성은 객체지향 언어의 기본인데, 이런 계약이 정말 빛을 발할 수 있는 분야이기도 하다. 한 클래스가 다른 클래스의 `한 종류(is-a-kind-of)`인 경우, 상속을 이용해서 `한 종류` 관계를 만든다고 상정해 보자. 여러분은 아마 리스코프 대체 원칙을 지키길 원할 것이다.

> 서브클래스는 사용자가 차이점을 모르고서도 기반 클래스 인터페이스를 통해 사용할 수 있어야 한다

달리 말하자면, 여러분이 만든 새 서브타입이 정말 베이스타입의 `한 종류` 여야 한다. 즉, 동일한 메서드를 지원하고, 그 메서드들은 동일한 의미를 가져야 한다. 이걸 계약을 통해 확실히 할 수 있다. 계약을 기반 클래스에 오로지 한 번만 명기하면, 자동으로 미래의 모든 서브클래스에 적용되도록 할 수 있다. 서브클래스는 원한다면 조금 더 넓은 범위의 입력을 받아들이거나, 혹은 더 강한 보증을 할 수 있다. 하지만 그 서브클래스는 자신의 부모 이상으로 받아들이고, 최소한 자신의 부모만큼은 보증해야 한다.

## 22. 죽은 프로그램은 거짓말을 하지 않는다

우리 중 대다수는 파일이 성공적으로 닫혔는지, 혹은 trace 문이 우리가 예상한 대로 찍히는지 확인하지 않는 코드를 작성한 경험이 있다. 그리고 다른 모든 조건이 동일하다면, 그럴 필요가 없었을지도 모른다. 문제의 코드는 정상 조건 하에서는 실패하지 않았을 것이다. 모든 에러는 정보를 준다. 우리는 에러가 발생할 리 없다고 스스로를 설득하고선 그걸 무시하기로 할 수 있다. 반면 실용주의 프로그래머는 만약 에러가 있다면 정말로 뭔가 나쁜 일이 생긴 것이라고 자신에게 이야기 한다.

### 망치지 말고 멈추라

가능한 한 빨리 문제를 발견하게 되면, 좀 더 일찍 시스템을 멈출 수 있다는 이득이 있다. 게다가 프로그램을 멈추는 것이 최선일 때가 많다. 자바 언어와 라이브러리는 이 철학을 포용했다. 런타임 시스템에서 뭔가 예상하지 못한 것이 발생하면 RuntimeException을 던진다. 만약 이 예외가 잡히지 않으면 프로그램의 최상위 수준까지 스며 나올 것이고, 결국 스택 트레이스를 출력하며 프로그램을 멈춰버릴 것이다.
