# 5. 구부러지거나 부러지거나

삶은 멈추지 않는다. 현대의 미친 듯이 빠른 변화 속도에 맞추기 위해서는 가능한 느슨하고 유연한 코드를 작성하기 위해 노력해야 한다. 유연성을 유지하는 한 가지 좋은 방법은 가능한 적은 양의 코드를 작성하는 것이다.

## 26. 결합도 줄이기와 디미터 법칙

좋은 울타리는 좋은 이웃을 만든다. - *로버트 프로스트(Robust Frost)* <담장 고치기>

스파이, 반체제자, 혁명가들은 종종 세포(cell)라 불리는 작은 그룹으로 조직을 만든다. 각 세포의 구성원은 같은 세포에 속한 구성원만 알 수 있으며, 다른 세포에 누가 있는지에 대해서는 전혀 모른다. 그렇기 때문에 하나의 세포가 발각된다 하더라도, 다른 세포에 있는 사람들은 안전하다. 세포 간의 상호 작용을 제거함으로써 모두를 보호하는 것이다.

우리는 이것이 코딩에도 적용할 수 있는 좋은 원리라고 믿는다. 코드를 세포(모듈 module)로 구성하고, 이들 간의 상호 작용을 제한하라. 그러면 한 모듈이 변경되거나 교체된다 하더라도 다른 모듈들은 변경 없이 수행될 수 있을 것이다.

### 결합도 줄이기

우리가 집을 지을 때 주 계약자와 계약을 하고, 주 계약자가 각각의 역할을 맡을 하도급자와 다시 계약을 하는 것이 일반적인 것처럼 소프트웨어도 이러한 모델을 따르기를 권한다. 어떤 객체에게 특정 서비스를 요청했을 때 이 요청을 바로 처리해 주기를 바라지, 제 3의 객체를 넘겨 받아 이미 요청한 서비스를 가지고 이러쿵저러쿵 하고 싶지는 않을 것이다.

예를 들어 과학 기술 정보를 그래프로 표현하는 클래스를 작성한다고 생각해보자. 데이터 기록기는 세계 곳곳에 분산되어 있다. 그리고 각 기록기 객체는 객체가 위치한 곳의 위치와 시간대를 알려주는 장소 객체를 가지고 있다. 사용자가 기록기를 선택해서 올바른 시간대가 표시된 데이터 그래프를 보게 하고 싶다면, 다음과 같은 코드를 작성할 수 있을 것이다.

```java
public void plotDate(Date aDate, Selection aSelection) {
  Timezone tz = aSelection.getRecorder().getLocation().getTimeZone();
  // ...
}
```

이렇게 되면 그래프를 그리는 루틴이 불필요하게 Selection, Recorder, Location 이라는 3개의 클래스와 결합하게 된다. 이러한 방식으로 코딩하면 우리의 클래스가 의존하게 되는 클래스의 숫자가 대폭 증가하게 된다. **왜 의존의 증가가 나쁠까? 시스템 어딘가의 무관한 변화가 코드에 미칠 수 있는 위험이 커지기 때문이다.** 예를 들어 누군가가 Location 클래스가 더 이상 TimeZone을 직접 포함하지 않도록 수정했다면, 여러분 역시 코드를 수정해 주어야 한다.

위와 같이 직접 위계 구조를 헤집지 말고, 필요한 정보는 직접 물어보자.

```java
public void plotDate(Date aDate, TimeZone aTz) {
  // ...
}
plotDate(someDate, someSelection.getTimeZone());
```

Selection에 메서드를 추가하여 직접 시간대를 얻을 수 있도록 하였다. 그래프를 그리는 루틴은 시간대가 Recorder로부터 직접 왔는지, Recorder에 포함된 어떤 객체로부터 왔는지, 혹은 Selection이 직접 시간대를 만드는지에 대해서는 상관하지 않는다. 마찬가지로 Selection 루틴도 Recorder에게 시간대를 물을 것이며, 자신이 포함하고 있는 Location 객체로부터 시간대를 알아내는 것은 Recorder의 책임이다.

직접 객체간의 관계를 헤집고 다닌다면 의존 관계가 조합적으로 폭발(combinatorial explosion)하게 될 수 있다. 예를 들면,

1. 단위 테스트를 링크하기 위한 명령어가 테스트 프로그램 자체보다 긴 대규모 C, C++ 프로젝트
2. 한 모듈의 '간단한' 수정이 이와 관계없는 모듈을 통해 시스템 전역에 퍼져나가는 경우
3. 개발자가 수정한 부분이 시스템에 어떤 영향을 미칠지 몰라 코드의 수정을 두려워하는 경우.

와 같은 경우가 예시일 수가 있을 것이다. 불필요한 의존이 많은 시스템은 유지보수 하기 어렵고, 이로 인해 비용이 많이 들며 시스템 자체가 매우 불안정한 경향이 있다. **우리는 의존도를 최소화 하기 위해 디미터 법칙을 사용하여 메서드, 함수를 설계한다.**

### 디미터 함수 법칙

디미터 함수 법칙은 프로그램에서 모듈간 결합도를 최소화하려 시도한다. 이 법칙은 한 객체가 제공하는 메서드에 접근하기 위해 또 다른 객체들을 통하는 것을 허용하지 않는다. 디미터 법칙은 아래 코드에 요약해 볼 수 있다. '부끄럼 타는' 코드를 작성해서 디미터 법칙을 가능한 만족시킨다면 우리의 목적을 이룰 수 있다.

```cpp
class Demeter { // 디미터 법칙은 객체의 모든 메서드는 다음에 해당되는 메서드만을 호출해야 한다고 말한다.
private:
  A *a;
  Int func();
public:   
  // ...
  void example(B& b);
}
void Demeter::example(B& b) {
  C c;
  Int f = func(); // 자신
  b.invert(); // 메서드로 넘어온 인자
  a = new A();
  a->setActive(); // 자신이 생성한 객체
  c.print(); // 직접 포함하고 있는 객체
}
```

*Tip: 모듈간의 결합도를 최소화하라*

디미터 법칙을 따르면 함수를 호출하는 클래스의 응답집합 크기를 줄일 수 있기 때문에 좀 더 에러가 적은 클래스들을 만들 수 있다. 반면 디미터 법칙은 코드를 더 적응성 있고 강하게 만들어 주지만 '주계약자(general contracter)'로서의 대가를 치러야 한다. 주계약자는 모든 하부 계약자를 직접 관리하고, 이들에게 일을 위임해 주어야 한다. 실제로 이는 위임자에게 단순히 요청을 전달하는 역할만을 하는 간단한 위임 메서드를 상당수 만들어야 함을 의미한다. 이러한 위임 메서드는 성능 저하와 메모리 과부화와 같은 문제를 야기할 수 있는데, 이러한 문제는 어떤 종류의 어플리케이션에서는 심각할 수도 있고, 심지어 절대 금해야 하는 것일 수도 있다.

여느 기술과 마찬가지로 디미터 법칙 역시 여러분이 만들려는 어플리케이션에 맞게 장점과 단점을 잘 고려해야 한다. 데이터베이스 스키마 설계시 '반정규화(denormalization)'를 통해 성능을 개선하는 것은 흔한 일이다. 정규화 법칙을 어기는 대신 속도라는 이점을 얻는 것이다. 비슷한 트레이드오프가 여기에도 있다. 디미터 법칙과 반대로 여러 모듈의 결합도를 높임으로써 중요한 성능향상을 꾀할 수도 있다. 해당 모듈들이 서로 결합하고 있다는 것을 잘 알고, 또 그것을 받아들일 수 있다면 아직 괜찮은 설계라 할 수 있다.
