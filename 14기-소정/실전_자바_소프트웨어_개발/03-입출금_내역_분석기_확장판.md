# 입출금 내역 분석기 확장판

- 특정 입출금 내역을 검색할 수 있는 기능
    - 주어진 날짜 범위나 특정 범주의 입출금 내역 조회
- 검색 결과의 요약 통계를 텍스트, HTML 등 다양한 형태로 반환

## 개방/폐쇄 원칙

새로 추가하는 기능인 입출금 내역 검색은 어디에 정의해야 할까? `BankTransactionFinder`라는 새로운 클래스를 정의할 수도 있지만 이름이 다양해 혼란스러울 수
있으므로 기존에 처리 기능을 담당하던 `BankTransactionProcessor`에 추가해보자.

```java
public class BankStatementProcessor {

  private final List<BankTransaction> bankTransactions;

  public BankStatementProcessor(List<BankTransaction> bankTransactions) {
    this.bankTransactions = bankTransactions;
  }

  public double calculateTotalAmount() {
    double total = 0d;

    for (final BankTransaction bankTransaction : bankTransactions) {
      total += bankTransaction.getAmount();
    }

    return total;
  }

  public double calculateTotalInMonth(final Month month) {
    double total = 0;

    for (final BankTransaction bankTransaction : bankTransactions) {
      if (bankTransaction.getDate().getMonth() == month) {
        total += bankTransaction.getAmount();
      }
    }

    return total;
  }

  public double calculateTotalForCategory(final String category) {
    double total = 0;

    for (final BankTransaction bankTransaction : bankTransactions) {
      if (bankTransaction.getDescription().equals(category)) {
        total += bankTransaction.getAmount();
      }
    }

    return total;
  }

  // 특정 금액 이상의 모든 입출금 내역을 검색하는 기능을 추가한다.
  public List<BankTransaction> findTransactionsGreaterThanEqual(final int amount) {
    final List<BankTransaction> result = new ArrayList<>();

    for (final BankTransaction bankTransaction : bankTransactions) {
      if (bankTransaction.getAmount() >= amount) {
        result.add(bankTransaction);
      }
    }

    return result;
  }
}
```

만약 금액이 아닌 월로 검색해야 한다면?

```java
public class BankStatementProcessor {
    ...

  public List<BankTransaction> findTransactionsInMonth(final Month month) {
    final List<BankTransaction> result = new ArrayList<>();

    for (final BankTransaction bankTransaction : bankTransactions) {
      if (bankTransaction.getDate().getMonth() == month) {
        result.add(bankTransaction);
      }
    }

    return result;
  }
}
```

입출금 내역을 검색하는 메서드들이 중복 코드를 가진다. 중복 코드가 많아지면 수정 사항이 생길 때마다 고칠 곳이 많아진다.

```java
public class BankStatementProcessor {
    ...

  public List<BankTransaction> findTransactionsInMonthAndGreater(final Month month,
      final int amount) {
    final List<BankTransaction> result = new ArrayList<>();

    for (final BankTransaction bankTransaction : bankTransactions) {
      if (bankTransaction.getDate().getMonth() == month && bankTransaction.getAmount() >= amount) {
        result.add(bankTransaction);
      }
    }

    return result;
  }
}
```

그렇다고 이렇게 합쳐서 만든다면 아래와 같은 한계가 있다.

- 조회 조건을 추가할 수록 코드가 복잡해진다.
- 반복 로직과 비즈니스 로직이 결합되어 분리가 어렵다.
- 코드를 반복한다.

개방/폐쇄 원칙을 이용하면 코드를 복사하거나 파라미터를 추가하는 등의 변경 없이 동작을 확장할 수 있다.

```java
// 자바 8에서는 `Predicate<T>`라는 제네릭 인터페이스로 같은 로직을 대체할 수 있다.
@FunctionalInterface
public interface BankTransactionFilter {

  boolean test(BankTransaction bankTransaction);
}
```

`BankTransactionFilter` 인터페이스를 만들어 `BankTransaction`을 받아 boolean 값을 반환한다. `test()`
가 `BankTransaction`의 모든 속성을 다룰 수 있어 이를 이용해 조회 조건에 맞는지 판단한다.

```java
public class BankStatementProcessor {
    ...

  public List<BankTransaction> findTransactions(final BankTransactionFilter bankTransactionFilter) {
    final List<BankTransaction> result = new ArrayList<>();

    for (final BankTransaction bankTransaction : bankTransactions) {
      if (bankTransactionFilter.test(bankTransaction)) {
        result.add(bankTransaction);
      }
    }

    return result;
  }
}
```

새로운 인터페이스를 통해 반복 로직과 비즈니스 로직의 결합을 제거했다. 더 이상 특정 필터 구현에 의존하지 않기 때문에, 조건마다 바디를 바꿀 필요 없이 인수로만 전달하면 된다.

### 함수형 인터페이스의 인스턴스 만들기

```java
public class BankTransactionIsInFebruaryAndExpensive implements BankTransactionFilter {

  @Override
  public boolean test(BankTransaction bankTransaction) {
    return bankTransaction.getDate().getMonth() == Month.FEBRUARY
        && bankTransaction.getAmount() >= 1_000;
  }
}
```

```java
public class BankStatementAnalyzer {

  private static final String RESOURCES = "src/main/resources/";

  public void analyze(final String fileName, final BankStatementParser bankStatementParser)
      throws IOException {
    ...

    // 조회할 조건의 필터를 findTransactions()의 파라미터로 전달한다.
    final BankStatementProcessor bankStatementProcessor = new BankStatementProcessor(
        bankTransactions);
    final List<BankTransaction> transactions = bankStatementProcessor
        .findTransactions(new BankTransactionIsInFebruaryAndExpensive());

    collectSummary(bankStatementProcessor);
  }
  
  ...
}
```

정의한 인터페이스의 구현체를 만든 뒤, 그 필터의 인스턴스를 인자로 넘기면 해당 조건으로 조회할 수 있다.

### 람다 표현식

하지만 앞의 방식은 새로운 조회 조건이 생길 때마다 클래스를 만들어줘야 한다.

```java
public class BankStatementAnalyzer {

  private static final String RESOURCES = "src/main/resources/";

  public void analyze(final String fileName, final BankStatementParser bankStatementParser)
      throws IOException {
    ...

    // 조회할 조건의 필터를 findTransactions()의 파라미터로 전달한다.
    final BankStatementProcessor bankStatementProcessor = new BankStatementProcessor(
        bankTransactions);
    final List<BankTransaction> transactions = bankStatementProcessor
        .findTransactions(bankTransaction ->
            bankTransaction.getDate().getMonth() == Month.FEBRUARY
                && bankTransaction.getAmount() >= 1_000);

    collectSummary(bankStatementProcessor);
  }
  
  ...
}
```

람다를 이용해 `bankTransaction` 파라미터로 조건식을 표현해 구하면 간단해진다.

### 정리

개방/폐쇄 원칙은 아래의 장점 때문에 사용한다.

- 기존 코드를 바꾸지 않으므로 기존 코드가 잘못될 가능성이 줄어든다.
- 코드가 중복되지 않으므로 기존 코드의 재사용성이 높아진다.
- 결합도가 낮아지므로 코드 유지보수성이 좋아진다.

## 인터페이스 문제

### 갓 인터페이스

```java
public interface BankTransactionProcessor {

  double calculateTotalAmount();

  double calculateTotalInMonth(Month month);

  double calculateTotalInJanuary();

  double calculateAverageAmount();

  double calculateAverageAmountForCategory(Category category);

  List<BankTransaction> findTransactions(BankTransactionFilter bankTransactionFilter);
}
```

`BankTransactionProcessor`의 구현과의 결합을 제거하기 위해 인터페이스로 분리해보자.

- 모든 연산 메서드가 포함되어 있어 복잡하고 갓 인터페이스가 만들어진다.
    - 구현 클래스는 인터페이스에 정의된 모든 연산을 구현해야 한다.
    - 연산을 추가할 수록 코드가 자주 바뀌고 문제가 발생할 범위도 커진다.
- 인터페이스가 도메인 객체의 특정 접근자에 종속된다.
    - 월, 카테고리 같은 `BankTransaction`의 속성이 메서드 이름의 일부로 사용되었다.
    - 도메인 객체(`BankTransaction`)의 세부 내용이 바뀌면 인터페이스와 구현체도 바뀌어야 한다.

### 지나친 세밀함

```java
interface CalculateTotalAmount {

  double calculateTotalAmount();
}

interface CalculateAverage {

  double calculateAverage();
}

interface CalculateTotalInMonth {

  double calculateTotalInMonth(Month month);
}
```

그렇다고 모든 동작을 인터페이스로 분리하면 유지 보수에 방해가 된다.

- 새로운 인터페이스가 계속 추가되어야 해서 복잡해진다.
- 기능이 분산되어 필요한 기능을 찾기 힘들다.
    - 자주 사용하는 기능을 쉽게 찾을 수 있어야 유지보수성도 좋아진다.

## 명시적 API와 암묵적 API

`BankTransactionProcessor`는 단순히 입출금 내역에서 통계 연산을 수행한다. 프로그램 전체가 사용할 수 있는 메서드를 제공하거나 다양한 메서드가 필요한 클래스가
아니다. 따라서 불필요하게 추상화해 복잡하게 할 필요는 없다.

인터페이스 대신 클래스로 구현한다면 메서드를 더 쉽게 정의할 수 있다. 이때 `findTransactionsGreaterThanEqual()`처럼 구체적인 이름이
좋을까, `findTransactions()`처럼 일반적인 것이 좋을까?

### 명시적 API

- `findTransactionsGreaterThanEqual()`
- 어떤 동작을 수행하는지 바로 알 수 있다.
- 특정 상황에 국한되기 때문에 상황에 맞는 메서드를 여러 개 만들어야 한다.

### 암묵적 API

- `findTransactions()`
- 알아보기 힘들어서 문서화를 잘 해놔야 한다.
- 필요한 모든 상황을 단순한 API로 처리할 수 있다.

상황에 따라 자유롭게 사용하면 된다. 만약 `findTransactionsGreaterThanEqual()`이 자주 사용하는 연산이라면 쉽게 이해하고 사용하도록 명시적으로 만드는
게 합리적이다.

```java

@FunctionalInterface
public interface BankTransactionSummarizer {

  double summarize(double accumulator, BankTransaction bankTransaction);
}
```

```java

@FunctionalInterface
public interface BankTransactionFilter {

  boolean test(BankTransaction bankTransaction);
}
```

```java
public class BankStatementProcessor {

  ...

  public double summarizeTransactions(final BankTransactionSummarizer bankTransactionSummarizer) {
    double result = 0;

    for (final BankTransaction bankTransaction : bankTransactions) {
      result = bankTransactionSummarizer.summarize(result, bankTransaction);
    }

    return result;
  }

  public double calculateTotalInMonth(final Month month) {
    // BankTransactionSummarizer를 사용해 total을 계산한다.
    return summarizeTransactions((acc, bankTransaction) ->
        bankTransaction.getDate().getMonth() == month ? acc + bankTransaction.getAmount() : acc);
  }

 ...

  public List<BankTransaction> findTransactions(final BankTransactionFilter bankTransactionFilter) {
    final List<BankTransaction> result = new ArrayList<>();

    for (final BankTransaction bankTransaction : bankTransactions) {
      if (bankTransactionFilter.test(bankTransaction)) {
        result.add(bankTransaction);
      }
    }

    return result;
  }

  public List<BankTransaction> findTransactionsGreaterThanEqual(final int amount) {
    // BankTransactionFilter를 이용해 조건에 맞는 거래 내역을 조회한다.
    return findTransactions(bankTransaction -> bankTransaction.getAmount() >= amount);
  }
}

```

`BankTransactionSummarizer`는 원싯값인 double을 반환한다. 만약 다른 결과를 반환하려면 `BankStatementProcessor`의 모든 구현을
수정해야 한다.

double을 감싸는 새로운 도메인 클래스 `Summary`를 만들면 필요한 필드를 자유롭게 추가할 수 있다.

- 도메인 개념 간의 결합을 줄인다.
- 요구 사항 변경 시 코드가 연쇄적으로 바뀌는 일이 줄어든다.

## 다양한 형식으로 보내기

HTML, JSON 등 다양한 형식으로 입출금 목록 통계를 보내보자.

### 숫자

`calculateTotalInMonth()`은 연산 결과로 double을 반환한다.

- 간단하게 구현할 수 있다.
- 요구 사항이 바뀌면 모든 코드의 결과값 형식을 바꿔야 한다.
    - 새로운 버그가 발생할 수 있다.

### 컬렉션

`findTransactions()`는 리스트를 반환한다.

- Iterable을 반환하면 상황에 맞춰 처리할 수 있어 유연하다.
- 오직 컬렉션만 반환해야 한다는 제한이 생긴다.

### 도메인 객체

요약 정보를 대표하는 `SummaryStatistics`라는 도메인 객체를 만든다. 도메인 객체란 자신의 도메인과 관련된 클래스의 인스턴스다.

- 결합을 깰 수 있다.
    - 새로운 요구 사항이 생겨서 추가 정보를 보내야 할 때 기존 코드를 수정하지 않고 도메인 객체만 수정하면 된다.

### 더 복잡한 도메인 객체

`SummaryStatistics`처럼 단순한 통계가 아닌 `Report` 같은 일반적이고 다양한 결과를 저장하는 개념을 만들 수도 있다.

- 복잡한 정보를 보내야 하는지 여부에 따라 도메인 객체가 달라진다.
- 어떤 조건이 되어도 `Report` 객체를 만드는 부분과 사용하는 부분이 결합하지 않는다.

```java
public class SummaryStatistics {

  private final double sum;
  private final double max;
  private final double min;
  private final double average;

  public SummaryStatistics(double sum, double max, double min, double average) {
    this.sum = sum;
    this.max = max;
    this.min = min;
    this.average = average;
  }

  public double getSum() {
    return sum;
  }

  public double getMax() {
    return max;
  }

  public double getMin() {
    return min;
  }

  public double getAverage() {
    return average;
  }
}
```

거래 내역의 요약 정보를 저장하는 `SummaryStatistics`를 선언해보자.

### 적절하게 인터페이스를 정의하고 구현하기

내보낼 형식을 `SummaryStatistics`로 정했으므로 이를 구현하는 API를 만들어보자.

```java
public interface Exporter {

  void export(SummaryStatistics summaryStatistics);
}
```

`Exporter`를 인터페이스로 정의하면 JSON으로 보내든 XML로 보내든 인터페이스를 상속해서 구현만 하면 된다.

하지만 인터페이스를 이렇게 정의하면 아래와 같은 문제가 발생한다.

- void를 반환하면 기능을 파악하기 어렵다.
    - 메서드가 무엇을 반환하는지 알 수 없다.
    - `export()`가 반환하지 않으니 어디선가 다른 클래스가 대신 작업을 진행하고 출력하게 된다.
    - 인터페이스로부터 얻을 수 있는 정보가 아무것도 없다.
- 테스트 하기 어렵다.
    - 예상 값과 실제 값을 비교할 수 있는 방법이 없다.
  
```java
public interface Exporter {
  String export(SummaryStatistics summaryStatistics);
}
```

지정한 반환 값을 이용해 파일에 저장하거나 전송하는 등의 로직을 처리할 수 있게 된다.

```java
public class HtmlExporter implements Exporter {

  @Override
  public String export(SummaryStatistics summaryStatistics) {
    String result = "<!doctype html>";
    result += "<html lang='en'>";
    result += "<head><title>Bank Transaction Report</title></head>";
    result += "<body>";
    result += "<ul>";
    result += "<li><strong>The sum is</strong>: " + summaryStatistics.getSum() + "</li>";
    result += "<li><strong>The average is</strong>: " + summaryStatistics.getAverage() + "</li>";
    result += "<li><strong>The max is</strong>: " + summaryStatistics.getMax() + "</li>";
    result += "<li><strong>The min is</strong>: " + summaryStatistics.getMin() + "</li>";
    result += "</ul>";
    result += "</body>";
    result += "</html>";
    return result;
  }
}
```

`Exporter`를 구현하면 위와 같다.