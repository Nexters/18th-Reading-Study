# 문서 관리 시스템

## 요구 사항

- 리포트, 우편물, 이미지 파일을 읽어 색인을 추가하고 검색할 수 있다.
- 각 문서는 파일 경로와 환자 정보를 포함해야 한다.
- 차츰 다른 종류의 문서도 추가될 수 있다.

## 설계 작업

`DocumentManagementSystem` 클래스에 문서를 임포트 해서 내부 문서 저장소에 추가한다.

- void importFile(String path)
    - 임포트하려는 파일의 경로를 받는다.
    - 사용자 입력을 받는 공개 API이므로 `java.io.File`처럼 안전한 형식 대신 평범한 String을 사용한다.
- List<Document> contents()
    - 문서 관리 시스템에 저장된 모든 문서 목록을 반환한다.
    - 즉, Document 클래스의 목록을 반환한다.

### 임포터

확장자로 파일을 어떻게 임포트할지 결정한다. 임포트할 파일 확장자는 `.letter`, `.report`, `.jpg`다.

```java
class Importer {

  public void importFile(String path) {
    switch (extension) {
      case "letter":
        break;
      case "report":
        break;
      case "jpg":
        break;
      default:
        throw new InknownFileTypeException("For file: " + path);
    }
  }
}
```

switch를 사용하면 확장자가 추가될 때마다 항목을 추가해야 해서 확장성이 떨어진다.

`Importer` 인터페이스를 정의해 이를 구현하는 클래스를 사용하도록 해보자.

```java
public interface Importer {
  Document importFile(File file) throws IOException;
}
```

임포트하려는 파일은 단순 String으로 하거나 `java.io.File`처럼 클래스를 사용할 수도 있다. 후자를 사용하면 강한 형식 원칙이 적용돼 오류가 줄어든다.

문서 관리 시스템 공개 API에 File 대신 String을 사용하는 이유는 다른 종류의 인터페이스로 감싸진 상태라 어떤 파일을 지원하는지 알 수 없기 때문이다.

### Document 클래스

가장 간단하게는 `Map<String, String>`으로 문서를 정의하는 것이다. `Map`을 `Document` 클래스로 감싸서 사용하는 이유는 다음과 같다.

#### 유비쿼터스 언어

- 개발자와 사용자 모두가 사용할 수 있도록 설계, 공유된 공통 언어
- 고객이 사용하는 용어와 코드를 똑같이 사용하면 유지보수가 쉬워진다.
- 어떤 코드를 바꿔야하는지 쉽게 알 수 있다.(발견성)

#### 강한 형식의 원칙

강한 형식을 이용하면 데이터 사용 방법을 규제할 수 있다. 

`Document` 클래스는 생성한 후에는 속성을 바꿀 수 없는 불변 클래스다. `Importer`에서 파일을 받아 문서를 만들면 수정할 수 없는 것이다. 따라서 `Document`의 속성에서 오류가 나면 이를 생성한 `Importer`의 구현을 확인하면 된다. 불변성 덕분에 안전하게 `Document`의 색인을 만들거나 정보를 캐시할 수 있다.

```java
public class Document {

  private final Map<String, String> attributes;

  Document(final Map<String, String> attributes) {
    this.attributes = attributes;
  }

  public String getAttribute(final String attributeName) {
    return attributes.get(attributeName);
  }
}
```

`Document`의 생성자는 패키지 내부에서만 사용할 수 있게 제한된다. 오직 문서 관리 시스템에서만 만들 수 있어야하므로 다른 곳에서 접근하지 못하도록 막는다.

### Document의 속성

강한 형식과는 거리가 멀게 `Document`는 속성에 String을 사용했다. 이를 문자화 형식이라고 한다.

- 속성을 텍스트로 하면 텍스트로 속성을 검색할 수 있다.
- Importer 종류에 상관없이 모든 속성이 일반적인 형식을 갖도록 한다.
- 다만, 응용 프로그램 단에서 String으로 정보를 전달하는 것은 좋지 않다.

만약 속성값이 복잡해서 가로, 세로 등을 검색해야 한다면 강한 형식으로 정의하는 게 좋다.

### Document의 계층

`ReportImporter`는 `Importer`를, `Report`는 `Document`를 상속한다. 각 서브 클래스는 전용 필드를 갖지 않는다. 모든 속성은 범용이다. 자신과 관련된 동작도 거의 포함하지 않는다. 그렇지 않으면 상속 등 계층 관계로 만들 이유가 없다.

설계는 단순할수록 좋다는 KISS 원칙을 따라야 한다. 반드시 필요한 기능보다 있으면 좋은 기능을 추가하다보면 설계가 복잡해진다.

### 임포터 구현과 등록

```java
class ImageImporter implements Importer {

  @Override
  public Document importFile(final File file) throws IOException {
    final Map<String, String> attributes = new HashMap<>();
    attributes.put(PATH, file.getPath());

    final BufferedImage image = ImageIO.read(file);
    attributes.put(WIDTH, String.valueOf(image.getWidth()));
    attributes.put(HEIGHT, String.valueOf(image.getHeight()));
    attributes.put(TYPE, String.valueOf(image.getType()));

    return new Document(attributes);
  }
}
```

- `WIDTH`처럼 속성을 상수로 등록하면 실수를 방지할 수 있다.

```java
public class Attributes {
  public static final String PATH = "path";
  public static final String WIDTH = "width";
  public static final String HEIGHT = "height";
  public static final String TYPE = "type";
}
```

- 상수는 public으로 어디서든 재사용할 수 있도록 한다.
- final로 변수에 다른 값을 할당할 수 없게 한다.
- static으로 클래스가 인스턴스 하나만 갖도록 한다.

```java
public class DocumentManagementSystem {
  private final Map<String, Importer> extensionToImporter = new HashMap<>();

  public DocumentManagementSystem() {
    extensionToImporter.put("letter", new LetterImporter());
    extensionToImporter.put("report", new ReportImporter());
    extensionToImporter.put("jpg", new ImageImporter());
  }
}
```

- 시스템에 각 확장자에 맞는 임포터를 등록한다.