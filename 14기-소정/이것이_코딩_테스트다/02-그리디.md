# 당장 좋은 것만 선택하는 그리디

- 단순 무식하게 탐욕적으로 푸는 알고리즘
- 당장에 좋은 것만 선택하는 방법으로, 나중에 미칠 영향은 고려하지 않는다.

## 거스름돈

거슬러 줘야 할 돈이 N원일 때 거슬러줄 동전의 최소 개수를 구하라. N은 항상 10의 배수이며 500원, 100원, 50원, 10원으로 거슬러줄 수 있다.

### 해설

- 가장 큰 화폐 단위부터 돈을 거슬러주면 최소 개수가 된다.

```python
n = 1260
count = 0

# 큰  단위의 화폐부터 차례대로 확인

coin_types = [500, 100, 50, 10]

for coin in coin_types:
    count += n // coin  # 해당 화폐로 거슬러 줄 수 있는 동전의 개수
    n %= coin
    
print(count)
```

- 화폐 단위가 K개라고 할 때 시간 복잡도는 O(K)가 된다.

## 그리디 알고리즘의 정당성

- 그리디로 풀 때는 정당한지 검토해야 한다.
- 이 문제는 동전의 큰 단위가 작은 단위의 배수이기 때문에 적합했다.
  - 800원을 거슬러줄 때 단위가 500원, 400원, 100원이었다면 그리디로는 500원 + 100원 + 100원 + 100원 + 100원이 나오지만, 400원 + 400원이 최적이다.
- 바로 문제 유형을 파악하기 힘들면 일단 그리디를 의심한다.
- 그리디로 해결이 되지 않으면 다이나믹이나 그래프로 해결할 수 있는지 고민한다.

## 큰 수의 법칙

주어진 수를 M번 더하여 가장 큰 수를 만든다. 단, K번을 초과하여 더해질 수 없다.

- 첫째 줄이 N, M, K의 자연수가 주어진다.
- 둘째 줄에 N개의 자연수가 주어진다.
- 입력으로 주어지는 K는  항상 M보다 작거나 같다

```
# 배열 크기, 더할 횟수, 반복 횟수를 공백으로 구분해 입력 받는다.
n, m, k = map(int, input().split())
# n개의 수를 공백으로 구분해 입력 받는다.
data = list(map(int, input().split()))

data.sort(reverse=True)
first = data[0]
second = data[1]

result = 0

while True:
    for i in range(k):  # 가장 큰 수를 k번 더한다.
        if m == 0:  # 더할 횟수가 0이면 반복할 필요가 없으므로 빠져나온다.
            break

        result += first
        m -= 1  # 더할 때마다 더할 횟수가 줄어든다.

    if m == 0:  # 제일 큰 수를 처리하고 나서 더할 횟수가 없으면 while을 빠져나온다.
        break

    result += second  # 두 번째로 큰 수는 한 번만 더한다.
    m -= 1  # 더할 횟수가 줄어들고 다시 큰 수를 더하러 반복문 앞으로 간다.

print(result)
```

전형적인 그리디 문제로, 아이디어를 떠올리는 것은 어렵지 않으나 구현 실수가 많으므로 꼭 직접 작성해본다.

```
n, m, k = map(int, input().split())
data = list(map(int, input().split()))

data.sort(reverse=True)
first = data[0]
second = data[1]

count = int(m/(k+1)) * k
count += m % (k+1)

result = 0
result += count * first
result += (m-count) * second

print(result)
```

[6, 6, 6, 5] 라는 수열이 일정하게 반복된다는 사실을 파악하면 더 쉽게 풀 수 있다.

수열의 길이는 (반복 횟수 k)+1이 된다. 따라서 더할 횟수 m을 k+1로 나누면 수열이 반복되는 횟수가 나온다. 다시 여기에 k를 곱하면 가장 큰 수가 나오는 횟수다.
m이 k+1로 나누어 떨어지지 않으면 그 나머지만큼 가장 큰 수가 추가로 더해진다. 따라서 가장 큰 수가 더해지는 횟수는 int(m/(k+1))*k  + m%(k+1)

## 숫자 카드 게임

- 숫자가 쓰인 카드들이 N * M으로 놓여있다.
- 뽑고자 하는 카드가 포함된 행을 선택한다.
- 그 다음 선택된 행에 포함도니 카드 중 가장  숫자가 낮은 카드를 뽑아야 한다.
- 즉, 처음 카드를 골라낼 행을 선택할 때 이후 가장 낮은 카드를 뽑을 것을 생각해 가장 높은 숫자를 뽑도록 전략을 세워야 한다.

```
x, y = map(int, input().split())
arr = list(range(y))

result = 0

for i in range(x):
    arr = map(int, input().split())
    m = min(arr)

    result = max(result, m) # min, max 함수를 사용할 줄 알아야 한다.

print(result)
```

그리디는 아이디어만 떠올리면 바로 정답을 찾을 수 있다. 아이디어는 각 행마다 가장 작은 수를 찾은 뒤에 그 수 중에 가장 큰 수를 찾는 것이다.

## 1이 될 때까지

```python
n, k = map(int, input().split())

result = 0

while True:
    # k로 나누어 떨어지는 수를 임의로 구한다.
    target = (n // k) * k
    # 1을 빼는 연산을 몇 번을 수행하게 될지 구한다.
    result += n - target
    # 이제 k로 나누어 떨어지는 것만 고려했을 때 몇 번을 해야할지 구한다.
    n = target

    # n이 k보다 작을 때(더 나눌 수 없을 때) 반복문을 나간다.
    if n < k:
        break

    # k로 나누는 연산은 한 번 수행되므로 1을 더해준다.
    result += 1
    # k로 나눈다.
    n //= k

# n < k인데도 n이 1보다 크다면 이 남은 수에 대해 1씩 빼는 연산을 해야하므로 그 횟수만큼 더한다.
result += (n - 1)

print(result)
```

N을 최대한 많이 나누면 빠르게 답을 구할 수 있다.