# 아이디어를 코드로 바꾸는 구현
## 피지컬로 승부하기

- 구현
  - 알고리즘을 소스 코드로 바꾸는 과정
  - 막상 코드로 옮기려니 무엇을 작성해야 할지 모를 수 있다.
  - 문법과 라이브러리에 대한 경험이 있어야 수월하다.
  - 이 책에서는 완전 탐색, 시뮬레이션 유형을 구현으로 묶어 다룬다.

## 구현 시 고려해야 할 메모리 제약 사항

int의 데이터 개수에 따른 메모리 사용량은 다음과 같다.

|데이터의 개수(리스트의 길이)|메모리 사용량|
|------|---|
|1,000|약 4KB|
|1,000,000|약 4MB|
|10,000,000|약 40MB|

- 파이썬은 자료형을 명시할 필요가 없지만 데이터 처리량이 많다면 꼭 메모리 제한을 고려한다.
- 1,000만 이상인 리스트가 있다면 용량 제한에 걸릴 수 있다.
- 일반적인 코딩 테스트 수준에서는 복잡한 최적화를 요구하지 않는다.

## 채점 환경

- 제한 시간이 1초이고 데이터 개수가 100만 개라면 일반적으로 O(NlogN) 이내로 풀어야 한다.
- 문제를 풀 때 시간 제한과 데이터 개수를 먼저 확인해 시간 복잡도를 예측해야 한다.

## 구현 문제에 접근하는 방법

- 문제의 길이는 길지만 고차원적이지 않아 익숙하다면 쉽게 풀 수 있다.
- 파이썬은 기본 문법만 알아도 구현 문제를 쉽게 해결할 수 있다.

### 상하좌우

```python
n = int(input())
x, y = 1, 1
plans = input().split()

# L, R, U, D에 따른 이동 방향
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
move_types = ['L', 'R', 'U', 'D']

# 이동 계획 확인한다.
for plan in plans:
    # 이동 후 좌표를 계산한다.
    for i in range(len(move_types)):
        if plan == move_types[i]:
            nx = x + dx[i]
            ny = y + dy[i]

    # 공간을 벗어나면 무시한다.
    if nx < 1 or ny < 1 or nx > n or ny > n:
        continue

    # 이동한다.
    x, y = nx, ny

print(x, y)
```

- 일련의 명령에 따라 개체를 차례로 이동시킨다는 점에서 시뮬레이션 유형으로 분류된다.
- 이동 횟수가 N번이면 시간 복잡도는 O(N)이 된다.
- 좌표 값을 리스트에 담아 처리한다.

### 시각

```python
n = int(input())
count = 0

for i in range(n+1):
  for k in range(60):
    for j in range(60):
      # 문자열 3이 포함됐는지 문자열로 치환해서 검사한다.
      if '3' in str(i) + str(j) + str(k):
        count += 1

print(count)
```

- 하루는 86,400초다. 즉, 모든 경우의 수가 86,400개밖에 안되므로 하나씩 세서 풀어도 된다.
- 시, 분, 초에대해 3중 반복문을 사용한다.

## 왕실의 나이트

```python
input_data = input()

# a1로 들어온다면 1이 row
row = int(input_data[1])
# a1로 들어온다면 a가 row
# 아스키 코드로 변환해서 a값으로 뺀 뒤 1을 더하면 위치가 나온다.
column = int(ord(input_data[0])) - int(ord('a')) + 1

# dx, dy처럼 따로 리스트를 만들지 않고 이렇게 하나로 합쳐서 쓸 수도 있다.
steps = [(-2, -1), (-1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)]

result = 0
for step in steps:
  # step = (x, y)이므로 x값을 더한다.
  next_row = row + step[0]
  # step = (x, y)이므로 y값을 더한다.
  next_column = column + step[1]

  if next_row >= 1 and next_row <= 8 and next_column >=1 and next_column <= 8:
    result += 1

print(result)
```

- 모든 이동 경로를 steps에 담는다.
- 현재 위치에서 이동 경로를 더한 뒤 정상적인 좌표 위에 있는지 확인한다.
- 8가지 경우의 수를 반복문으로 하나씩 검사한다.
- dx dy 대신 steps를 활용하는 방식이다.