# DFS / BFS
## 꼭 필요한 자료구조 기초

- 탐색
  - 많은 양의 데이터 중에 원하는 데이터를 찾는 과정
  - DFS, BFS는 대표적인 탐색 알고리즘이다.
  - 이 둘을 이해하려면 스택과 큐를 이해해야 한다.
- 자료구조
  - 데이터를 표현, 관리, 처리하기 위한 구조
- 오버플로
  - 자료구조가 수용할 수 있는 데이터 크기가 이미 찬 상태에서 삽입(push)을 수행할 때 발생
- 언더플로
  - 자료구조에 데이터가 전혀 있지 않은 상태에서 삭제(pop)를 수행할 때 발생

### 스택

- 선입후출
  - 박스 쌓기와 같다.
  - 아래에서 위로 쌓는다.
  - 아래에 있는 박스를 치우려면 위에 있는 박스를 먼저 내려야 한다.

```python
stack = []

stack.append(5)
stack.append(2)
stack.append(3)
stack.append(7)

stack.pop()

stack.append(1)
stack.append(4)

stack.pop()

# 최하단 원소부터 출력
# [5, 2, 3, 1]
print(stack)

# 최상단 원소부터 출력
# [1, 3, 2, 5]
print(stack[::-1])
```

- append()는 리스트의 가장 뒤쪽에 데이터를 삽입한다.
- pop()은 리스트의 가장 뒤쪽에서 데이터를 꺼낸다.

### 큐

- 선입선출
  - 대기 줄과 같다.
  - 먼저 온 사람이 먼저 들어간다.
  - 나중에 온 사람이 나중에 들어간다.

```python
# 큐 구현을 위해 deque 라이브러리를 사용한다.
from collections import deque

queue = deque()

queue.append(5)
queue.append(2)
queue.append(3)
queue.append(7)

queue.popleft()

queue.append(1)
queue.append(4)

queue.popleft()

# 먼저 들어온 순서대로 출력한다.
# deque([3, 7, 1, 4])
print(queue)

# 역순으로 바꾼다.
queue.reverse()
# deque([4, 1, 7, 3])
print(queue)
```

- 파이썬으로 큐를 구현할 때는 collections 모듈의 deque 자료구조를 활용한다.
  - 스택과 큐의 장점을 모두 채택했다.
  - 데이터를 넣고 빼는 속도가 리스트에 비해 효율적이다.
  - queue 라이브러리보다 간단하다.
  - 대부분 코딩 테스트에서는 collection 모듈 등의 사용을 허용한다.
- deque 객체를 리스트로 바꾸려면 list(queue)를 사용한다.

### 재귀 함수

- 자기 자신을 다시 호출하는 함수
- DFS, BFS를 구현하려면 재귀를 이해해야 한다.

```python
def recursive_function():
  print('재귀 함수를 호출합니다.')
  recursive_function()
  
# 호출한다.
recursive_function()
```

위 함수를 실행하면 문자열이 무한이 출력되면서 결국 오류 메시지가 나오고 멈춘다.

#### 재귀 함수의 종료 조건

- 재귀 함수는 무한히 호출되지 않도록 종료 조건을 꼭 명시해야 한다.

```python
def recursive_function(i):
  # 100번째 출력했을 때 종료되도록 한다.
  if i == 100:
    return
  
  print(i, '번째 재귀 함수에서', i+1, '번째 재귀 함수를 호출합니다.')
  recursive_function(i+1)
  print(i, '번째 재귀 함수를 종료합니다.')
  
recursive_function(1)
```

- 재귀 함수는 스택을 이용한다.
  - 함수를 계속 호출했을 때 가장 마지막에 호출한 함수가 먼저 끝내야 그 앞의 함수도 종료된다.
- 따라서 스택을 활용하는 알고리즘은 재귀를 이용하면 간편하게 구현할 수 있다.

```python
# 반복적으로 구현한 팩토리얼
def factorial_iterative(n):
  result = 1
  
  # 1부터 n까지의 수를 차례로 곱한다.
  for i in range(1, n + 1):
    result *= i
    
  return result
  
# 재귀적으로 구현한 팩토리얼
def factorial_recursive(n):
  # n이 1 이하인 경우 1을 반환한다.
  if n <= 1:
    return 1
    
  # n! = n * (n - 1)!을 그대로 구현한다.
  return n * factorial_recursive(n-1)
```

- 재귀 함수를 사용하면 코드가 더 간결해진다.
  - 특정한 함수를 자신보다 더 작은 변수에 대한 함수와의 관계로 표현한 점화식을 그대로 코드로 옮겼기 때문이다.
  - 이 개념은 다이나믹 프로그래밍으로 이어진다.
- 팩토리얼은 n이 양수일 때만 유효하기 때문에 n <= 1인 경우는 1을 반환해서 종료하도록 한다.

## 탐색 알고리즘 DFS/BFS
### 그래프

- 그래프는 노드(Node)와 간선(Edge)으로 표현된다.
  - 노드는 정점(Vertex)이라고도 한다.
  - 두 노드가 간선으로 연결되어 있다면 인접한다고 표현한다.
- 그래프 탐색
  - 한 노드를 시작으로 다수의 노드를 방문하는 것

프로그래밍에서 그래프는 크게 2가지 방식으로 표현할 수 있다.

#### 인접 행렬

- 2차원 배열로 그래프의 연결 관계 표현
- 연결되지 않은 노드는 무한이라고 표현한다.
- 모든 관계를 저장하기 때문에 노드 개수가 많을 수록 메모리가 낭비된다.

```python
# 무한을 표현하기 위해 논리적으로 정답이 될 수 없는 큰 값으로 초기화 한다.
INF = 999999999

# 2차원 리스트를 이용해 인접 행렬 표현
graph = [
  [0, 7, 5],
  [7, 0, INF],
  [5, INF, 0]
]

# [[0, 7, 5], [7, 0, 999999999], [5, 999999999, 0]]
print(graph)
```

#### 인접 리스트

- 연결 리스트로 그래프의 연결 관계 표현
- 파이썬은 다른 언어와 달리 배열과 연결 리스트 기능을 모두 기본으로 제공한다.
- 연결된 정보만 저장하므로 메모리를 효율적으로 사용한다.
- 연결된 데이터를 하나하나 확인해야 해서 인접 행렬에 비해 특정 노드가 서로 연결되어 있는지 얻는 속도가 느리다.
  - 인접 행렬에서는 graph[1][7]만 확인하면 되는데, 리스트는 앞에서부터 차례로 확인해야 한다.

```python
# 행이 3개인 2차원 리스트로 인접 리스트를 표현한다.
graph = [[] for _ in range(3)]]

# 노드 0에 연결된 노드 정보 저장 (노드, 거리)
graph[0].append((1, 7))
graph[0].append((2, 5))

# 노드 1에 연결된 노드 정보 저장
graph[1].append((0, 7))

# 노드 2에 연결된 노드 정보 저장
graph[2].append((0, 5))

[[(1, 7), (2, 5)], [(0, 7)], [(0, 5)]]
print(graph)
```

### DFS

- Depth-First Search
- 깊이 우선 탐색
  - 그래프의 깊은 부분을 우선적으로 탐색하는 알고리즘

DFS는 특정한 경로로 탐색하다가 특정 상황에서 최대한 깊숙이 들어가 노드를 방문하고, 다시 돌아가 다른 경로를 탐색한다.

1. 탐색 시작 노드를 스택에 삽입하고 방문 처리 한다.
  - 방문 처리란 스택에 한 번 삽입되어 처리도니 노드가 다시 삽입되지 않게 체크하는 것이다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리 한다. 
   - 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 2번을 더 이상 수행할 수 없을 때까지 반복한다.

DFS는 순서와 상관없이 처리해도 되지만 코딩 테스트에서는 관행적으로 번호가 낮은 순서부터 처리하도록 구현한다.

- 스택을 기본으로 하므로 구현이 간단하고 데이터가 N개인 경우 O(N)의 시간이 걸린다.
- 스택을 이용하므로 실제 구현은 재귀 함수를 이용했을 때 매우 간결하다.

```python
# DFS 정의
def dfs(graph, v, visited):
  # 현재 노드 방문 처리
  visited[b] = True
  print(v, end='')
  
  # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
  for i in graph[v]:
    if not visited[i]:
      dfs(graph, i, visited)
      
# 각 노드가 연결된 정보를 리스트 자료형으로 표현
graph = [
  [],
  [2, 3, 8],
  [1, 7],
  [1, 4, 5],
  [3, 5],
  [3, 4],
  [7],
  [2, 6, 8],
  [1, 7]
]

# 각 노드가 방문된 정보를 리스트로 표현
visited = [False] * 9

# 정의된 DFS 함수 호출
# 1 2 7 6 8 3 4 5
dfs(graph, 1, visited)
```