# 객체, 설계

## 티켓 판매 애플리케이션 구현하기

- 이벤트에 당첨된 관람객은 무료로 관람할 수 있는 초대장이 있으며 티켓으로 교환해야 한다.
- 당첨되지 않는 관람객은 티켓을 구매해야만 입장할 수 있다.

```java
import java.time.LocalDateTime;

public class Invitation {
    private LocalDateTime when;
}
```

초대장은 공연을 관람할 수 잇는 초대 일자인 when을 인스턴스 변수로 가진다.

```java
public class Ticket {
    private Long fee;

    public Long getFee() {
        return fee;
    }
}
```

관람객은 티켓을 소지하고 있어야 한다.

```java
public class Bag {
    private Long amount;
    private Invitation invitation;
    private Ticket ticket;

    public Bag(Long amount) {
        this(null, amount);
    }

    public Bag(Invitation invitation, Long amount) {
        this.invitation = invitation;
        this.amount = amount;
    }

    public boolean hasInvitation() {
        return invitation != null;
    }

    public boolean hasTicket() {
        return ticket != null;
    }

    public boid setTicket(Ticket ticket) {
        this.ticket = ticket;
    }

    public void minusAmount(Long amount) {
        this.amount -= amount;
    }

    public void plusAmount(Long amount) {
        this.amount += amount;
    }
}
```

관람객은 초대장, 티켓, 현금을 포관할 가방을 가진다. Bag을 생성하는 시점에 초대장이 있거나 없는 조건을 강제하도록 생성자를 추가한다.

```java
public class Audience {
    private Bag bag;

    public Audience(Bag bag) {
        this.bag = bag;
    }

    public Bag getBag() {
        return bag;
    }
}
```

관람객은 소지품을 보관하기 위해 가방을 소지한다.

```java
import java.util.ArrayList;
import java.util.Arrays;

public class TicketOffice() {
    private Long amount;
    private List<Ticket> tickets = new ArrayList<>();

    public TicketOffice(Long amount, Ticket... tickets) {
        this.amount = amount;
        this.tickets.addAll(Arrays.asList(tickets));
    }

    public Ticket getTicket() {
        return tickets.remove(0);
    }

    public void minusAmount(Long amount) {
        this.amount -= amount;
    }

    public void plusAmount(Long amount) {
        this.amount += amount;
    }
}
```

매표소는 판매 및 교환할 티켓과 판매 금액을 가진다. 판매 금액을 더하거나 차감하는 메서드고 구현한다.

```java
public class TicketSeller {
    private TicketOffice ticketOffice;

    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }

    public TicketOffice getTicketOffice() {
        return ticketOffice;
    }
}
```

판매원은 매표소에서 초대장을 티켓으로 교환해주거나 티켓을 판매한다. TicketSeller는 자신이 일하는 ticketOffice를 알고 있어야 한다.

```java
public class Theater {
    private TicketSeller ticketSeller;
    
    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }
    
    public void enter(Audience audience) {
        if(audience.getBag().hasInvitation) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().minusAmount(ticket.getFee());
            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
            audience.getBag().setTicket(ticket);
        }
    }
}
```

- 극장은 관람객의 가방에서 초대장이 있는지 확인한다.
- 초대장이 있다면 티켓을 가방 안에 넣어준다.
- 초대장이 없다면 가방에서 티켓 금액만큼을 차감하고 매표소에 금액을 증가시킨다.
    - 극장은 관람객의 가방 안에 티켓을 넣어준다.
    
## 무엇이 문제인가

모든  소프트웨어 모듈에는 세 가지 목적이 있다.

1. 실행 중에 제대로 동작하는 것
2. 변경을 위해 존재하는 것
3. 코드를 읽는 사람과 의사소통 하는 것
    - 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다.
    
### 예상을 빗나가는 코드

문제는 관람객과 판매원이 극장의 통제를 받는 수동적인 존재라는 것이다. 이해 가능한 코드란 동작이 우리의 예상에서 벗어나지 않는 것이다. 하지만 관람객은 가만히 가방을 헤집도록 바라만 봐야 한다.

또 다른 문제는 코드를 이해하기 전에 세부 내용을 한꺼번에 알아야 한다는 것이다. 극장의 enter()를 이해하려면 Audience, Bag, TicketSeller 등을 알아야 한다.

### 변경에 취약한 코드

예를 들어 관람객이 가방을 든다는 가정이 바뀐다면, Audience에서 Bag을 지울 뿐만 아니라 Bag에 접근하는 Theater의 enter()도 수정해야 한다.

이것은 객체 사이의 의존성 문제다. 의존성은 어떤 객체가 변경될 때 그 객체에 의존하는 다른 객체도 함께 변경될 수 있다.

따라서 필요한 최소한의 의존성을 유지하고 불필요한 의존성을 제거해야 한다. 의존성이 과한 경우 결합도가 높다고 하는데, 결합도를 낮춰 용이한 설계를 해야 한다.