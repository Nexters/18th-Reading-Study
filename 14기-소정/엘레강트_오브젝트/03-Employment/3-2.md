# 정적 메서드를 사용하지 마세요

```java
class WebPage {
    public static String read(String uri) {
        // HTTP 요청을 만들고 문자열로 변환한다.
    }
}

class Main {
    public static void main(String[] args) {
        String html = WebPage.read("http://www.java.com");
    }
}
```

```java
class WebPage {
    private final String uri;

    public String content() {
        // HTTP 요청을 만들고 문자열로 변환한다.
    }
}

class Main {
    public static void main(String[] args) {
        String html = new WebPage("http://www.java.com").content();
    }
}
```

- 정적 메서드보다 객체를 사용하자.

## 객체 vs 컴퓨터 사고

```txt
// 최댓값을 구하라고 명령한다.
int x = Math.max(5, 9);

// x가 5와 9의 최댓값이라는 사실을 정의할 뿐이다. (is a)
Number x = new Max(5, 9);
```

- 컴퓨터는 우리가 제공한 명령어를 순차적으로 실행한다.
    - 문장이 위에서 아래로 흐른다.
- 우리는 CPU에게 할 일을 지시하는 대신 정의해야 한다.
    - 최댓값을 계산하라고 하지 않고 x는 두 수의 최댓값이라고 이야기할 뿐이다.
- 그저 무엇인지만 정의하고 객체가 스스로 필요할 때 상호작용 하도록 제어를 위임해야 한다.

## 명령형 스타일 vs 선언형 스타일

- 명령형은 프로그램의 상태를 변경하는 문장으로 계산 방식을 서술한다.
    - 연산을 차례대로 실행한다.
- 선언형은 제어 흐름을 서술하는 대신 계산 로직을 표현한다.
    - 엔티티 사이의 관계로 구성된다.

최댓값을 구할 때 정적 메서드든 객체든 어디선가는 `if (a > b)`를 써야한다. 하지만 이 기능을 사용하는 방법에 차이가 있다.

```java
public class Math {
    public static int between(int l, int r, int x) {
        return Math.min(Math.max(l, x), r);
    }
}

public class Main {
    public static void main(String[] args) {
        int y = Math.between(5, 9, 13);
    }
}
```

새로운 기능을 추가하고 싶으면 또 다른 정적 메서드 between()을 추가해야만 한다. 사용하는 쪽에서는 between()를 호출하자마자 값을 반환받는다.

```java
class Between implements Number {
    private final Number num;

    Between(Number left, Number right, Number x) {
        this.num = new Min(new Max(left, x), right);
    }

    @Override
    public int intValue() {
        return this.num.intValue();
    }
}

class Main {
    public static void main(String[] args) {
        // 아직 결과가 나오지 않았다.
        Number y = new Between(5, 9, 13);
    }
}
```

컴퓨터에게 between을 계산해달라고 말하지 않고 between이 무엇인지만 정의한 선언형 스타일이다.

- 선언형은 더 빠르다.
    - 직접 성능 최적화를 제어할 수 있다.
    - 인스턴스 생성은 정적 메서드보다 오래 걸리지만 오직 하나의 정적 메서드만 호출할 때 적용된다.
        - 그 값이 정적 메서드 호출 뒤의 로직에서 필요하지 않아도 무조건 값을 계산하기 때문이다.

```java
class Between implements Number {
    private final Number num;

    Between(Number left, Number right, Number x) {
        this(new Min(new Max(left, x), right));
    }

    // 새로운 ctor
    Between(Number number) {
        this.num = number;
    }
}

class Main {
    public static void main(String[] args) {
        Integer x = new Between(new IntegerWithNewAlgorithms(5, 9, 13));
    }
}
```

- 선언형 방식은 다형성을 활용할 수 있다.
- 즉, 코드 사이의 의존성을 끊을 수 있다.
- 객체를 다른 객체로부터 완전히 분리하려면 메서드나 주 ctor에서 new 연산자를 사용하면 안된다.

만약 새로운 알고리즘으로 between을 판단해야 한다면 between이 Min, Max를 사용하지 않도록 분리할 수 있다.

```java
class Number {
    public static void main(String[] args) {
        Collection<Integer> evens = new LinkedList<>();

        // 코드를 이해하려면 컴퓨터가 계산하듯 루프를 따라 실행 경로를 추적해야 한다.
        for (int number : numbers) {
            if (number % 2 == 0) {
                evens.add(number);
            }
        }
    }
}
```

```java
class Number {
    public static void main(String[] args) {
        // evens는 짝수를 포함하는 필터링된 컬렉션이라고 선언한다. 
        // 이 컬렉션을 어떻게 생성하는지는 모른다.
        // 구현은 감추고 오직 행동만 표현된다.
        Collection<Integer> evens = new Filtered(numbers, {number -> number % 2 == 0});
    }
}
```

- 결과를 예상하려면 머리 속에서 코드를 실행해야 하는 명령형이 덜 직관적이다.
- 선언형은 결과를 이야기하기 때문에 직관적이다.
- evens를 한 줄에 선언했기 때문에 계산을 책임지는 코드를 분리할 수 없어 응집도가 높다.
    - 시간적인 결합 문제를 해결할 수 있다.

```java
class FileLines implements Iterable<String> {
    private final File file;

    public Iterator<String> iterator() {
        return Arrays.asList(FileUtils.readLines).iterator();
    }
}
```

- 정적 메서드가 보이면 클래스로 감싸 고립시킨 뒤 점진적으로 제거한다.

객체와 정적 메서드를 혼용하면 안된다. 절대 명령형을 사용하면 안된다. 명령형을 쓰기 시작하면 코드 전체가 따라가게 된다.

## 유틸리티 클래스