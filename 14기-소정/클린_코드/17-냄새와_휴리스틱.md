# 냄새와 휴리스틱

## 주석

### 부적절한 정보

- 변경 이력 등 다른 시스템에 저장할 수 있는 내용을 남기지 않는다.
- 기술적인 설명을 부연하는 수단으로만 사용한다.

### 쓸모 없는 주석

- 오래되거나 잘못된 주석은 쓸모없다.

### 중복된 주석

- 코드만으로 충분하넫 구구절절 설명하는 주석

### 성의 없는 주석

- 주절대거나 당연한 소리를 반복하지 않는다.
- 단어를 신중히 선택한다.

### 주석 처리된 코드

- 그냥 즉각 지우자.

## 환경

### 여러 단계로 빌드

- 빌드는 한 단계로 끝내야 한다.
    - JAR, XML 등 온갖 파일을 찾느라 뒤적거리지 않아야 한다.

### 여러 단계로 테스트

- 모든 단위 테스트는 한 명령으로 돌려야 한다.

## 함수

### 너무 많은 인수

- 함수에서 인수는 아예 없거나 작을 수록 좋다.

### 출력 인수

- 일반적으로 인수는 출력이 아니라 입력으로 간주된다.
- 함수에서 뭔가의 상태를 변경해야 한다면 출력 인수 대신 함수가 속한 객체의 상태를 변경한다.

### 플래그 인수

- 함수가 여러 기능을 수행한다는 명백한 증거이므로 피한다.

### 죽은 함수

- 아무도 호출하지 않는 함수는 삭제한다.

## 일반

### 한 소스 파일에 여러 언어를 사용한다

- 소스 파일 하나에 언어 하나만 사용하는 방식이 가장 좋다.

### 당연한 동작을 구현하지 않는다.

- 함수나 클래스는 프로그래머가 당연하게 여길만한 동작과 기능을 제공해야 한다.

### 경계를 올바로 처리하지 않는다

- 모든 경계와 구석진 곳에서 코드를 증명하는 테스트 코드를 작성한다.

### 안전 절차 무시

- 컴파일러 경고를 꺼버리면 빌드는 쉬워지지만 위험하다.

### 중복

- 중복은 추상화할 기회다.
    - 하위 루틴이나 다른 클래스로 분리한다.
    - 추상화로 중복을 없애면 설계 언어의 어휘가 늘어난다.
- 복사한 듯한 코드는 간단한 함수로 교체한다.
- 조건문으로 똑같은 조건을 거듭 확인하는 중복은 다형성으로 대체한다.
- 알고리즘이 유사하나 코드가 서로 다른 중복은 템플릿 메서드, 전략 패턴으로 대체한다.

### 추상화 수준이 올바르지 못하다

- 모든 저차원 개념은 파생 클래스에, 모든 고차원 개념은 기초 클래스에 넣는다.

### 기초 클래스가 파생 클래스에 의존한다

- 기초 클래스는 파생 클래스를 아예 몰라야 한다.

### 과도한 정보

- 잘 정의된 인터페이스는 많은 함수를 제공하지 않는다.
- 매우 작게, 그리고 깐깐하게 만들어 정보를 제한하고 결합도를 낮춘다.

### 죽은 코드

- 실행되지 않는 코드는 제거하라.

### 수직 분리

- 변수와 함수는 사용되는 위치에 가깝게 정의한다.
- 지역 변수는 처음 사용하기 직전에 선언한다.
- private 함수는 처음 호출한 직후에 정의한다.

### 일관성 부족

- 변수 이름을 지었으면 다른 함수에서도 일관성있게 동일한 이름을 사용한다.

### 잡동사니

- 사용하지 않거나, 아무도 호출하지 않거나, 정보를 제공하지 않는 코드는 없앤다.

### 인위적 결합

- 무관한 개념을 결합하지 않는다.
    - enum이나 범용 static 함수를 특정 클래스에 속하게 하지 마라.
    - 상호작용이 없는 코드를 알아야 하는 상황이 된다.
- 당장 편하자고 넣어버린 게으른 행동이다.

### 기능 욕심

- 클래스 메서드는 다른 클래스 변수와 함수에 고나심을 가져서는 안된다.
- 다른 객체의 참조자와 변경자를 사용한다면 범위를 욕심낸 것이다.

### 선택자 인수

- 인수를 넘겨서 동작을 선택하는 대신 함수를 쪼개서 새롭게 만드는 것이 좋다.

### 모호한 의도

- 코드에 의도를 최대한 표현한다.

### 잘못 지운 책임

- 독자가 자연스럽게 기대할 위치에 코드를 배치한다.
- 꼭 다른 곳에 해야할 이유가 있다면 그 사실을 반영한 함수 이름을 짓는다.

### 부적절한 static 함수

- static 메서드는 메서드를 소유하는 객체에서 정보를 가져오거나 메서드를 재정의할 일이 없을 때만 사용한다.
- 일반적으로 static 보다 일반 함수가 좋다.

### 서술적 변수

- 가독성을 높일 수 있는 방법이다.

### 이름과 기능이 일치하는 함수

- 이름만으로 분명히 알 수 없다면 이름을 바꿔야 한다.

```java
Date newDate=date.add(5);
```

- 더하는 것이 날짜인지 달인지 알 수 없다.

### 알고리즘을 이해하라

- 작성자가 알고리즘을 정확히 이해해야 한다.
- 단지 돌아간다는 이유로 만족하면 안된다.

### 논리적인 의존성은 물리적으로 드러내라

- 의존하는 모듈이 상대 모듈에 대해 뭔가를 가정하면 안된다.
- ex) pageSize는 reporter가 아니라 formatter에서 의존해야 한다.

### 조건문보다 다형성을 사용하라

- 손 쉽게 switch를 쓰려고 하지 말고 다형성을 먼저 고려해라.

[냄새 나는 Switch 코드와 다형성](https://www.whiteship.me/-eb-83-84-ec-83-88--eb-82-98-eb-8a-94-switch--ec-bd-94-eb-93-9c-ec-99-80--eb-8b-a4-ed-98-95-ec-84-b1/)

### 표준 표기법을 따르라

- 업계 표준에 기반한 구현 표준을 따라야 한다.

### 매직 숫자는 명명된 상수로 교체하라

- 일반적으로 코드에서 숫자를 사용하지 않는다.

### 정확하라

- 코드에 대한 결정을 내릴 때는 이유와 예외 처리 방법을 분명히 알고 한다.
    - ex) 모든 변수를 protected로 선언하는 코드는 무절제하다.

### 관례보다 구조를 사용하라

- 명명 관례보다는 구조 자체로 강제하는 게 더 좋다.
    - ex) enum을 사용하는 switch보다 추상 메서드가 좋다.

### 조건을 캡슐화하라

- 조건의 의도를 분명히 밝히는 함수로 표현하라

```java
if(shouldBeDeleted(timer))
```

보다는

```java
if(timer.hasExpired()&&!timer.isRecurrent())
```

가 좋다.

### 부정 조건은 피하라

- 부정 조건은 이해하기 어렵다.

### 함수는 한 가지만 해야 한다

- 한 가지만 수행하는 더 작은 함수 여럿으로 나눈다.

### 숨겨진 시간적인 결합

- 호출 순서가 중요한 코드는 연결 소자로 결합을 노출한다.

```java
public class Example {
    public void dive(String reason) {
        saturateGradient();
        reticulateSplines();
        diveForMoog(reason);
    }
}
```

순서를 실수로 바꾸면 오류가 발생한다.

```java
public class Example {
    public void dive(String reason) {
        Gradient gradient = saturageGradient();
        List<Spline> splines = reticulateSplines(gradient);
        diveForMoog(Splines, reason);
    }
}
```

복잡해지지만 의도적으로 시간 복잡성을 드러낸다.

### 일관성을 유지하라

- 코드 구조를 잡을 때 이유를 고민하고 이유를 코드로 명백히 표현하라.

### 경계 조건을 캡슐화하라

- 경계 조건은 코드 여기저기에 흩어놓지 않고 한 곳에서 별도로 처리한다.

### 함수는 추상화 수준을 한 단계만 내려가야 한다.

- 함수 내 모든 문장은 추상화 수준이 동일해야 한다.
- 추상화 수준은 함수 이름이 의미하는 작업보다 한 단계만 낮아야 한다.

### 설정 정보는 최상위 단계에 둬라

- 기본값이나 설정 관련 상수를 저차원 함수에 숨기면 안된다.

### 추이적 탐색을 피하라

- A가 B를 사용하고 B가 C를 사용해도 A는 C를 알 필요가 없다.
    - a.getB().getC()는 바람직하지 않다.
    - B와 C 사이에 무언갈 넣기도 어렵다.

## 자바

### 긴 import 목록을 피하고 와일드 카드를 사용하라

- 긴 import 목록은 부담스럽다.
- `import pakcage.*`로 간단히 명시한다.

### 상수는 상속하지 않는다

- 자식 클래스에서 저 멀리 부모에 있는 상수를 사용하면 찾기 힘들다.
- 써야 한다면 static import를 한다.

### 상수 대 Enum

- enum은 메서드와 필드를 사용할 수 있어 더 유연하다.

## 이름

### 서술적인 이름을 사용하라

- 선택한 이름이 적합한지 신중하게 생가한다.
- 가독성은 이름이 90%를 결정한다.

### 적절한 추상화 수준에서 이름을 선택하라

- 구현을 드러내는 이름을 피한다.
- 적절한 추상화 수준을 반영하도록 노력해야 한다.

```java
public interface Modem {
    boolean dial(String phoneNumber);
}
```

전화가 아닌 전용선을 사용하는 모뎀은 위 인터페이스를 사용하기엔 부적절하다. 즉, 전화번호라는 추상화 수준이 틀렸다.

```java
public interface Modem {
    boolean connect(String connectionLocator);
}
```

더 좋은 전략은 위와 같다.

### 가능하다면 표준 명명법을 사용하라

- 기존 명명법을 사용하면 이해하기 쉽다.
    - 데코레이터 패턴이라면 테코레이터 단어를 사용한다.
- 팀에서 부르는 유비쿼터스 언어를 열심히 사용한다.

### 명확한 이름

- 함수나 변수의 목적을 명확히 하는 이름을 선택한다.

### 긴 범위는 긴 이름을 사용하라

- 범위가 작으면 짧은 이름을 사용해도 된다.
    - 5줄 이내라면 i나 j도 괜찮다.

### 인코딩을 피하라

- 이름에 유형이나 범위 정보를 넣지 말자.
- `m_` 등 불필요한 접두사를 쓰지 말자.

### 이름으로 부수 효과를 설명하라

- 여러 작업을 수행하는 함수에 동사 하나만 달랑 사용하지 말자.

```java
public class Oos {
  public OutputStream getOos() {
    if (m_oos == null) {
      m_oos = new OutPutStream();
    }
    return m_oos;
  }
}
```

위 함수는 단순이 oos만 가져오는 게 아니라 없을 때 생성도 한다.

```java
public class Oos {
  public OutputStream createOrReturnOos() {
    if (m_oos == null) {
      m_oos = new OutPutStream();
    }
    return m_oos;
  }
}
```

위의 이름이 더 좋다.

## 테스트

### 불충분한 테스트

- 잠재적으로 꺠질 만한 부분을 모두 테스트 한다.

### 커버리지 도구를 사용하라

- 테스트가 빠뜨리는 공백을 알려준다.

### 사소한 테스트를 건너뛰지 마라

- 사소한 테스트가 제공하는 문서적 가치는 크다.

### 무시한 테스트는 모호함을 뜻한다

- 요구사항이 불분명하고 돌아가는 방식을 확신하기 어려우면 주석으로 처리하거나 @Ignore를 붙여 표현한다.
- 컴파일 가능 여부에 따라 선택하면 된다.

### 경계 조건을 테스트하라

- 경계 조건을 각별히 신경써서 테스트한다.

### 버그 주변은 철저히 테스트하라

- 버그는 서로 모이는 경향이 있다.
- 한 함수에 버그가 있다면 다른 버그도 발견할 확률이 높다.

### 실패 패턴을 살펴라

- 실패하는 패턴으로 문제를 진단할 수도 있다.
- ex) 입력이 5자를 넘기는 테스트 케이스 모두 실패

### 테스트 커버리지 패턴을 살펴라

- 통과하는 테스트가 실행하거나 실행하지 않는 코드로 실패하는 테스트의 원인을 알 수 있다.

### 테스트는 빨라야 한다

- 느린 테스트는 실행하지 않게 된다.