백그라운드 스레드를 적절히 사용하는 것 : 앱 성능을 향상하는 데 많은 도움이 됨

# 3.1 HandlerThread 클래스

Thread 를 상속

내부에서 Looper.`prepare()` 와 Looper.`loop()` 를 실행하는 Looper Thread

Handler 를 가진 Thread 로 오해할 수 있지만 그렇지 않음

`Looper 를 가진 Thread` 이면서, `Handler 에서 사용`하기 위한 Thread

Handler 의 3번째 생성자를 활용함 (Handler(`Looper looper`))

Looper.loop 이후에 quit 를 넣더라도 도달하지 않음 (unreachable)

→ Looper.loop() 만 돌고 있는 백그라운드 스레드를 따로 두어 Message 도 여기서 처리하도록 만듬

→ 명시적으로 종료를 요청할 시 종료되도록 만듬

Handler 를 Looper 에 연결하는 방법

1. Handler 를 Thread 에 두고 사용하는 방식

    ```java
    class AbcdThread extends Thread{
    	Handler handler = Handler();

    	...
    }
    ```

2. Thread 에서 Looper 를 시작하고 Thread 외부에서 Handler 를 생성하는 방식

    내부적으로 prepare(), loop() 를 실행하는 것 외에 별 다른 내용은 없음

    ```java
    private HandlerTHread handlerThread;

    public Processor(){
    	handlerThread = new HandlerThread("Message Thread");
    	handlerThread.start();
    }

    public void process() {
    	new Handler(handlerThread.getLooper()).post(new Runnable(){
    		@Override
    		public void run(){
    			// ...
    		}
    	}
    }
    ```

    Handler 에 Looper 를 전달 (`handlerThread.getLooper()`)

    HandlerThread 에서 생성한 스레드에서 Handler 에서 보낸 Message 가 처리됨

## HandlerThread 프레임워크 소스

```java
public class HandlerThread extends Thread {
	Looper mLooper;

	public void run() {
		Looper.prepare();
		synchronized (this) {
			mLooper = Looper.myLooper();    // 1
			notifyAll();    // 2
		}
		Looper.loop()
	}

	public Looper getLooper() {
		if(!isAlive()) {    // 3
			return null;
		}
		synchronized (this) {
			while(isAlive() && mLooper == null) {    // 4
				try {
					wait();    // 5
				} catch(InterruptedException e){
				}
			}
		}
		return mLooper;
	}

	public boolean quit(){
		Looper looper = getLooper();
		if(looper != null){
			looper.quit();
			return true;
		}
		return false
	}
}
```

mLooper 에 Looper.myLooper() 를 대입 (1)

getLooper() 메서드나 quit() 메서드에서 mLooper 를 직접 사용하지 않음

→ getLooper() 에서 return mLooper; 한줄로 끝나지 않음

→ quit() 에서 getLooper() 메서드를 거침

getLooper() 메서드는 공개적으로 외부에서도 활용될 때도 있음

→ ex. handlerThread.getLooper()

Thread 를 상속한 HandlerThread 에서 start 를 호출했는지 체크 (3)

- HandlerThread 사용 시 getLooper 를 호출 전 반드시 start() 호출할 것
- isAlive : 스레드가 start() 메서드로 시작되어 아직 종료되지 않았을 시, false 리턴

mLooper 가 null 인지 체크 (4)

- start() 를 호출하고 스레드에서 run() 메서드가 실행되는 시점은 명확히 알 수 없음

    → getLooper() 에서 run 메서드 내에서 mLooper 를 대입하는 시점까지 대기하기 위해 이를 체크

- mLooper 는 대입되고 난 후에는, getLooper() 메서드 외에는 다른 곳에 쓰이지 않음

wait() 메서드로 대기 (5)

- (2) 과정에서 mLooper 대입 이후, notifyAll() 을 실행해 대기하는 스레드를 깨움

### 순차 작업에 HandlerThread 적용

단일 스레드에서 순차 작업이 필요할 시 HandlerThread 를 사용하면 유용
```
IntentService 가 HandlerThread 를 내부적으로 사용함
```
ex. CheckBox 클릭 후 서버에 반영

→ 이를 쓰레드로 처리할 시 비동기로 인한 예상치 못한 오류 발견 가능

     (이 내용 이외에도 우리는 이 케이스를 마주할 수 있는 방법이 평소에 많다)

HandlerThread 로 순차 처리 가능

사용하지 않는다면 백그라운드 스레드에서 무한 반복문을 만들고
BlockingQueue 를 매개로 하여 반복문에서 가져오기를 실행 (take)
Thread 외부에서 넣기를 실행 (put)

```java
예제 코드
```

1. HandlerThread 시작 (HandlerThread 는 Thread 를 상속한 것)

    ```java
    handlerThread.start()
    ```

2. HandlerThread 에서 만든 Looper 를 Handler 생성자에 전달

    ```java
    favoriteHandler = new Handler(handlerThread.getLooper())
    ```

3. 체크박스를 선택 / 해제할 때마다 Handler 에 Message 보냄

    ```java
    @Override
    public void handleMessage(Message msg){
    	//...
    }
    ```

4. Message 를 받아 DB 에 반영

    ```java
    favoriteHandler.sendMessage(message);
    ```

5. HandlerThread 의 quit 메서드는 Looper.quit() 를 실행해 Looper 종료

    ```java
    handlerThread.quit()
    ```

3.2 스레드 풀 사용

3.2.1 ThreadPoolExecutor 클래스

3.2.2 ScheduledThreadPoolExecutor 클래스

3.2.3 Executors 클래스

3.3 AsyncTask 클래스

3.3.1 백그라운드 스레드와 UI 스레드 구분

3.3.2 액티비티 종료 시점과 불일치

3.3.3 AsyncTask 취소

3.3.4 예외 처리 메서드 없음

3.3.5 병렬 실행 시 doInBackground() 실행 순서가 보장되지 않음
