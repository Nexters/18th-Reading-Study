# Activity

화면의 기본단위이면서 가장 많이 사용되는 컴포넌트이다.

**액티비티 특징1. 액티비티는 필요한 만큼만 생성하기**

`AndroidManifest.xml`에 선언하고 설정 파일에 액티비티를 추가하면 된다.

 관리차원을 생각하면 많이 만드는 건 좋지 않다.

독립적인 화면이라면 액티비티가 더 적합하고, 종속적인 화면으로 보인다면 다른 것을 사용하면 된다.

1. 내부에 UI 액션이나 비즈니스 로직이 많다면 액티비티 고려하기
2. 팝업 형태라면 DialogFragment, PopupWindow 로 대체하기

**액티비티 특징2. setContentView 를 강제할 필요가 없음**

setContentView 가 없다면 UI 가 없는 액티비티

로직에 따라 다른 액티비티를 띄우도록 사용하기도 한다.

ex. Intent scheme 에 따라 다른 화면으로 전환하는 경우, 여러 액티비티에 intent-filter 를 추가하지 않고 
관문 역할의 액티비티 1개에만 여러 scheme 의 intent filter 를 추가하기도 한다.

```kotlin
<activity
	android:name=".activity.splash.SplashActivity"
	...
	tools:targetApi="n">

	<intent-filter>
	    <action android:name="android.intent.action.VIEW" />
	    <category android:name="android.intent.category.DEFAULT" />
	    <data android:scheme="doc" />
	    <data android:scheme="xls" />
	    <data android:scheme="ppt" />
	</intent-filter>
</activity>
```

= doc, xls, ppt 스킴이 전달될 시, SplashActivity 에서 처리하겠다

```kotlin
// SplashActivity.kt

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    
    when(intent?.data?.scheme){
        null -> Toast.makeText(this, "Uri does not exist", Toast.LENGTH_SHORT).show()
        "doc" -> startActivity(Intent(this, WordActivity::class.java))
        "xls" -> startActivity(Intent(this, ExcelActivity::class.java))
        "ppt" -> startActivity(Intent(this, PowerPointActivity::class.java))
        else -> Toast.makeText(this, "Uri is invalid", Toast.LENGTH_SHORT).show()
    }
}
```

# 5.1 생명주기

생명주기를 이해하지 못했을 때 리소스가 반납되지 않을 수도 있고, 필요한 데이터를 읽어들이지 못할 수도 있다.

(당연한 소리... 이거 모르면 개발자 때려쳐야 읍읍)

## 5.1.1 액티비티 생명주기 다이어그램

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cc83115c-8992-4093-bd9b-f06bc2f3a1d0/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cc83115c-8992-4093-bd9b-f06bc2f3a1d0/Untitled.png)

복습한다는 느낌으로 보니 새롭다.

### 다른 액티비티에 가리는 경우

일부분만 가리면 onPause, 전체를 가리면 onStop 까지 불림

전면 액티비티가 종료되어 돌아오면 일부분만 가렸을 경우 onResume, 전체를 가렸을 경우 onStart 가 불림

### 우선 순위가 더 높은 앱이 메모리를 확보

우선순위가 더 높은 앱을 실행해야하는데 메모리가 부족하다면 
OS는 우선순위가 비교적 낮은 앱을 언제든 종료시킬 수 있다.

이는 onPause() 단계 부터 해당되므로, 상황에 따라 `onStop()`, `onDestroy()`가 실행되지 않을 수 있다.

리소스를 안전하게 정리하는 게 필요할 경우 onStop(), onDestroy() 에 안전장치로 코드를 추가하기도 한다.

### 시스템에 의한 액티비티 제거

onDestroy() 는 아래의 경우 실행된다.

1. 사용자가 액티비티를 완전히 닫거나(뒤로 버튼을 누른 경우) `finish()`가 호출되는 경우
2. configuration 변경(ex 기기 회전, 멀티 윈도우 모드)으로 인해 
시스템이 일시적으로 액티비티를 소멸시키는 경우

메모리 부족 시 OutOfMemoryError 발생 전 액티비티를 제거하여 메모리 문제 가능성을 없애버릴 경우도 있다.

가용 메모리의 3/4 가 넘을 경우 백그라운드 테스크 앱을 종료시킨다.

## 5.1.2 생명주기 메서드 호출 시점

메서드가 어디까지 호출되는지는 `액티비티 화면 보임`(visibility) 여부, `포그라운드 여부`로 체크할 수 있다.

화면이 일부 보이지만 백그라운드 상태라면 onPause 까지만 실행된다. (전체를 가리면 onStop 까지 실행된다)

기타 시나리오는 아래 내용을 참고

1. **시작할 때**

    onCreate -> onStart -> onResume

2. **기기 회전할 때**

    onPause -> onStop -> onDestroy -> onCreate -> onStart -> onResume

3. **다른 액티비티가 위에 뜰 때 / 잠금 버튼으로 기기 화면을 끌 때 / 홈 키를 눌렀을 때**

    onPause -> onStop()

4. **백 키로 액티비티 종료**

    onPause -> onStop -> onDestroy

5. **백 키로 이전 액티비티로 돌아갈 때 / 잠금 화면을 풀고 액티비티로 돌아왔을 때 / 홈화면에서 돌아왔을 때**

    onRestart -> onStart -> onResume

6. **다이얼로그 테마 액티비티나 투명 액티비티가 위에 뜰 때**

    onPause

### 액티비티 lifeTime

~ 의 공간이 각 항목에 해당하는 lifeTime 이다.

1. 전체 : onCreate() `<` ~ `<` onDestroy()
2. 가시성(visibility) :  onStart() `<` ~ `<` onStop()
3. 포그라운드 (foreground) : onResume() `<` ~ `<` onPause()

Q. setContentView()에 전달된 레이아웃은 가시 lifeTime 시작인 onStart()에서 처리하는 것일까?

A . Nope

onCreate() 부터 onResume() 까지는 하나의 Message에서 처리하므로 
setContentView()의 결과는 `onResume() 이후`에 보인다. 

onStart() 부터 가시 라이프타임이라는 것은 
액티비티가 화면에 보이지 않다가, 다시 보일 때는 `로직상!!!` 여기부터 실행된다는 의미이다.

### 추가로 생명주기 메서드가 불리는 시점 확인

1. onCreate 에서 finish() 를 호출하면 다른 생명주기 메서드를 거치지 않고 onDestroy() 를 실행한다.
2. onActivityResult() 는 onResume() 보다 먼저 실행된다.

    (실행 순서에 유의하자. 특히 코루틴 등을 사용해서 onActivityResult 를 유야무야하게 만드는 경우!)

## 5.1.3 액티비티 시작 메서드

### 호출자와 피호출자

TabActivity 인 경우, getParent() 를 호출하면, 자신을 포함한 액티비티를 가리킨다. 
(자신을 시작시킨 액티비티를 가리키는 것이 아니다.)

위와 같은 혼란을 막기 위해 아래와 같이 명명한다.

A→B 에서 A 는 호출자(caller), B는 피호출자 (callee)

### 액티비티를 시작하는 메서드

startActivity(), startActivityForResult() 로 호출

startActivity() 는 Context 의 메서드, startActivityForResult() 는 Activity 의 메서드

startActivity() 는 단방향 통신 (→), startActivityForResult() 는 양방향 통신 (↔ )

→  startActivity() 호출 시, 피호출자에서 getCallingActivity(), getCallingPackage() 실행 시 null 반환

getCallingActivity(), getCallingPackage() : 호출자의 정보를 리턴

**startActivityForResult()**

1. 호출자에 따라 다르게 처리할 필요가 있을 경우
startActivityForResult() requestCode 파라미터에 0 이상 값을 넣는다
2. 호출자, 피호출자가 다른 테스크에 속해 있다면
onActivityResult() 에서 결과를 받을 수 없다.
3. setResult() 메서드는 finish() 전에 호출해야 한다. (놓치기 쉬운 실수이다.)

    그래야만 resultCode, data 가 호출자에게 전달된다.

4. resultCode 는 RESULT_OK, RESULT_CANCELED(`0`) 를 주로 사용한다.

    setResult() 를 호출하지 않으면 기본 값은 RESULT_CANCELED(`0`) 이다.

5. Intent.FLAG_ACTIVITY_FORWARD_RESULT

    A → B 상태에서 B 종료 후 A → C 형태가 가능할까? 이건 일단 가능하다

    C 에서 setResult() 한 데이터를 A 로 전달할 수 있을까? 이건 불가능하다. 
    (정확히는 onActivityResult() 는 호출되지만 setResult() 에서 설정한 데이터는 받을 수 없다.)

    이 값을 전달받으려면, B 에서 `startActivity()!!!` 를 시작하면서 Intent 내에 Intent.`FLAG_ACTIVITY_FORWARD_RESULT` 플래그를 추가해야 한다.

    startActivityForResult() 에서는 예외(Crash)가 발생한다.

    ```kotlin
    android.util.AndroidRuntimeException: 
    FORWARD_RESULT_FLAG used while also requesting a result
    ```

## 5.1.4 액티비티 전환 시 생명주기 메서드 호출

### 1. 액티비티에서 다른 액티비티를 시작할 때 (A → B)

A 액티비티 : onPause(), onStop() 실행

B 액티비티 : onCreate(), onStart(), onResume() 실행

그런데 이상하다. 왜 아래와 같이 onStop() 이 나중에 호출될까?

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a6fb3938-b4c2-4497-9919-ef0e6733daf3/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a6fb3938-b4c2-4497-9919-ef0e6733daf3/Untitled.png)

아직은 호출된 액티비티가 일부만 가리는지, 투명한지 알 수 없기 때문이다.

데이터를 연동하는 과정이 있다면, onStop()이 아니라 onPause()에서 저장하고 넘기는 걸 추천한다.
적어도 onPause() 는 두가지 케이스에 모두 실행되니까!

ex. A 에서 변경한 값을 B 에서도 사용할 때, onStop() 에서 변경하면 안되고 onPause() 에 저장해야 한다.

### 2. 포그라운드에서 액티비티가 닫힐 때 (B → A)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6f756f0f-0dc9-41d6-90cc-133e85c8d236/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6f756f0f-0dc9-41d6-90cc-133e85c8d236/Untitled.png)

이 경우도 [1번](https://www.notion.so/5-632c954a8bd3486fbf8c9a55c8fcf9e6)과 마찬가지로 onStop(), onDestroy() 가 나중에 실행된다.

## 5.1.5 생명주기 메서드 사용 시 주의사항

### 1. 리소스 생성 및 제거는 대칭적으로 실행하기

ex. onCreate()에서 리소스를 생성했다면 onDestroy()에서 제거

onResume()에서 생성했다면 onPause()에서 제거

### 2. 생명주기 함수를 override 해서 사용하는 경우, super.onXxx() 호출을 나중에 하기

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7c11b27d-98a2-44a8-a94c-abc41fe15c95/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7c11b27d-98a2-44a8-a94c-abc41fe15c95/Untitled.png)

[Effective Aandroid](http://orhanobut.github.io/effective-android/) 에서도 볼 수 있다.

```kotlin
@Override
public void onCreate(
	Bundle savedInstanceState
) {
    super.onCreate(savedInstanceState)
    ...  // 기타 로직
}

@Override
public void onDestroy() {
    ...  // 기타 로직
    super.onDestroy()
}
```

### 3. 생명주기 함수 내에서 finish() 메서드를 호출한 후에는 반환하기

finish() 는 단순히 화면을 종료하라는 신호만 보내는 것이므로 아래와 같이 사이드 이펙트가 생길 수 있다.

```kotlin
@Override
public void Create(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    address = getIntent().getPacelableExtra(EXTRA_DATA_ADDRESS);
    if (address == null) {
        Log.d(TAG, "Address not exist.");
        finish();
        return; //리턴 필요
    }
    //리턴이 없으면 NPE 발생
    Log.d(TAG, "address = " + address.city);
    ...
}
```

### 4. 생명주기 유사 함수 (ex. onXXX()) 는 직접 호출을 하지 말 것

onBackPressed() 를 재정의하면서 우리는 많이 겪었다. (영향이 그만큼 많이 가고 생각을 많이 해주어야 한다)

시스템이 알아서 호출하는 메서드는 함부로 엮지 말고 별도 메서드를 만들어서 처리하자!

onActivityResult() 를 직접 호출하는 사람도 있다더라...

# 5.2 구성 변경

## 구성(Configuration)

컴포넌트에서 어떤 리소스를 사용할지 결정하는 조건

프레임워크에서 따로 정해져 있음

화면 방향(orientation) 이 구성의 가장 대표적인 항목

구성 항목들은 `android.content.res.Configuration` 에서 확인 가능

- densityDpi, fontScale, hardKeyboardHidden, keyboard, keyboardHidden
- locale, mcc, mnc, navigation, navigationHidden, orientation
- screehHeightDP, screenLayout, screenWidthDp
- smallestScreenWidthDp, touchScreen, uiMode

fontScale, locale : 단말의 환경 설정에서 정할 수 있는 사용자 옵션이고, 그 이외는 단말의 현재 상태

## 5.2.1 리소스 반영

구성은 컴포넌트에서 사용하는 리소스를 결정한다. → 구성 변경 시 컴포넌트에서 사용하는 `리소스도 변경`된다.

ex. 단말 환경 설정에서 언어 변경 시 

(영어 기본, 한국어 / 일본어 지원)
/res/values, /res/values-ko, /res/values-ja 에 동일한 내용의 문자열을 번역해 strings.xml 을 각각 만듬

한국어 → 일본어
/res/values-ko/strings.xml → /res/values-ja/strings.xml 로 변경해서 보여줌

화면에서 하나씩 문자열을 변경하는 게 아닌 `액티비티를 재시작` 해서 변경된 리소스를 활용함

ex2. 화면 회전

/res/layout-port, /res/layout-land 디렉터리의 레이아웃 교체 시 `액티비티를 재시작`함

액티비티 이외의 다른 컴포넌트는 구성 변경에 민감하게 반응하지 않는다 (`재시작 X`)

## 5.2.2 구성 변경으로 인한 액티비티 재시작

인스턴스 초기화는 하지 않는다.

기존 인스턴스를 onDestroy()까지 실행한 후, 완전히 새로운 인스턴스를 생성해 onCreate() 부터 시작한다.

### 메모리 누수 가능성

onDestory()가 실행되었지만, 기존 액티비티 인스턴스에 대한 참조가 남을 시, 
GC되지 않고 메모리를 계속 차지한다.

화면을 회전할 때 자꾸 OutOfMemoryError가 발생한다면 원인은 메모리 누수 때문이다.

**case 1. Activity 목록 참조**

Activity 인스턴스를 따로 조작하는 행위는 되도록 피해야 한다. WeakReference 를 사용하더라도 피해야 한다.
ex. 떠 있는 액티비티의 특별한 작업을 위해 특정 collection 에 activity 들을 모아두기

액티비티 목록은 시스템이 알아서 관리하는 영역이기도 하고, 실수할 경우 문제가 발생할 수 있다.

**case 2. 액티비티의 내부 클래스나 익명 클래스 인스턴스**

activity 내부 클래스, 익명 클래스의 인스턴스가 activity 의 참조를 갖고 있다면 
이들 인스턴스를 외부의 리스너로 등록한 경우에 해제도 반드시 해야 한다.

해제를 하지 않는 실수는 메모리 누수로 이어진다.

ex. SomeActivity.this 를 쓸 수 있는 상황이면 액티비티에 대한 참조를 갖고 있는 것

해결책으로 단순 내부 클래스라면, 정적 내부 클래스를 만들어 생성자에 WeekReference로 
액티비티를 전달하는 방법을 사용하여 문제를 예방할 수 있다 (코드는 복잡해진다)

**case 3. 싱글턴에서 액티비티 참조**

싱글턴에 Context가 전달되어야 하는데 Activity 자신을 전달한 경우에 메모리 누수가 발생할 수 있다. 

ex. onCreate() 에서 AsyncTask 시작 시, AsyncTask 에서 activity 를 참조하고 있기 때문에 
      activity 는 GC 대상이 되지 않음!!

이로 인해 화면 회전 시 asyncTask 가 중단되지 않고 계속 실행되고, 
전환하면서 실행되는 onCreate 에 의해 또 실행됨

## 5.2.3 프레임워크 소스 확인

구성 변경 시 ActivityManagerService 에서 앱 프로세스의 메인 클래스인 ActivityThread에 새로운 Configuration 을 전달한다.

결과적으로 AssertManager의 네이티브 메서드(C로 작성된)인 setConfiguration()을 실행하는 것이다.

네이티브에서는 리소스 테이블을 유지하고 있는데, 현재 Configuration에 맞는 리소스를 선택해서 가져온다.

### 리소스 선택 로직

ex. getText()

```kotlin
Resources.getText(int id)
	AssetManager.getResourceText(int ident)
		AssetManager.loadResourceValue(int ident, short density, TypedValue outValue, boolean resolve)
```

loadResourceValue 는 네이티브 코드

AssetManager 를 거쳐 Configuration 에 맞는 리소스를 매번 선택해서 가져옴

ex2. 구성 업데이트

```
// 현재 사용 가능한 리소스

drawable/
drawable-en/
drawable-fr-rCA/
drawable-en-port/
drawable-en-notouch-12key/
drawable-port-ldpi/
drawable-port-notouch-12key/
```

```kotlin
현재 단말의 구성

Locale = en-GB
Screen orientation = port
Screen pixel density = hdpi
Touchscreen type = notouch
Primary text input method = 12key
```

1. 먼저 현재 구성에 맞는 리소스를 선택
2. 그 다음 우선순위를 가지는 한정자를 비교해 현재 구성과 맞지 않는 리소스를 계속 배제
(ex. drawable-fr-rCA/ 배제)
3. 그 외 시스템 자체적으로 구성을 확인하고 절대 선택될 일이 없는 리소스는 
리소스 테이블에 올리지도 않는 등 추가적인 과정이 존재

## 5.2.4 구성 한정자

![image](https://user-images.githubusercontent.com/13694046/121815761-f74a0380-ccb2-11eb-9bf8-346db85c1b30.png)

### 구성 한정자에 대한 알쓸신잡

1. 플랫폼 버전도 리소스 선택에 영향을 주지만 `Configuration` 멤버 변수에는 플랫폼 버전 값이 없다. 

    이는 숨겨진 멤버 변수인 `Build.VERSION.RESOURCES_SDK_INT`에 상수로 되어 있다.

2. `Configuration`의 멤버 변수 가운데서 `fontScale`은 구성 한정자와 관련된 것이 없다. 

    즉 `fontScale`은 리소스 선택 로직에는 영향을 주지 않고 액티비티를 재시작할 때 
    화면에서 `sp` 단위로 된 문자열의 크기를 변경할 뿐이다.

3. 언어 설정을 아랍어, 히브리어, 페르시아어로 변경하면 RTL(right-to-left)로 레이아웃 방향이 변경된다.

    (`AndroidMenifest.xml`에서 `supportsRtl` 속성이 true이고, `targetSdkVersion`이 17 이상일 때)

## 5.2.5 데이터 복구

구성 변경으로 재시작되어도 사용자 경험상 기존에 보던 화면을 유지해야 한다

ex. ViewPager 에서 플링을 통해 특정 페이지로 이동할 때 액티비티가 재시작해도 동일한 페이지를 보여주려함

onSaveInstanceState() 와 onRestoreInstanceState() 를 사용해 복구한다.

### onSaveInstanceState()

- 생명주기처럼 항상 호출되는 함수가 아님
- 구성 변경으로 재시작할때 뿐만 아니라, 
메모리 문제로 시스템이 액티비티를 강제 종료하는 경우에도 호출된다
- 그렇게 되면 제일 먼저 이 함수가 호출한다.

### onRestoreInstanceState()

→ 여기에 전달되는 bundle 파라미터는 onCreate() 에도 전달되지만 
    대칭을 위해 onRestoreInstanceState() 에서 복구하는 로직을 작성한다.

### targetSdkVersion 에 따른 호출 시점

**onSaveInstanceState() 호출 시점**

- targetSdkVersion 11 미만 : onPause 이전에 호출
- targetSdkVersion 11 이상 : onStop 이전에 호출

**onRestoreInstanceState() 호출 시점**

- onCreate() < `...` < onResume() 이전

### 액티비티 전환 시 onSaveInstanceState() 호출

화면 이동 후 0(A → B) B에서 구성 변경되면, B는 onSaveInstanceState() 가 호출

이미 B로 가기 직전 A에서는 onSaveInstanceState() 가 호출된 상태

백키

A는 다시 그 화면이 포커싱될 때 재시작됨 (이미 onSaveInstanceState() 는 호출되었으므로 호출되지 않음)

다시 원래 화면으로 돌아와서 포커싱될 경우엔 재시작 없음

홈키

B에서 홈키 클릭 시 onSaveInstanceState() 호출

다시 돌아올때 구성 변경이 되었을 경우엔 재시작됨

화면 off

onStop() 까지 실행, 직전 onSaveInstanceState() 를 호출

on 될 경우에 구성 변경 되었을 경우엔 재시작됨

## 5.2.6 android:configChanges 속성

액티비티 선언에서 고정값을 둠

1. android:screenOrientation 속성에 지정해서 화면을 아예 고정하기

    (portrait, landscape)

2. android:configChanges 속성에 orientation 을 추가

    이런 경우 화면 시에 재시작하지 않고, onConfigurationChanged(Configuration newConfig) 에서 
    회전시에 할 작업을 지정한다.

### Configuration 의 멤버 변수와 android:configChanges 비교

android.content.pm.ActivityInfo 에서 CONFIG_ 로 시작하는 상수와 매핑됨

Configuration

---

screenHeightDp, screenWidthDp

hardKeyboardHidden, navigationHidden

smallestScreenWidthDp

navigationHidden 이 navigation 이 아닌 keyboardHidden 과 매핑됨

### onConfigurationChanged() 메서드에서 구성변경 대응

[해당 솔루션](https://www.notion.so/5-632c954a8bd3486fbf8c9a55c8fcf9e6)은 구성 변경 시 onConfigurationChanged() 에서 모든 걸 설정하겠다는 의미이다

onConfigurationChanged() 가 불린 이후에 화면을 다시 그린다.

onConfigurationChanged() 을 재정의하지 않더라도 
activity 의 기본 onConfigurationChanged() 는 반드시 불린다

android:configChanges 을 언급하지 않는 경우, 액티비티를 새로 재시작하지만
android:configChanges orientation 을 언급한 경우, 액티비티를 재시작하지 않는다

어짜피 다시 생명주기는 실행되는데, onConfigurationChanged() 를 굳이 언급하지 않더라도
괜찮지 않나요?

View 생성자에서 해당 Configuration 의 리소스를 대입하는 구조 때문이다.
layout_width, layout_height 는 `ViewGroup` 속성이다.
setContentView 에서 내부적으소 이용하는 LayoutInflater inflate() 함수에서는 
View 생성자에서 View 속성부터 먼저 반영한다. 그리고 ViewGroup 의 generateLayoutParams() 를 실행해 layout_width, layout_height 을 반영한다

→ 즉 inflate() 단계에서 네임스페이스 값들 (dimens) 이 대입되고, configuration 이 변경된다고 해서 다시 대입되지 않는다.

1. **화면 회전 대응**

    android:configChanges 에 가장 흔하게 넣는 내용 : orientation

    layout-port, layout-land 디렉터리에 별도 레이아웃 리소스 사용하지 않을 시 많이 쓰임

    언급시 View 의 layout_width, layout_height 만 변경해서 적용함

    /res/values-port/dimens.xml
    /res/values-land/dimens.xml

2. **폰트크기 변경 대응**

    sp 를 사용하지 않는다면 fontScale 사용이 가능하다

    UI 가 복잡한 경우 dp 를 사용한다

    fontScale 을 추가하여 불필요하게 액티비티를 재시작하지 않을 수 있다.

3. **로케일 변경 대응**

    앱에서 다국어를 대응하지 않는다면 local 사용이 가능하다

    local 을 쓸 경우에 onConfigurationChanged() 내에서 대응할 코드만 작업하면 변경된 문자가 반영된다.

그외 특징

1. `|` 을 통해 여러개 반영도 가능하다. 
2. 일반 구성 변경이 아닌, 특정 케이스에 대응하는 경우도 있다
keyboardHidden (키보드가 숨겨졌는지 여부) 
3. setRequestOrientation() 을 호출하면서 configChanges 에 orientation 항목이 있다면 
액티비티는 재시작하지 않고 onConfigurationChanged() 가 불린다.
4. 최대보다는 최소를 원칙으로 삼자

### onSaveInstanceState() 메서드는 여전히 필요함

android:configChanges 에 값을 넣어도 onSaveInstanceState() 는 불린다.

## 5.2.7 Configuration 클래스의 변수 확인

configuration 을 출력하면 아래와 같다. (2번째 케이스는 화면 회전의 예, 3번째 케이스는 폰트크기변경의 예)

```kotlin
{1.0 450mcc5mnc ko_KR ldltr sw360dp w360dp h567dp 480dpi nrml port finger-keyb/v/h -nav/h s.28}
{1.0 450mcc5mnc ko_KR ldltr sw360dp w598dp h335dp 480dpi nrml port finger-keyb/v/h -nav/h s.29}
{1.15 450mcc5mnc ko_KR ldltr sw360dp w598dp h335dp 480dpi nrml port finger-keyb/v/h -nav/h s.29}
```

상세 명세 내용은 106~107 참고

### 포그라운드 액티비티 기준으로 구성 변경

화면 방향 고정인 액티비티가 포그라운드에 있다면 아무리 화면을 회전해도 
Application 의 onConfigurationChanged() 조차 불리지 않는다.

seq 가 변경되어 onConfigurationChanged() 가 호출된다.

### Configuration 은 1개의 상태만 있음

Configuration 은 하나의 값만 존재한다.

activityA 가로 → activityB 세로 고정일 때, activityB 에서 백버튼을 누를 경우 activityA 는 세로로 변한다.

# 5.3 테스크

테스크는 액티비티 작업 묶음 단위

앱과 테스크는 1:1 대응이 아니다 (ex. 3개의 액티비티 및 다른 앱으로 가더라도 하나의 테스크로 대응된다)

## 백스택

액티비티는 백 스택이라는 곳에 계속 쌓인다.

테스크 : 액티비티 모임
백 스택 : 그 모임이 저장된 방식을 의미하는 것

비권장이라고는 하지만 순서 조정은 가능하다 (ex. `Intent.FLAG_ACTIVITY_REORDER_TO_FRONT`)

## 테스크 관리 필요

프로그램의 흐름은 단순히 액티비티를 실행했다가 백 키로 돌아기만 하는 경우는 잘 없다.
상황에 따라 다양한 경로로 각각의 액티비티에 접근하기 때문에 내비게이션(화면 흐름)이 꼬이는 경우가 많다.
고민을 잘 하자

## 5.3.1 테스크 상태

태스크에는 화면에 포커스되어 있는 포그라운드 상태와, 화면에 보이지 않는 백그라운드 상태가 있다. 
포그라운드에 있는 것은 홈 키를 통해서 언제든 백그라운드로 이동할 수 있고, 
백그라운드에 있는 것도 언제든 포그라운드로 이동할 수 있다.

### 포그라운드에서 백그라운드로 테스크 이동

Activity 의 moveTaskToBack(boolean nonRoot)
nonRoot 가 true 일 시 어느 위치에서건 백그라운드로 이동할 수 있다
(false 인 경우, 테스크 루트일 때만 백그라운드로 이동할 수 있다)

ex. 암호 잠금, 비밀번호 잠금에서 비밀번호를 잘못칠 시

### 백그라운드에서 포그라운드로 테스크 이동

ActivityManager 의 moveTaskToFront(int taskId, int flag)

다만 이 경우에는 제약 사항이 좀 있음

1. android.permission.REORDER_TASK 퍼미션이 필요함

```kotlin
//ActivityManager 가져오기
ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);

//해당 앱과 관련있는 태스크들을 읽어오기
List<ActivityManager.AppTask> runningTaskInfos = activityManager.getAppTasks();
        
for (ActivityManager.AppTask recentTaskInfo : runningTaskInfos) {
	// 해당 앱과 패키지 이름이 동일하면
  if (recentTaskInfo.getTaskInfo().baseIntent.getComponent().getPackageName().equals(getPackageName())) {
	  int taskId;

		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
	    taskId = recentTaskInfo.getTaskInfo().taskId;
    } else {
	    taskId = recentTaskInfo.getTaskInfo().id;
    }

    //실행 중인 태스크만 포그라운드로 가져오기
    if (taskId > -1) {
	    activityManager.moveTaskToFront(taskId, 0);
    }
  }
}
```

## 5.3.2 dumpsys 명령어로 태스크 확인

백 키로 전환되는 화면들은 마치 하나의 스택처럼 보이는 데 이건 동일한 테스크라고 확신할 수 없다

ex. startActivity() 로 브라우저를 열었다면 화면과 브라우저는 한 묶음 같아 보이지만 동일한 테스크는 아니다

브라우저는 singleTask, launchMode 로 되어 있어 별도의 task 로 되어있다.

adb shell에서 dumpsys 명령어를 활용할 수 있다

```kotlin
adb shell dumpsys activity activities
```

하지만 바로 확인하긴 어렵다. dumpsys 명령어의 출력 결과는 많기 때문에 바로바로 확인하기가 어렵다. 

따라서 `adb shell dumpsys activity a > tasks.txt` 와 같이 사용하면 편하다.

- 실제 나오는 예

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eefa68c3-42cc-45a4-bece-6940d03ddfae/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eefa68c3-42cc-45a4-bece-6940d03ddfae/Untitled.png)

태스크는 최근에 사용한 액티비티 기준으로 먼저 위쪽에 나타난다.

`TaskRecord` 섹션은 하나의 태스크를 이루고 태스크의 다양한 정보를 볼 수 있다.

그 안에 Hist 섹션의 `ActivityRecord`를 통해 스택의 액티비티 정보를 알 수 있다.

`ProcessRecord`에는 프로세스명(패키지명) 앞뒤로 프로세스의 PID와 USER ID도 보여준다.

프로세스가 종료된 것 (히스토리) 인 경우도 있다

TaskRecord에는 ‘app=null’이면서 ‘state=DESTROYED’인 것이 그 예이다.

### 포커스된 액티비티 찾기

```kotlin
adb shell dumpsys activity a | grep mFocusedActivity
```

현재 포커스된 액티비티가 어떤 것인지 확인하는 데에도 유용

## 5.3.3 taskAffinity 속성

TaskRecord 의 어느 ActivityRecord 에는 소속되지만, 
이 소속되는 기준 가운데 한 가지가 바로 taskAffinitity 문자열 속성

단어분석

taskAffinity : 액티비티가 관련된 테스크에 들어갈 때 참고하는 값

affinity : 친밀한, 관련성, 천영성

실제분석

taskAffinity

- ActivityRecord에 속해있으며 AndroidManifest.xml의 액티비티 설정에 들어가는 값이다.
- `android:taskAffinity`로 설정할 수 있는데, 설정하지 않을 경우의 기본값은 앱의 패키지명이다.

affinity

- TaskRecord에 속해있으며 태스크를 시작한 액티비티의 taskAffinity 속성이다.

### taskAffinity 는 언제 사용되는가?

taskAffinity 는 android:lanunchMode 에 singleTask 를 지정하거나 
액티비티를 시작하는 Intent 에 FLAG_ACTIVITY_NEW_TASK 플래그를 전달하는 경우에 사용된다

→ 액티비티가 시작되면서 TaskRecord의 affinity가 액티비티의 taskActivity와 동일한 것을 찾아 그 태스크에 액티비티가 속하게 된다.

→ 시작하려는 액티비티의 taskAffinity에 따라서 결과가 달라진다. TaskRecord의 affinity가 실행하려는 taskAffinity와 동일한 게 있다면, 그 태스크에 액티비티가 포함되고, 그렇지 않다면 새로운 태스크가 시작된다.

→ singleTask 와 FLAG_ACTIVITY_NEW_TASK 는 무작정 새로운 태스크를 생성하는 것이 아니다.

### 액티비티 외의 컴포넌트에서 액티비티 시작

BroadcastReceiver나 Service에서 startActivity()를 실행하기도 한다.
(드물지만) Application에서 startActivity()를 실행하는 경우도 있다.

Activity 외 다른 컴포넌트에서 startActivity()를 실행하면 다음과 같은 에러와 함께 크래시가 발생한다.

```kotlin
android.util.AndroidRuntimeException: Calling startActivity() 
from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. 
Is this really what you want?
```

언급한대로 FLAG_ACTIVITY_NEW_TASK 를 포함해야 한다.

```kotlin
Intent intent = new Intent(context, MainActivity.class);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
context.startActivity(intent);
```

그렇게 되면 MainActivity의 taskAffinity와 동일한 affinity를 가진 태스크가 있을 경우 그 태스크 위에 올라가고,

그런 태스크가 없다면 새로운 태스크를 생성하여 실행되고 새로 생성한 태스크의 baseActivity가 된다.

### taskAffinity 속성 지정

(복습) taskAffinity는 AndroidManifest.xml의 액티비티 선언에 android:taskAffinity로 지정할 수 있고, 
속성이 없다면 디폴트 값은 패키지명

→ 해당 속성을 선언하지 않은 것끼리는 FLAG_ACTIVITY_NEW_TASK 속성을 쓰더라도 같은 태스크에 있다.

taskAffinity 속성을 지정할 때는 android:taskAffinity에 `:alarm`과 같이 콜론(:) 뒤에 구분자를 적는 걸 권장
그러나 taskAffinity는 보통은 쓰지 않는 속성

해당 속성을 별도로 지정하는 경우 case

1. 다른 화면들과 독립적으로 보여지는 알람 화면

    ex. 알람 리스트 화면(AlarmClock), 알람 설정 화면(AlarmSettings), 알람 화면(AlarmAlert) 에서
    AlarmAlert에 android:taskAffinity 속성이 따로 없는 경우

    → 일정 시간이 되어 알림이 뜨는(AlarmAlert) 그 순간 알람 앱의 태스크가 포그라운드나 백그라운드에 이미 있을 수도 있다. 

    포그라운드에 이미 있었다면 AlarmAlert 화면이 그 위에 추가되어서 포커스될 것이고, 
    백그라운드에 있다면 태스크가 포그라운드되면서 그 위에 AlarmAlert 화면이 뜰 것이다. 

    백 키를 누르면 방금 전까지 보이지 않았던 AlarmSettings 화면이 뜬다. 
    백그라운드에 있던 화면들까지 모두 딸려와서 흐름이 어색해진다.

    sol. 독립적인 화면인 AlarmAlert의 `android:taskAffinity` 속성을 별도로 지정하고, 
    AlarmAlert를 호출할 때 `FLAG_ACTIVITY_NEW_TASK` 플래그를 포함해보자. 

    그럼 새로운 태스크로 알람 화면이 뜨게 되고, 백 스택에 다른 화면이 딸려오는 일이 없어진다. 
    이 경우에는 하나의 앱에서 2개의 태스크를 사용한 것이고 
    최근 사용 앱 목록을 보면 2개가 있는 것을 확인할 수 있다.

    알람 태스크가 최근 앱 목록에 별도로 보이는 것을 방지하고 싶다면 AndroidManifest.xml의 
    AlarmAlert 선언에 `android:excludeFromRecents` 속성을 `true`로 하면 된다.

5.3.4 태스크 속성 부여

5.4 〈activity-alias〉 선언
