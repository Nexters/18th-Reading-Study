# Activity

화면의 기본단위이면서 가장 많이 사용되는 컴포넌트이다.

**액티비티 특징1. 액티비티는 필요한 만큼만 생성하기**

`AndroidManifest.xml`에 선언하고 설정 파일에 액티비티를 추가하면 된다.

 관리차원을 생각하면 많이 만드는 건 좋지 않다.

독립적인 화면이라면 액티비티가 더 적합하고, 종속적인 화면으로 보인다면 다른 것을 사용하면 된다.

1. 내부에 UI 액션이나 비즈니스 로직이 많다면 액티비티 고려하기
2. 팝업 형태라면 DialogFragment, PopupWindow 로 대체하기

**액티비티 특징2. setContentView 를 강제할 필요가 없음**

setContentView 가 없다면 UI 가 없는 액티비티

로직에 따라 다른 액티비티를 띄우도록 사용하기도 한다.

ex. Intent scheme 에 따라 다른 화면으로 전환하는 경우, 여러 액티비티에 intent-filter 를 추가하지 않고 
관문 역할의 액티비티 1개에만 여러 scheme 의 intent filter 를 추가하기도 한다.

```kotlin
<activity
	android:name=".activity.splash.SplashActivity"
	...
	tools:targetApi="n">

	<intent-filter>
	    <action android:name="android.intent.action.VIEW" />
	    <category android:name="android.intent.category.DEFAULT" />
	    <data android:scheme="doc" />
	    <data android:scheme="xls" />
	    <data android:scheme="ppt" />
	</intent-filter>
</activity>
```

= doc, xls, ppt 스킴이 전달될 시, SplashActivity 에서 처리하겠다

```kotlin
// SplashActivity.kt

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    
    when(intent?.data?.scheme){
        null -> Toast.makeText(this, "Uri does not exist", Toast.LENGTH_SHORT).show()
        "doc" -> startActivity(Intent(this, WordActivity::class.java))
        "xls" -> startActivity(Intent(this, ExcelActivity::class.java))
        "ppt" -> startActivity(Intent(this, PowerPointActivity::class.java))
        else -> Toast.makeText(this, "Uri is invalid", Toast.LENGTH_SHORT).show()
    }
}
```

# 5.1 생명주기

생명주기를 이해하지 못했을 때 리소스가 반납되지 않을 수도 있고, 필요한 데이터를 읽어들이지 못할 수도 있다.

(당연한 소리... 이거 모르면 개발자 때려쳐야 읍읍)

## 5.1.1 액티비티 생명주기 다이어그램

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cc83115c-8992-4093-bd9b-f06bc2f3a1d0/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cc83115c-8992-4093-bd9b-f06bc2f3a1d0/Untitled.png)

복습한다는 느낌으로 보니 새롭다.

### 다른 액티비티에 가리는 경우

일부분만 가리면 onPause, 전체를 가리면 onStop 까지 불림

전면 액티비티가 종료되어 돌아오면 일부분만 가렸을 경우 onResume, 전체를 가렸을 경우 onStart 가 불림

### 우선 순위가 더 높은 앱이 메모리를 확보

우선순위가 더 높은 앱을 실행해야하는데 메모리가 부족하다면 
OS는 우선순위가 비교적 낮은 앱을 언제든 종료시킬 수 있다.

이는 onPause() 단계 부터 해당되므로, 상황에 따라 `onStop()`, `onDestroy()`가 실행되지 않을 수 있다.

리소스를 안전하게 정리하는 게 필요할 경우 onStop(), onDestroy() 에 안전장치로 코드를 추가하기도 한다.

### 시스템에 의한 액티비티 제거

onDestroy() 는 아래의 경우 실행된다.

1. 사용자가 액티비티를 완전히 닫거나(뒤로 버튼을 누른 경우) `finish()`가 호출되는 경우
2. configuration 변경(ex 기기 회전, 멀티 윈도우 모드)으로 인해 
시스템이 일시적으로 액티비티를 소멸시키는 경우

메모리 부족 시 OutOfMemoryError 발생 전 액티비티를 제거하여 메모리 문제 가능성을 없애버릴 경우도 있다.

가용 메모리의 3/4 가 넘을 경우 백그라운드 테스크 앱을 종료시킨다.

## 5.1.2 생명주기 메서드 호출 시점

메서드가 어디까지 호출되는지는 `액티비티 화면 보임`(visibility) 여부, `포그라운드 여부`로 체크할 수 있다.

화면이 일부 보이지만 백그라운드 상태라면 onPause 까지만 실행된다. (전체를 가리면 onStop 까지 실행된다)

기타 시나리오는 아래 내용을 참고

1. **시작할 때**

    onCreate -> onStart -> onResume

2. **기기 회전할 때**

    onPause -> onStop -> onDestroy -> onCreate -> onStart -> onResume

3. **다른 액티비티가 위에 뜰 때 / 잠금 버튼으로 기기 화면을 끌 때 / 홈 키를 눌렀을 때**

    onPause -> onStop()

4. **백 키로 액티비티 종료**

    onPause -> onStop -> onDestroy

5. **백 키로 이전 액티비티로 돌아갈 때 / 잠금 화면을 풀고 액티비티로 돌아왔을 때 / 홈화면에서 돌아왔을 때**

    onRestart -> onStart -> onResume

6. **다이얼로그 테마 액티비티나 투명 액티비티가 위에 뜰 때**

    onPause

### 액티비티 lifeTime

~ 의 공간이 각 항목에 해당하는 lifeTime 이다.

1. 전체 : onCreate() `<` ~ `<` onDestroy()
2. 가시성(visibility) :  onStart() `<` ~ `<` onStop()
3. 포그라운드 (foreground) : onResume() `<` ~ `<` onPause()

Q. setContentView()에 전달된 레이아웃은 가시 lifeTime 시작인 onStart()에서 처리하는 것일까?

A . Nope

onCreate() 부터 onResume() 까지는 하나의 Message에서 처리하므로 
setContentView()의 결과는 `onResume() 이후`에 보인다. 

onStart() 부터 가시 라이프타임이라는 것은 
액티비티가 화면에 보이지 않다가, 다시 보일 때는 `로직상!!!` 여기부터 실행된다는 의미이다.

### 추가로 생명주기 메서드가 불리는 시점 확인

1. onCreate 에서 finish() 를 호출하면 다른 생명주기 메서드를 거치지 않고 onDestroy() 를 실행한다.
2. onActivityResult() 는 onResume() 보다 먼저 실행된다.

    (실행 순서에 유의하자. 특히 코루틴 등을 사용해서 onActivityResult 를 유야무야하게 만드는 경우!)

## 5.1.3 액티비티 시작 메서드

### 호출자와 피호출자

TabActivity 인 경우, getParent() 를 호출하면, 자신을 포함한 액티비티를 가리킨다. 
(자신을 시작시킨 액티비티를 가리키는 것이 아니다.)

위와 같은 혼란을 막기 위해 아래와 같이 명명한다.

A→B 에서 A 는 호출자(caller), B는 피호출자 (callee)

### 액티비티를 시작하는 메서드

startActivity(), startActivityForResult() 로 호출

startActivity() 는 Context 의 메서드, startActivityForResult() 는 Activity 의 메서드

startActivity() 는 단방향 통신 (→), startActivityForResult() 는 양방향 통신 (↔ )

→  startActivity() 호출 시, 피호출자에서 getCallingActivity(), getCallingPackage() 실행 시 null 반환

getCallingActivity(), getCallingPackage() : 호출자의 정보를 리턴

**startActivityForResult()**

1. 호출자에 따라 다르게 처리할 필요가 있을 경우
startActivityForResult() requestCode 파라미터에 0 이상 값을 넣는다
2. 호출자, 피호출자가 다른 테스크에 속해 있다면
onActivityResult() 에서 결과를 받을 수 없다.
3. setResult() 메서드는 finish() 전에 호출해야 한다. (놓치기 쉬운 실수이다.)

    그래야만 resultCode, data 가 호출자에게 전달된다.

4. resultCode 는 RESULT_OK, RESULT_CANCELED(`0`) 를 주로 사용한다.

    setResult() 를 호출하지 않으면 기본 값은 RESULT_CANCELED(`0`) 이다.

5. Intent.FLAG_ACTIVITY_FORWARD_RESULT

    A → B 상태에서 B 종료 후 A → C 형태가 가능할까? 이건 일단 가능하다

    C 에서 setResult() 한 데이터를 A 로 전달할 수 있을까? 이건 불가능하다. 
    (정확히는 onActivityResult() 는 호출되지만 setResult() 에서 설정한 데이터는 받을 수 없다.)

    이 값을 전달받으려면, B 에서 `startActivity()!!!` 를 시작하면서 Intent 내에 Intent.`FLAG_ACTIVITY_FORWARD_RESULT` 플래그를 추가해야 한다.

    startActivityForResult() 에서는 예외(Crash)가 발생한다.

    ```kotlin
    android.util.AndroidRuntimeException: 
    FORWARD_RESULT_FLAG used while also requesting a result
    ```

## 5.1.4 액티비티 전환 시 생명주기 메서드 호출

### 1. 액티비티에서 다른 액티비티를 시작할 때 (A → B)

A 액티비티 : onPause(), onStop() 실행

B 액티비티 : onCreate(), onStart(), onResume() 실행

그런데 이상하다. 왜 아래와 같이 onStop() 이 나중에 호출될까?

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a6fb3938-b4c2-4497-9919-ef0e6733daf3/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a6fb3938-b4c2-4497-9919-ef0e6733daf3/Untitled.png)

아직은 호출된 액티비티가 일부만 가리는지, 투명한지 알 수 없기 때문이다.

데이터를 연동하는 과정이 있다면, onStop()이 아니라 onPause()에서 저장하고 넘기는 걸 추천한다.
적어도 onPause() 는 두가지 케이스에 모두 실행되니까!

ex. A 에서 변경한 값을 B 에서도 사용할 때, onStop() 에서 변경하면 안되고 onPause() 에 저장해야 한다.

### 2. 포그라운드에서 액티비티가 닫힐 때 (B → A)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6f756f0f-0dc9-41d6-90cc-133e85c8d236/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6f756f0f-0dc9-41d6-90cc-133e85c8d236/Untitled.png)

이 경우도 [1번](https://www.notion.so/5-632c954a8bd3486fbf8c9a55c8fcf9e6)과 마찬가지로 onStop(), onDestroy() 가 나중에 실행된다.

## 5.1.5 생명주기 메서드 사용 시 주의사항

### 1. 리소스 생성 및 제거는 대칭적으로 실행하기

ex. onCreate()에서 리소스를 생성했다면 onDestroy()에서 제거

onResume()에서 생성했다면 onPause()에서 제거

### 2. 생명주기 함수를 override 해서 사용하는 경우, super.onXxx() 호출을 나중에 하기

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7c11b27d-98a2-44a8-a94c-abc41fe15c95/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7c11b27d-98a2-44a8-a94c-abc41fe15c95/Untitled.png)

[Effective Aandroid](http://orhanobut.github.io/effective-android/) 에서도 볼 수 있다.

```kotlin
@Override
public void onCreate(
	Bundle savedInstanceState
) {
    super.onCreate(savedInstanceState)
    ...  // 기타 로직
}

@Override
public void onDestroy() {
    ...  // 기타 로직
    super.onDestroy()
}
```

### 3. 생명주기 함수 내에서 finish() 메서드를 호출한 후에는 반환하기

finish() 는 단순히 화면을 종료하라는 신호만 보내는 것이므로 아래와 같이 사이드 이펙트가 생길 수 있다.

```kotlin
@Override
public void Create(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    address = getIntent().getPacelableExtra(EXTRA_DATA_ADDRESS);
    if (address == null) {
        Log.d(TAG, "Address not exist.");
        finish();
        return; //리턴 필요
    }
    //리턴이 없으면 NPE 발생
    Log.d(TAG, "address = " + address.city);
    ...
}
```

### 4. 생명주기 유사 함수 (ex. onXXX()) 는 직접 호출을 하지 말 것

onBackPressed() 를 재정의하면서 우리는 많이 겪었다. (영향이 그만큼 많이 가고 생각을 많이 해주어야 한다)

시스템이 알아서 호출하는 메서드는 함부로 엮지 말고 별도 메서드를 만들어서 처리하자!

onActivityResult() 를 직접 호출하는 사람도 있다더라...

# 5.2 구성 변경

## 구성(Configuration)

컴포넌트에서 어떤 리소스를 사용할지 결정하는 조건

프레임워크에서 따로 정해져 있음

화면 방향(orientation) 이 구성의 가장 대표적인 항목

구성 항목들은 `android.content.res.Configuration` 에서 확인 가능

- densityDpi, fontScale, hardKeyboardHidden, keyboard, keyboardHidden
- locale, mcc, mnc, navigation, navigationHidden, orientation
- screehHeightDP, screenLayout, screenWidthDp
- smallestScreenWidthDp, touchScreen, uiMode

fontScale, locale : 단말의 환경 설정에서 정할 수 있는 사용자 옵션이고, 그 이외는 단말의 현재 상태

## 5.2.1 리소스 반영

구성은 컴포넌트에서 사용하는 리소스를 결정한다. → 구성 변경 시 컴포넌트에서 사용하는 `리소스도 변경`된다.

ex. 단말 환경 설정에서 언어 변경 시 

(영어 기본, 한국어 / 일본어 지원)
/res/values, /res/values-ko, /res/values-ja 에 동일한 내용의 문자열을 번역해 strings.xml 을 각각 만듬

한국어 → 일본어
/res/values-ko/strings.xml → /res/values-ja/strings.xml 로 변경해서 보여줌

화면에서 하나씩 문자열을 변경하는 게 아닌 `액티비티를 재시작` 해서 변경된 리소스를 활용함

ex2. 화면 회전

/res/layout-port, /res/layout-land 디렉터리의 레이아웃 교체 시 `액티비티를 재시작`함

액티비티 이외의 다른 컴포넌트는 구성 변경에 민감하게 반응하지 않는다 (`재시작 X`)

## 5.2.2 구성 변경으로 인한 액티비티 재시작

인스턴스 초기화는 하지 않는다.

기존 인스턴스를 onDestroy()까지 실행한 후, 완전히 새로운 인스턴스를 생성해 onCreate() 부터 시작한다.

### 메모리 누수 가능성

onDestory()가 실행되었지만, 기존 액티비티 인스턴스에 대한 참조가 남을 시, 
GC되지 않고 메모리를 계속 차지한다.

화면을 회전할 때 자꾸 OutOfMemoryError가 발생한다면 원인은 메모리 누수 때문이다.

**case 1. Activity 목록 참조**

Activity 인스턴스를 따로 조작하는 행위는 되도록 피해야 한다. WeakReference 를 사용하더라도 피해야 한다.
ex. 떠 있는 액티비티의 특별한 작업을 위해 특정 collection 에 activity 들을 모아두기

액티비티 목록은 시스템이 알아서 관리하는 영역이기도 하고, 실수할 경우 문제가 발생할 수 있다.

**case 2. 액티비티의 내부 클래스나 익명 클래스 인스턴스**

activity 내부 클래스, 익명 클래스의 인스턴스가 activity 의 참조를 갖고 있다면 
이들 인스턴스를 외부의 리스너로 등록한 경우에 해제도 반드시 해야 한다.

해제를 하지 않는 실수는 메모리 누수로 이어진다.

ex. SomeActivity.this 를 쓸 수 있는 상황이면 액티비티에 대한 참조를 갖고 있는 것

해결책으로 단순 내부 클래스라면, 정적 내부 클래스를 만들어 생성자에 WeekReference로 
액티비티를 전달하는 방법을 사용하여 문제를 예방할 수 있다 (코드는 복잡해진다)

**case 3. 싱글턴에서 액티비티 참조**

싱글턴에 Context가 전달되어야 하는데 Activity 자신을 전달한 경우에 메모리 누수가 발생할 수 있다. 

ex. onCreate() 에서 AsyncTask 시작 시, AsyncTask 에서 activity 를 참조하고 있기 때문에 
      activity 는 GC 대상이 되지 않음!!

이로 인해 화면 회전 시 asyncTask 가 중단되지 않고 계속 실행되고, 
전환하면서 실행되는 onCreate 에 의해 또 실행됨

## 5.2.3 프레임워크 소스 확인

구성 변경 시 ActivityManagerService 에서 앱 프로세스의 메인 클래스인 ActivityThread에 새로운 Configuration 을 전달한다.

결과적으로 AssertManager의 네이티브 메서드(C로 작성된)인 setConfiguration()을 실행하는 것이다.

네이티브에서는 리소스 테이블을 유지하고 있는데, 현재 Configuration에 맞는 리소스를 선택해서 가져온다.

### 리소스 선택 로직

ex. getText()

```kotlin
Resources.getText(int id)
	AssetManager.getResourceText(int ident)
		AssetManager.loadResourceValue(int ident, short density, TypedValue outValue, boolean resolve)
```

loadResourceValue 는 네이티브 코드

AssetManager 를 거쳐 Configuration 에 맞는 리소스를 매번 선택해서 가져옴

ex2. 구성 업데이트

```
// 현재 사용 가능한 리소스

drawable/
drawable-en/
drawable-fr-rCA/
drawable-en-port/
drawable-en-notouch-12key/
drawable-port-ldpi/
drawable-port-notouch-12key/
```

```kotlin
현재 단말의 구성

Locale = en-GB
Screen orientation = port
Screen pixel density = hdpi
Touchscreen type = notouch
Primary text input method = 12key
```

1. 먼저 현재 구성에 맞는 리소스를 선택
2. 그 다음 우선순위를 가지는 한정자를 비교해 현재 구성과 맞지 않는 리소스를 계속 배제
(ex. drawable-fr-rCA/ 배제)
3. 그 외 시스템 자체적으로 구성을 확인하고 절대 선택될 일이 없는 리소스는 
리소스 테이블에 올리지도 않는 등 추가적인 과정이 존재

## 5.2.4 구성 한정자

![image](https://user-images.githubusercontent.com/13694046/121815761-f74a0380-ccb2-11eb-9bf8-346db85c1b30.png)

### 구성 한정자에 대한 알쓸신잡

1. 플랫폼 버전도 리소스 선택에 영향을 주지만 `Configuration` 멤버 변수에는 플랫폼 버전 값이 없다. 

    이는 숨겨진 멤버 변수인 `Build.VERSION.RESOURCES_SDK_INT`에 상수로 되어 있다.

2. `Configuration`의 멤버 변수 가운데서 `fontScale`은 구성 한정자와 관련된 것이 없다. 

    즉 `fontScale`은 리소스 선택 로직에는 영향을 주지 않고 액티비티를 재시작할 때 
    화면에서 `sp` 단위로 된 문자열의 크기를 변경할 뿐이다.

3. 언어 설정을 아랍어, 히브리어, 페르시아어로 변경하면 RTL(right-to-left)로 레이아웃 방향이 변경된다.

    (`AndroidMenifest.xml`에서 `supportsRtl` 속성이 true이고, `targetSdkVersion`이 17 이상일 때)

5.2.5 데이터 복구

5.2.6 android:configChanges 속성

5.2.7 Configuration 클래스의 변수 확인

5.3 태스크

5.3.1 태스크 상태

5.3.2 dumpsys 명령어로 태스크 확인

5.3.3 taskAffinity 속성

5.3.4 태스크 속성 부여

5.4 〈activity-alias〉 선언
