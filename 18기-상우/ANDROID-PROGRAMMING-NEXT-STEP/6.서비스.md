서비스의 UI 를 제공하지 않고 백그라운드에서 실행되는 컴포넌트

Android 26 이상부터는 백그라운드 서비스에 대한 제약이 강화되었다. 
따라서 여기서 설명할 서비스를 사용하는 용도와 예시는 26 이상 부터는 적합하지 않을 수 있다. 
(대안으로 JobScheduler와 DownloadManager 등을 사용할 수 있다.)

## 백그라운드 스레드에서 작업을 오래하는 문제

UI를 블로킹하지 않기 위해 Thread를 사용해 백그라운드에서 큰 스케일의 작업을 할 수 있다. 
(as like 30초동안 캘린더 일정 가져오기)

유저가 홈키를 누르는 등을 통해 앱을 빠져나오면
시스템은 메모리가 부족할 경우에 LMK(Low Memory Killer)가 
우선순위가 높지 않은 프로세스를 종료할 수 있다.

그 외에도 유저가 최근본 앱 목록에서 앱을 삭제함으로써 강제로 종료시킬 수 있다
(이 때에는 LMK 에 의해 제거된듯한 동작으로 종료된다)

→ 사용자, OS 에 의해 앱이 강제로 종료될 수 있다.

## 프로세스의 우선순위

1. 포그라운드 프로세스

    포그라운드에서 실행되는 프로세스

    메모리가 부족할 때에도 가장 마지막까지 남을 수 있는 프로세스

    아래 조건 중 하나라도 부합하면 포그라운드에 있는 것으로 간주한다.

    1. 사용자와 상호 작용하는 액티비티를 가지고 있다 (onResume() 이 실행된 상태)
    2. onReceive() 가 실행중인 BroadCastReceiver 을 가지고 있다
    3. onCreate(), onStart() onDestroy() 중 하나를 실행중인 서비스를 가지고 있다.

2. 가시 프로세스

    포그라운드 컴포넌트를 가지고 있지는 않지만 사용자가 보는 화면에 영향이 있는 프로세스

    1. onPause() 가 실행되었으나 가시 상태인 액티비티를 가지고 있을 때

        (ex. 다른 프로세스의 다이얼로그 테마나 투명한 액티비티가 가렸을 때)

    2. Service.startForeground() 를 통해 포그라운드 서비스로 실행 중인 Service 가 있을 때
    3. 가시 액티비티에 바운드된 서비스가 실행 중일 때

1. 서비스 프로세스

    startService 메서드로 시작된 Service 를 유지하는 프로세스 (위의 카테고리에 들어가지 않은 프로세스)

    지금 보고 있는 화면과 직접적인 연관은 없지만 일반적으로 사용자가 관심을 가진 작업 (ex. 백그라운드 네트워크 데이터 다운로드) 을 실행한다.

    메모리가 부족하지 않은 상태라면 서비스 프로세스까지는 실행 상태를 유지하려 한다.

    ---

2. 백그라운드 프로세스

    액티비티가 종료된 것은 아니지만 사용자에게 더 이상 보이지 않고 활성화된 컴포넌트가 없는 프로세스

    LRU 목록으로 유지되며 일반적으로 가장 오래된 프로세스부터 제거된다.

3. 빈 프로세스 ( = 캐시 프로세스)

    백 키로 액티비티를 모두 종료하고 활성화된 컴포넌트가 없는 프로세스

    다음에 컴포넌트를 다시 띄울 때 빠르게 띄울 수 있도록 캐시로 사용하기 위해서, 
    백키를 눌러 액티비티가 모두 종료 되었더라도 메모리에 한동안 유지된다.

    우선순위가 매우 낮으므로, 가장 먼저 강제 종료 대상이 된다.

아래같은 형태로 하면 생명주기 메서드가 실행중일 때는 우선순위가 가장 높은 포그라운드 프로세스에 있다가
onStartCommand() 메서드가 리턴되고 난 이후에 세번째 우선순위인 서비스 프로세스에 남는다.

1. Application 에서 startService 를 통해 Service 를 시작
2. Service 에서 백그라운드 스레드를 시작

LMK 에 의해 언제든 제거되는 프로세스인 빈 프로세스가 아니므로 
스레드에서 하는 작업을 무사히 종료할 수 있는 가능성이 높아진다. 
(최근 앱 목록에서 삭제하더라도 마찬가지이다)

프로세스가 강제 종료될 시 서비스는 onStartCommand() 리턴 값에 따라 재시작 여부를 결정하는 데
디폴트 값은 START_STICKY 로 서비스를 재시작한다.

## 서비스는 UI 스레드에서 실행

서비스는 액티비티처럼 눈에 보이는 가시 컴포넌트가 아닐 뿐이지, 
메인 쓰레드에서 실행이 안된다는 것이 아니다.
(메인 스레드가 아닌 별도 스레드에서 서비스를 실행하는 것으로 착각하면 안된다.)

서비스의 생명주기 메서드는 UI 스레드에서 실행되고 이 때문에 다른 UI 가 지연될 수 있다.
UI 를 블로킹하는 작업이 있다면, 되도록 백그라운드 스레드를 생성해서 작업을 진행해야 한다.

서비스는 스레드를 안정적으로 돌리기 위한 컴포넌트

## 서비스는 단일 인스턴스로 실행

서비스는 앱에서 1개의 인스턴스만 생긴다

일부로 싱글턴 객체를 만들고 그 안에서 백그라운드 스레드를 실행하도록 하지 않아도 된다

(ex. 서비스와 다른 클래스에서 사용하던 싱글턴 객체를 서비스로 모두 옮길 경우, 
        싱글턴이 아닌 서비스의 멤버 변수로 남기더라도 싱글턴과 동일하게 작업이 진행된다.)

## 서비스 시작 방법

startService(), bindService(), startForegroundService()(`26부터 제공`) 가 존재한다.

![image](https://user-images.githubusercontent.com/13694046/126911879-3349be04-f42c-4cab-840e-bf01d4cfb182.png)

## 스타티드 & 바운드 서비스

스타티드이면서 바운드인 서비스도 존재한다

ex1. 음악 재생화면이 있을 때, 

  화면을 종료하더라도 재생되게 하려면 스타티드 서비스를 사용해야 한다.

  다시 화면에 진입 할 때 재생중인 음악 정보를 보여주어야 한다면 바운드 서비스를 활용해야 한다.

ex2. 화면에서 파일 다운로드 명령을 하고 서비스에서 실제 다운로드를 진행할 떄

  seekBar 을 통해 다운로드 진행률을 표시하는 데 화면을 종료해도 다운로드는 계속되어야 한다

  다시 화면에 진입해도 진행률을 표시해주어야 한다. 

# 6.1 스타티드 서비스

`startService()` 메서드나 `startForegroundService()` 로 시작
(`startForegroundService()` 의 경우 5초 이내로 
 서비스의 startForegroiund() 를 호출해 알림을 표시해야 한다. 못하면 서비스를 중단시키고 ANR 로 간주한다.)

호출되는 시점에 바로 시작되지 않는다.

Main Looper 의 MessageQueue 에 Message 가 들어가서 
메인 스레드를 쓸 수 있는 시점에 서비스가 시작된다.

startService() 메서드는 곧바로 ComponentName을 리턴하고 다음 라인을 진행한다.
startService()는 Intent Bundle 에 파라미터를 전달하고, 서비스에 작업하도록 요청하는 역할을 할 뿐이다.

6.1.1 서비스 재시작 방식

6.1.2 멀티 스레드 이슈

6.1.3 외부 프로세스에서 암시적 인텐트로 서비스 시작

6.1.4 IntentService 클래스

6.1.5 서비스 중복 실행 방지

6.2 바운드 서비스

6.2.1 리모트 바인딩

6.2.2 로컬 바인딩

6.2.3 바인딩의 특성

6.2.4 Messenger 클래스
