# 30장 데이터베이스는 세부사항이다

DB 는 엔티티가 아님 ( = 저수준)

아키텍트 구성 요소로 끌어올릴 수 없음

# __관계형 데이터베이스

관계형 데이터베이스는 데이터를 저장하고 접근하는데 탁월한 기술

하지만 그저 기술일 뿐

데이터를 테이블의 행 형태로 둔다는 거 아키텍처의 외부(원 바깥)에서만 알아야 함

테이블과 행이 객체 형태로 시스템 여기 저기에 있는 건 잘못된 설계

# __데이터베이스 시스템은 왜 이렇게 널리 사용되는가?

디스크가 주 이유

하지만 디스크는 시간 지연이 큼. 이를 완화하기 위해

1.  색인, 캐시, 쿼리 계획 최적화가 필요
2. 데이터를 표현하는 일종의 표준 방식도 필요

시간이 지나면서 파일 시스템, 관계형 DB 관리 시스템으로 분류됨

파일 시스템

1. 문서 전체를 자연스럽고 편리하게 저장하는 방법 제공
2. 이름을 기준으로 저장, 조회 시 잘 동작
3. 내용을 기준으로 검색 시엔 도움이 되지 않음

DB 시스템

1. 내용을 기반으로 레코드를 자연스럽고 편리하게 찾는 방법 제공1 
2. 서로 공유하는 내용에 기반해 다수의 레코드를 연관(join) 하는 데 탁월
3. 정형화되지 않은 문서를 저장하고 검색하는 데는 부적합

# __디스크가 없다면 어떻게 될까?

디스크는 RAM 으로 대체되고 있음

(연결리스트, 트리, 해시테이블, 스택, 큐)

이미 우리는 데이터가 DB 나 파일 시스템에 있더라도 RAM 으로 읽어 위 개념을 사용하고 있음

데이터를 파일이나 테이블 형태로 두는 경우는 거의 없음

# __세부사항

DB 는 한낱 매커니즘에 불과

아키텍처 입장에서 DB 의 존재를 알면 안됨

# __하지만 성능은?

저수준 관심사

1. 데이터 저장소 측면에서 보는 성능은, 업무 규칙과는 분리될 수 있음
2. 데이터 저장소에서 데이터를 빠르게 넣고 뺄 수 있어야 하는 건 맞지만 이는 저수준 관심사

결론 : 성능은 시스템의 전반적인 아키텍처와는 아무런 관련이 없음

# __개인적인 일화

관계형 DB 를 도입해야한다고 주장한 어느 마케팅 담당자 (사유는 마케팅)

관계형 DB 를 도입해야한다고 주장한 어느 하드웨어 엔지니어 (사유는 기술적인 이유)

공학적인 부분에선 관계형 DB 도입이 나쁘지만, 고객의 부분에서는 관계형 DB 를 무지성으로 원함

DB 업체에서 실시한 마케팅 캠페인
→ 기업의 데이터 자산은 `보호할 필요`가 있으며 자신의 DB 시스템은 이러한 보호를 약속함

# __결론

DB 는 세부사항이며 아키텍처 관점에선 중요하지 않음

# 31장 웹은 세부사항이다

모든 전산 능력을 `중앙 서버`에 두는 방식과 `단말(디바이스)`에 두는 방식의 괴리

메타

1. 모든 연산 능력이 서버 팜에 위치하고, 브라우저는 수동적인 역할만 수행
2. 애플릿을 추가하여 동적인 내용을 웹에 추가하다가 서버로 다시 옮김
3. Ajax 와 js 를 이용해 처리과정의 많은 부분을 웹으로 옮김
4. Node.js 로 다시 웹의 js 영역을 서버로 옮김

(몇 번을 왔다갔다 하는거니)

# __끝없이 반복하는 추

웹이 있기 전에는 클라이언트-서버 아키텍처가 존재

연산 능력을 어디에 둘 것인지는 지속된 난제였음

갑자기 웹이 나오면서 이는 심화됨

진동 뭐시기 등의 내용이 있었지만 결론은 업무 규칙은 UI 로부터 분리되어야 함

# __요약

웹 = GUI = 세부사항 = 입출력 장치

UI 와 애플리케이션 사이에는 추상화가 가능한 또 다른 경계가 존재함

- 업무 로직은 다수의 유스케이스로 구성
- 각 유스케이스는 사용자를 대신해 일부 함수를 수행함
- 각 유스케이스는 입력 데이터, 수행 처리 과정, 출력 데이터를 기반으로 기술

완전한 입력 데이터와 그에 따른 출력 데이터는 데이터 구조로 만들어 
유스케이스 처리 과정의 입력, 출력 값으로 사용할 수 있음

→ 각 유스케이스가 장치 독립적인 방식으로 UI 라는 입출력 장치를 동작시킨다고 간주할 수 있음

# __결론

웹은 핵심업무 로직에서 분리된 경계 바깥에 두어야하는 입출력장치


# 32장 프레임워크는 세부사항이다

프레임워크는 아키텍처가 아님

# __프레임워크 제작자

프레임워크는 각자 만든이를 위해 만들어질 뿐, 나를 위해서 만들어진 것이 아니다.

(하지만 대부분 만든이의 니즈와 나의 니즈가 겹칠때가 많긴 함)

# __혼인 관계의 비대칭성

프레임워크는 우리를 신경쓰지않지만, 우리는 프레임워크에 종속되어 있다. (비대칭적)

하지만 프레임워크는 소프트웨어와의 긴밀한 결합을 원함

(express 와 node.js)

# __위험 요인

프레임워크는 의존성 규칙을 위반하는 경향이 있음 (ex. 프레임워크의 코드를 상속받기를 요구)

초기엔 많이 쓰겠지만 이후로는 프레임워크의 틀을 벗어나게 됨

프레임워크가 제작자의 길을 막을수도 있음 (도움이 안되는 방향으로 진화)

새로운 프레임워크가 구미를 당길수도 있음

# __해결책

프레임워크는 아키텍처 바깥쪽 원의 세부사항으로 취급해야 함

ex. 업무 규칙이 스프링을 알아서는 안됨 (의존성 주입을 위해 사용하는 `@Autowired` 어노테이션)

# __이제 선언합니다

필요한 경우도 존재 (C++ 의 STL, 자바의 자바 표준 라이브러리)

하지만 선택적이어야 한다

# __결론

# 33장 사례 연구: 비디오 판매

# __제품

웹 사이트에서 비디오를 판매하는 소프트웨어

- 판매하길 원하는 비디오들이 있고 그걸 개인과 기업에게 웹을 통해 판매
- 단품 가격을 지불해 스트리밍으로 보거나, 더 높은 가격을 내고 영구 저장 가능
- 기업용 라이센스 존재  (스트리밍 전용이며 대량 구매를 하면 할인을 받음)

유저 명세

개인 : 시청자인 동시에 구매자, 

기업 : 다른 사람들이 시청할 비디오를 구매하는 사람 따로 존재

비디오 제작자 : 비디오 파일과 설명, 부속 파일을 제공

관리자 : 신규 비디오 시리즈 추가, 기존 시리즈 물에 비디오를 추가 또는 삭제, 가격 책정

시스템의 초기 아키텍처를 결정하는 첫 단계 : 액터와 유스케이스를 식별하기

# __유스케이스 분석

주요 액터 : 4개

단일 책임 원칙에 따르면, 4개의 액터가 시스템이 변경되어야 할 4가지 주요 근원이 됨

신규 기능 추가, 기존 기능 변경 시 이들 액터 중 하나에게 해당 기능을 제공해야 함

시스템을 분할하여 특정 액터를 위한 변경이, 나머지 액터에게는 전혀 영향이 끼치지 않게 만들고자 함

<img width="904" alt="image" src="https://user-images.githubusercontent.com/13694046/143775193-aa7906a5-e10a-45b8-9444-73a87522ccb8.png">

이 유스케이스도 완벽하진 않음 

→ 로그인, 로그아웃 유스케이스 미존재 (다 담으려면 내용이 너무 방대)

점선으로 된 유스케이스 (ex. 카탈로그 조회하기, 라이선스 구매하기)

- 추상 유스케이스
- 범용적인 정책을 담고 있고 다른 유스케이스에서 이를 더 구체화함
- 시청자 입장, 구매자 입장 각각에서의 카탈로그 조회하기는 
모두 카탈로그 조회하기라는 추상 유스케이스를 상속받음
- 굳이 없어도 되는 추상 유스케이스이지만, 
유사성을  식별해서 분석 초기에 통합하는 차원에서 생성함

# __컴포넌트 아키텍처

2단계는 예비 단계의 컴포넌트 아키텍처 만들기

<img width="905" alt="image" src="https://user-images.githubusercontent.com/13694046/143775200-e1fedcb7-6c2b-487b-bf27-47fbd5b4f734.png">

2중으로 된 선은 아키텍처의 경계

View, Presenter, Interactor, Controller 로 분리된 전형적인 분할 방법

각 컴포넌트는 dll, .jar 로 만들 수 있음 
(이럴 경우 서로 독립적으로 변경될 가능성이 큰 컴포넌트들을 독립적으로 배포할 수 있음)

ex. `|` 기준으로 각각 jar 를 둠

1. 뷰 + 프레젠터 `|` 인터렉터 `|` 컨트롤러 `|` 유틸리티
2. 뷰 + 프레젠터 `|` 인터렉터, 컨트롤러, 유틸리티 

# __의존성 관리

제어 흐름은 오른쪽에서 왼쪽으로 이동

1. 입력이 컨트롤러에서 발생 시 인터랙터에 의해 처리되어 결과가 만들어짐
2. 그 후 프레젠터의 결과의 포맷을 변경하고 뷰가 화면에 표시함

그렇다고 무조건 모든 화살표가 오른쪽에서 왼쪽을 가르키지는 않음

1. 대다수가 아키텍처 의존성 규칙으로 인해 왼쪽에서 오른쪽으로 향하긴 함
2. 모든 의존성은 경계선을 한 방향으로만 가로지르도록 하며, 
항상 더 높은 수준의 정책을 포함하는 컴포넌트를 향함

개방 폐쇄 원칙을 적용

1. 사용관계(열린 화살표)는 제어 흐름과 같은 방향을 가리킴
2. 상속 관계(닫힌 화살표)는 제어 흐름과 반대 방향을 가리킴

결론

의존성이 올바른 방향으로 흐름

저수준의 세부사항에서 발생한 변경이 상위로 파급되어 
상위 수준의 정책에 영향을 미치지는 않음을 보장

# __결론

위 다이어 그램은 두 가지 서로 다른 차원의 분리 개념을 포함함

1. 단일 책임 원칙에 기반한 액터의 분리
2. 의존성 규칙

두 차원은 서로 다른 이유로 서로 다른 속도로 변경되는 컴포넌트를 분리하는 데 목적이 있음

프로젝트를 구조화하고 나면 시스템을 실제로 배포하는 방식은 다양하게 선택 가능

# 34장 빠져 있는 장

여기는 스크린샷과 병행하여 진행

# __계층 기반 패키지
<img width="941" alt="image" src="https://user-images.githubusercontent.com/13694046/143775216-754835bb-e928-4822-b335-a6825354efee.png">

# __기능 기반 패키지
<img width="935" alt="image" src="https://user-images.githubusercontent.com/13694046/143775239-7505557d-b01f-4fa6-93cc-69280db031d6.png">

# __포트와 어댑터
<img width="925" alt="image" src="https://user-images.githubusercontent.com/13694046/143775269-e74c0fb9-d846-4e89-874a-ae1c6c3cef40.png">

# __컴포넌트 기반 패키지

대다수는 전통적인 계층형 아키텍처를 따름

하지만 계층형 아키텍처는 기능이 같은 코드끼리 서로 분리하는 것

의존성 화살표가 항상 아래로 향하고 각 계층은 반드시 바로 아래 계층에만 의존해야 함

안타깝게도 속임수를 써서 몇몇 의존성을 의도치않은 방식으로 추가하더라도 비순환 의존성 그래프가 완성됨
(완화된 계층형 아키텍처)

아키텍처를 깨뜨리지 않기 위한 원칙 고수가 일부 필요

1. 웹 컨트롤러는 절대로 Repository 에 접근하면 안된다는 원칙
2. **/web 패키지에 있는 타입은 절대로 **/data 에 있는 타입을 접근하지 않는다는 원칙

컴파일러를 사용해서 아키텍처를 강제하는 방식을 사용하길 추천
<img width="934" alt="image" src="https://user-images.githubusercontent.com/13694046/143775288-aa8625b4-4f46-4b92-a692-d2de10465ac3.png">

위 구조의 특징

주문과 관련된 무언가를 작업 시 OrdersComponent 만 보면 됨

관심사의 분리는 여전히 유효하고 업무 로직은 데이터 영속성과 분리되어 있음

주문 처리와 관련된 모든 것을 캡슐화하려는 별도의 OrdersService 가 존재

모노리틱 어플리케이션에서 컴포넌트를 잘 정의하면 마이크로서비스 아키텍처로 가기 위한 발판이 될 수 있음

# __구현 세부사항엔 항상 문제가 있다

public 접근 지시자

- 캡슐화 관련 이점을 사용하지 않겠다는 의미
- 아키텍처를 위반하게 될 것 (거의 blame 수준)

# __조직화 vs. 캡슐화

public 을 과용하면 상기 언급된 네 가지 아키텍처 접근법은 본질적으로 같아짐 (= 캡슐화가 없어짐)

<img width="919" alt="image" src="https://user-images.githubusercontent.com/13694046/143775313-b8c6a8e5-f4af-4512-b62b-9772ec05a3a2.png">

1번째 : 계층 기반 패키지

OrderService 와 OrderRepository 인터페이스
외부 패키지의 클래스로부터 자신이 속한 패키지 내부로 들어오는 의존성이 존재하므로 public 으로 선언

구현체 (OrderServiceImpl. JdbcOrdersRepository) 는 제한적으로 선언
누구도 알 필요가 없는 구현 세부사항

---

2번째 : 기능 기반 패키지

OrdersController
패키지로 들어올 수 있는 유일한 통로이므로 public 으로 선언 (나머지는 제한적으로 선언)

해당 패키지의 특징
패키지 밖의 코드에서는 컨트롤러를 통하지 않으면 주문 관련 정보에 접근하지 못함 (양날의 검)

---

3번째 : 포트와 어뎁터

OrderService 와 Orders 인터페이스는 외부로부터 들어오는 의존성을 가지므로 public

기타 구현체 (OrderServiceImpl. JdbcOrdersRepository) 는 제한적으로 선언

런타임에 의존성을 주입할 수 있음

---

4번째 : 컴포넌트 기반 패키지

OrderComponent 인터페이스
외부로부터 의존성을 가지므로 public 으로 선언  (나머지는 제한적으로 선언)

---

위 시나리오는 모든 코드가 단 하나의 소스코드 트리에 존재하는 경우

아키텍처 원칙을 강제할 경우 자기 규율이나 컴파일 후처리 도구 대신, 컴파일러에 의지할 것을 권장

# __다른 결합 분리 모드

소스코드 의존성을 분리하는 방법

1. OSGi 같은 모듈 프레임워크나, 자바 9에서 제공하는 새로운 모듈 시스템 사용
    
    public 와 외부에 공표할 타입 분리 가능
    
    (ex. 모든 타입이 public 이더라도 일부 타입만을 외부에서 사용할 수 있도록 만들 수 있음)
    
2. 소스코드 수준에서 의존성 분리하기
    1. 서로 다른 소스코드 트리로 분리
        
        ex.  포트와 어뎁터
        
        업무와 도메인용 소스 코드 : OrdersService, OrdersServiceImpl, Orders
        
        웹용 소스코드 : OrdersController
        
        데이터 영속성용 소스코드 : JdbcOrdersRepository
        
        업무와 도메인 코드 자체는 웹이나 데이터 영속성 코드에 대해서는 아무것도 알지 못함
        
        하지만 너무 이상적인 해결책 (성능, 복잡성, 유지보수 등)
        
    2. 단순히 소스코드 트리를 두 개만 만들기 (도메인 코드 : 내부, 인프라 코드 : 외부)
        
        도메인에 대해 컴파일 시점 의존성을 지님
        
        소스코드를 조직화 시 효과가 있지만 잠재적으로 절충할 부분 존재 
        (포트와 어댑터에 대한 페리페리크 안티 패턴)
        
        <aside>
        ❓ 페리페리크 안티 패턴
        
        특정영역(인프라코드중 웹 컨트롤러 부분)이 애플리케이션의 다른 영역에 있는 코드를 
        도메인 코드를 통하지않고 직접 호출 가능
        
        </aside>
        
        인프라 코드를 단일 소스코드에 모두 모아둔다는 말 
            = 애플리케이션에서 특정 영역에 있는 인프라 코드가 
                애플리케이션의 다른 영역에 있는 코드를 직접 호출할 수 있다는 말
        

# __결론: 빠져 있는 조언

구현 전략에 얽힌 복잡함을 고려하지 않으면 설계가 순식간에 망가질 수 있음

아래 사항을 고민해보기

1. 설계를 어떻게 해야 `원하는 코드 구조로 매핑`할 수 있을지
2. `코드`를 어떻게 `조직화`할지
3. 런타임과 컴파일 타임에 어떤 `결합 분리 모드`를 적용할지
4. 선택사항을 열어두고 `실용주의적`으로 움직이기
5. 팀의 규모, 기술 수준, 해결책의 복잡성을 `일정과 예산`이라는 제약과 동시에 고려하기

