좋은 소프트웨어 시스템 : 깔끔한 코드

SOLID

중간 수준의 소프트웨어 구조가 아래와 같이 만들어지는 것을 목표로 함

1. 함수와 데이터 구조를 클래스로 배치하는 방법과, 이 클래스를 서로 결합하는 방법을 설명
2. 이해하기 쉽고, 변경에 유연한 프로그램을 만들 수 있도록 함

중간 수준?

프로그래머가 모듈 수준에서 작업할 때 적용할 수 있다는 뜻
코드 수준보다 상위에서 적용됨 
모듈과 컴포넌트 내부에서 사용되는 SW 구조를 정의하는 데 도움을 줌

이 원칙을 알고도 clean 하지 않을 수 있으므로 고수준의 원칙도 알아야 함

# 7장 SRP: 단일 책임 원칙

~~모든 모듈이 `단 하나의 일`만 해야 한다~~ → SRP 가 아님

1. 단 하나의 일만 한다는 것 : 함수는 반드시 하나의 일만 해야한다는 원칙

실제 정답은 아래 내용

단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.

( = 하나의 모듈은 오직 `하나의 사용자 또는 이해관계자(액터)`에 대해서만 책임져야 한다)

모듈 : 단순하게는 `소스 파일`, 복잡하게는 단순이 함수와 데이터 구조로 응집된 집합 (`클래스`)

`하나의 사용자 또는 이해관계자` : 집단, 즉 해당 변경을 요청하는 한 명 이상의 사람  ( = actor)

# 징후 1: 우발적 중복

```kotlin
class Emplayee {
	fun calculatePay(){}
	fun reportHours(){}
	fun save(){}
}
```

이 클래스가 SRP 를 위반하는 이유

- 하나의 모듈이 세 가지 액터에 대응함
calculatePay(회계팀에서 사용), reportHours(인사팀에서 사용), save(DB 관리자가 사용)
- 회계팀에서 사용하는 로직을 수정하면 인사팀, DB 팀에 영향을 줄 수 있음

ex. regularHours(초과근무를 제외한 업무시간을 계산하는 알고리즘) 을 공유할 경우

회계팀에서 생각하는 초과근무 산정 방식과, 인사팀에서 생각하는 초과 근무 산정 방식이 다를 수 있음

이경우 regularHours 가 회계팀과 인사팀 모두에 영향을 끼치고, 쥐도새도 모르게 변경될 수 있음

이 데이터를 활용한 통계 및 자료는 이제 엉터리가 되어버림 (그렇게 수백만 달러 손실)

# 징후 2: 병합

소스 파일에 많은 메서드를 가지고 있으면 자주 생길거라 누구나 예상할 수 있다.

ex. DB 팀에서 Employee 스키마를 변경하기로 하고 regularHours 도 변경하기로 함 (인사팀)

각 팀의 개발자가 이걸 처리하려고 보니... 겹친다 (충돌한다)

병합에는 위험이 따른다. 어떤 도구도 병합이 발생하는 모든 경우를 해결할 수 없다.

많은 사람이 서로 다른 목적으로 동일한 소스 파일을 건드리려할때 문제가 발생한다.

# 해결책

1. 데이터와 메서드를 분리하기
    
    ```kotlin
    class EmplayeeData {
    }
    
    class PayCalculator { fun calculatePay(){ ... } }
    class HourReporter { fun reportHours(){ ... } }
    class EmployeeSaver { fun save(){ ... } }
    ```
    
    세 가지 클래스를 인스턴스화하고 추적해야 함
    

1. facade 패턴
    
    ```kotlin
    class EmplayeeData {
    }
    
    class PayCalculator { fun calculatePay(){} }
    class HourReporter { fun reportHours(){} }
    class EmployeeSaver { fun save(){} }
    
    class EmployeeFacade {
    	fun calculatePay() = PayCalculator().calculatePay()
    	fun reportHours() = HourReporter().reportHours()
    	fun save() = EmployeeSaver().save()
    }
    ```
    
    EmployeeFacade 에 코드는 거의 없음.
    
    이 클래스는 세 클래스의 객체를 생성하고 요청된 메서드를 가지는 객체로 위임하는 일을 책임짐
    
    FaCade??
    
2. facade 응용
    
    ```kotlin
    class EmplayeeData {
    }
    
    class PayCalculator { fun calculatePay(){} }
    class HourReporter { fun reportHours(){} }
    class EmployeeSaver { fun save(){} }
    
    class Employee {
    	val emplayeeData : EmplayeeData
    
    	fun calculatePay() = PayCalculator().calculatePay()
    	fun reportHours() = HourReporter().reportHours()
    	fun save(){ ... }
    }
    ```
    
    중요한 함수 (save) 는 원래 위치에 둠
    

모든 클래스는 반드시 단 하나의 메서드를 가져야 한다는 주장에 위배된다고 할 수 있음

→ 사실상 이는 불가능 (위의 내용은 일련의 간단한 예일 뿐이지 실제는 2~30개까지도 될 것이다)

# 결론

단일 책임 원칙은 메서드와 클래스 수준의 원칙이지만, 
이보다 상위의 두 수준에서도 다른 형태로 등장함

1. 컴포넌트 수준 : 공통 폐쇄 원칙
2. 아키텍처 수준 : 아키텍처 경계 생성을 책임지는 변경의 축

# 8장 OCP: 개방-폐쇄 원칙

```kotlin
소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
```

확장 가능해야 하지만, 이 때 객체를 변경하면 안된다.

요구사항을 살짝확장하는 데 소프트웨어를 엄청나게 수정해야 할 경우 이는 실패이다

# 사고 실험

ex. 재무재표를 웹 페이지로 보여주는 시스템

웹 페이지에 표시되는 데이터는 스크롤할 수 있으며 음수는 빨간색으로 출력

이 상황에 아래와 같은 요구사항이 들어옴

- 흑백 프린터, 페이지 번호 존재, 머리글 바닥글 존재, 표의 각 열에는 레이블 존재해야 함

이상적인 코드 변경량은 0

1. 다른 목적으로 변경되는 요소를 적절하게 분리 (단일 책임 원칙), 
    
    보고서 생성을 두 개의 타입으로 분리시킬 수 있음
    
    1. 보고서용 데이터를 계산하는 책임
    2. 데이터를 출력하는 것 (ex. 웹에 표시, 프린터로 출력)
    
2. 이들 요소 사이의 의존성을 체계화(의존성 역전 원칙) 하여 
    
    위와 같이 책임을 분리했다면, 두 책임 중 하나에서 변경이 발생하더라도 
    다른 하나는 변경되지 않도록 해야 함
    
    새로 조직화한 구조는 기능이 확장되더라도 변경이 발생하지 않음을 보증해야 함
    
    → 소스코드 의존성도 확실히 조직화해야함
    

위를 위해서는 단방향으로 의존해야한다 (as like ViewModel with LiveData)

= A컴포넌트로부터 발생한 변경으로부터 B 컴포넌트를 보호하려면 
    A 컴포넌트는 B 컴포넌트에 의존해야함

= View 에서 발생한 변경으로부터 Presenter 를 보호하고자 함

= DataBase 등 특정 컴포넌트에 변경이 있더라도 영향을 받지 않음

## 방향성 제어

컴포넌트 간 의존성이 제대로 된 방향으로 향하고 있는 것이 중요함

의존성이 바로 향하지 않도록 해야 함 (ex. View 에서 바로 DB 로 접근 등)

# 정보 은닉

때로는 Interactor 내부의 정보를 감추기 위한 용도로도 사용됨 
(as like RepositoryImpl class, Repository interface)

추이 종속성

- 클래스 A 가 클래스 B 에 의존, 클래스 B 가 클래스 C 에 의존하면 A 는 C 에 의존
- 특정 기능이 추이 종속성을 갖게 되면 
`자신이 직접 사용하지 않는 요소에는 절대 의존하면 안된다`는 원칙에 위배됨
- ISP 와 공통 재사용 원칙과 유관

controller 에서 발생한 변경에서 Interactor 를 보호하는 것도 중요하지만
그 반대의 경우에도 보호되어야 한다.

# 결론

이 이론은 시스템을 확장 가능하기 쉽게 만들고, 변경으로 영향을 덜 끼치는걸 목표로 함

시스템을 컴포넌트 단위로 분리하고, 
저수준의 변경에서, 고수준을 보호하는 형태로 의존성 계층 구조가 만들어져야 함

# 9장 LSP: 리스코프 치환 원칙

# 상속을 사용하도록 가이드하기

```kotlin
interface License {
	fun calcFee() {}
}

class PersonalLicense: License {
	override fun calcFee(){}
}

class BusinessLicense: License {
	val users: User

	override fun calcFee(){}
}

class Billing: Activity{
	val license = License()
	fun onCreate(){
		...
		license.calcFee()
	}
}
```

LSP 를 준수하는 설계

Billing 애플리케이션 행위가 License 하위 타입 중 무엇을 사용하는지에 대해 의존하지 않기 때문

# 정사각형/직사각형 문제

개발관점에서 Square(정사각형) 은 Rectangle(사각형) 의 하위 타입이 될 수 없음 (...?)

사각형은 높이, 너비가 독립적으로 변경이 가능하지만, 정사각형은 불가능하기 때문

```kotlin
Rectangle r = ...
r.setWidth(5)
r.setHeight(2)
assert(r.area() == 10)
```

위의 식은 ... 이 정사각형 객체 생성일 경우 무조건 실패한다 (아마 4 또는 25이어야 될 것이다)

위의 문제를 해결하려면 조건문을 넣으면 되지만, 
Billing 위치에 이를 넣을경우 타입에 따른 안전한 실행이 불가능하다

# LSP와 아키텍처

처음에 LSP : 상속을 사용하도록 가이드하는 방법정도로 간주되었음

지금의 LSP : 인터페이스와 구현체로도 확장됨

LSP 를 이해하려면 이 원칙을 어겼을때 시스템상 어떤 문제가 발생하는지 관찰하면 된다.

# LSP 위배 사례

ex. 택시 파견 서비스를 통합하는 애플리케이션

1. 택시 업체 신경쓰지 않고, 자신의 상황에 가장 적합한 택시를 찾음
2. 이용할 택시를 결정하면 시스템은 REST 서비스를 통해 선택된 택시를 고객 위치로 파견
3. 택시 파견 REST 서비스의 URI 가 운전기사 데이터베이스에 저장되어 있음
4. 기사를 선택하면 해당 기사의 레코드로부터 URI 정보를 읽고 해당 기사를 고객에게 전달
(ex. purplecab.com/driver/BOB)

택시업체별로 pickupAddress, pickupTime, destination 를 동일한 방식으로 가져가야 함

만약 특정 업체에 대한 부가조건이 붙는다면 

1. 가장 간단한 방법
조건문 넣기
2. 아키텍처를 고려한 방법
파견 URI 를 키로 사용하는 설정용 DB 를 이용하는 
파견 명령 생성 모듈을 만들어야 할 수도 있음

# 결론

LSP 는 아키텍처 수준까지 반드시 확장해야만 한다.

치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 
상당량의 별도 매커니즘을 추가할 것이다.

(클레임 상세 쪽 약간 수정이 필요할 것 같기도 하다)

# 10장 ISP: 인터페이스 분리 원칙

상황

ex. 다수의 사용자가 OPS 클래스의 오퍼레이션을 사용하는 경우

1. User1 은 op1, User2 는 op2, User3 는 op3 만을 사용
2. OPS 는 정적 타입 언어로 작성된 클래스

문제

User1 의 소스 코드는 op2, op3 을 전혀 사용하지 않아도 이 두개의 메서드에 의존함

op2 코드 변경 시 User1 도 새로 컴파일 후 새로 배포해야 함

해결책

OPS 함수들을 인터페이스 단위로 쪼개어 해결 가능

(User1 의 소스 코드 → U1ops / User2 의 소스 코드 → U2ops ... )

위와 같이 작성 시 OPS 에 의존하지 않으며, 
OPS 에서 발생한 변경이 User1 과는 전혀 상관없는 변경이라면 

→ User1 을 컴파일하고 다시 배포하는 상황은 존재하지 않음

# ISP와 언어

코드는 include, use, import 등으로 인해, 소스코드 의존성이 발생하고 재컴파일이 강제된다.

동적 파일 언어에서는 존재하지 않지만 런타임에 추론이 발생
소스코드 의존성이 아예 없고 재컴파일이 필요 없음

Java 의 독특함

시그니처는 그대로인 채 구현 코드만 변경되었다면 그마저도 다시 컴파일할 필요가 없음

자바는 비 final, 비 private 인스턴스 변수에 대해서는 
호출할 정확한 메서드를 런타임에 결정하는 늦은 바인딩을 수행함

컴파일 타임에는 어디에 존재하는지만 파악

ISP 는 언어에 따라 영향받는 정도가 다름

# ISP와 아키텍처

필요 이상으로 많은 걸 포함하는 모듈에 의존하는 건 해로운 일

→ 불필요한 재컴파일을 강요하기 때문

ex. S 시스템에 F 라는 프레임워크를 도입하고, F는 D DB 를 사용함

S System → F Framework → D DB : 문제가 있는 아키텍처

이유

1. F Framework 에서 불필요한 기능이 D DB 에 포함될 경우 
D 내부가 변경되면 F를 재배포해야 할 수도 있고 S까지 재 배포해야 할수도 있음
2. D 내부의 기능에 어떠한 문제가 생기면 S 와 F 에 무조건 영향을 끼침

# 결론

불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠짐

# 11장 DIP: 의존성 역전 원칙

유연성이 극대화된 시스템

- 소스코드 의존성이 추상에 의존하며 구현체에는 의존하지 않는 시스템
- use, import, include 구문은 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 함
(실제 구현체에는 절대 의존하면 안됨...)
- 소스코드 의존 관계에서 구현체 모듈을 참조하면 안됨
(왜 클린아키텍처에서 Impl 을 만들고 인터페이스를 참조하는지 알겠다)

하지만 비현실적

- 구체적인 많은 장치에 반드시 의존하게 됨
- 운영체제와 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편
- ex. Java String
    
    구현체 (의존성을 벗어날 수 없음)
    
    의존성은 벗어날 수 없지만 매우 안정적
    
    String 클래스가 변경되는 일은 거의 없고 있더라도 엄격히 통제함
    

타협안 : 변동성이 큰 구체적인 요소는 인터페이스화하여 관리하자 (Repository 등)

# 안정된 추상화

추상 인터페이스에 변경이 생기면 → 이를 구체화한 구현체들도 따라 수정해야 함

구현체에 변경이 생기면 → 추상 인터페이스 변경하지 않음

많은 사람들은 실제 인터페이스의 변동성을 낮추기 위해 많이 애쓴다
인터페이스를 변경하지 않고도, 구현체에 기능을 추가할 수 있는 방법을 찾는다.

안정된 소프트웨어 아키텍처 : 변동성이 큰 구현체 대신 안정된 추상 페이스를 선호함

## 변동성이 큰 구체 클래스 참조하지 않기

대신 추상인터페이스 참조하기

이 규칙은 언어가 정적이든 동적이든 상관없음

## 변동성이 큰 구체 클래스로부터 파생하지 않기

대신 추상 인터페이스를 참조하기

상속은 소스코드의 모든 관계 중에서 가장 강력하면서도 뻣뻣함 (그러므로 신중히 사용할 것)

## 구현체 함수를 오버라이드 하지 않기

구현체 함수는 소스코드 의존성을 필요로 함

구현체 함수를 오버라이드 하면 이러한 의존성을 제거할 수 없게 되고 그 의존성을 상속함
(음 Kotlin Util 함수에 그동안 전역으로 사용했던 것도 그러면 문제가 되려나)

차라리 추상함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 함

## 구체적이며 변동성이 크면 절대 그 이름 언급하지 않기

위의 말과 똑같은 말

# 팩토리

위의 내용으로 말미암아 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야 함

sol : 추상 팩토리를 사용함

→ interface 만을 다루게 함으로서 실질적으로 구현체를 다루지 않도록 함

→ 위와 같이 작성함으로서 소스코드 의존성은 추상적인 쪽을 향하게 됨

인터페이스와 구현체 클래스 사이의 경계선(이하 곡선)은 시스템을 두가지 컴포넌트로 분리함

→ 추상 컴포넌트(고수준 업무 규칙), 구체 컴포넌트(업무 규칙을 다루기 위한 모든 세부사항)

제어 흐름은 소스 코드 의존성과는 정 반대 방향으로 곡선을 가로지름 (구현체를 사용함)

→ 소스 코드 의존성은 제어 흐름과는 반대 방향으로 역전 
     (구현체를 사용하되 인터페이스를 사용 = 의존성 역전)

# 구체 컴포넌트

구현체에는 구체적인 의존성이 최소 하나 존재하고, 따라서 DIP 에 위배된다
(ex. RepositoryImpl 은 DataSourceImpl 을 소유함)

위배된 내용을 모두 없앨수는 없지만 DIP 를 위배하는 내용들을 한 곳에 모을수는 있음
(이를 통해 시스템의 나머지 부분과는 분리가 가능)

최소 하나의 구체는 가질수밖에 없게 됨
(ex. Impl 구현체를 선언하여 인터페이스 타입으로 전역 변수에 저장)

# 결론

DIP 는 자주 접하고, 가장 눈에 드러나는 원칙

상기 언급한 곡선은 아키텍처의 경계

곡선을 경계로 추상적인 엔티티가 있는 쪽으로만 향하는 것을 의존성 규칙이라 명명함
