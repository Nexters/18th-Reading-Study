# 15장 아키텍처란?

권력과 신비로움? 누군가는 꿈꿀 수 있는 이상적인 직업?

소프트웨어 아키텍트

1. 프로그래머
2. 고수준의 문제에만 집중해야 하는 건 아님
3. 최고의 프로그래머이자 앞으로도 프로그래밍 작업을 맡을 뿐 아니라
나머지 팀원들이 생산성을 극대화할 수 있는 설계를 하도록 방향을 이끔
4. 프로그래밍 작업은 지속적으로 참여

소프트웨어 시스템의 아키텍쳐

1. 시스템을 구축했던 사람들이 만들어낸 시스템의 형태
2. 아키텍처 안에 담긴 SW 시스템이 쉽게 개발, 배포, 운영, 유지보수 되도록 만들어짐
3. 가능한한 많은 선택지로, 가능한한 오래 남겨두는 전략을 따라야 함
4. 소프트웨어 아키텍처의 목표는 시스템의 동작 여부와는 관련이 멈
(형편 없는 아키텍처도 동작은 함)
5. 운영보다는 배포, 유지보수, 개발 과정에서 어려움이 있음

좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하고, 쉽게 유지보수하고, 쉽게 배포하게 해줌

# __개발

팀원이 작을 경우, 모노리틱 시스템으로도 운영 가능
(오히려 아키텍처가 방해가 될 수 있음)

팀원이 많을 경우 (7명씩으로 구성된 총 5팀), 
잘 설계된 컴포넌트 단위로 분리하지 않으면 개발이 진척되지 않음

팀별 단일 컴포넌트 아키텍처가 시스템을 배포, 운영, 유지보수하는 데 최적일 가능성은 거의 없음

순전히 일정에만 쫒겨일한다면 이렇게 될 것

시스템 아키텍처는 `개발팀이 시스템을 쉽게 개발할 수 있도록` 해야함

# __배포

배포 비용이 높을수록 시스템의 유용성은 떨어짐

시스템을 `단 한번에 쉽게 배포할 수 있도록` 만드는데 그 목표를 두어야 함

마이크로서비스 아키텍처

- 컴포넌트 경계가 뚜렷해지고 인터페이스도 대체로 안정화되므로 
시스템을 매우 쉽게 개발할 수 있다고 판단했을 확률이 높음
- 하지만 배포 시기 시 마이크로서비스들을 서로 연결하기 위한 설정, 작동순서 결정 등
오히려 오작동이 발생할 원천이 생길수도 있음

더 적은 서비스를 사용, 서비스 컴포넌트와 프로세스 수준의 컴포넌트를 하이브리드 형태로 융합하며 
좀 더 통합된 도구로 사용해 상호 연결을 관리했어야 함 → ??

# __운영

개발, 배포, 유지보수에 미치는 영향보다는 덜 극적

하드웨어 단순 투입으로도 해결 가능

하지만 아주 연관이 없지만은 않음 - 시스템을 운영하는 데 필요한 요구도 알려줌

개발자에게 시스템의 운영 방식을 잘 드러내준다고 할 수 있음

유스케이스, 기능, 시스템의 필수행위를 1급 엔티티로 격상시킴

→ 솔직히 잘 이해되지 않음

# __유지보수

유지보수는 소프트웨어 시스템에서 가장 비싼 작업

탐사와 이로 인한 위험 부담

탐사
기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때 
소프트웨어를 파헤쳐 어디를 수정해야 하는지, 어떤 전략을 써야할지를 결정할 때 드는 비용

시스템을 컴포넌트로 분리하기

안정된 인터페이스를 두어 격리하기 
(최근 프로젝트에서 차트 로직 및 변수를 인터페이스로 분리해서 기능 추가에 별다른 어려움을 겪지 않았음)

# __선택사항 열어 두기

소프트웨어는 행위적 가치, **`구조적 가치`**를 지님

`구조적 가치` : 소프트웨어를 유연하게 만듬

소프트웨어를 만든 이유 : 기계의 행위를 빠르고 쉽게 변경 가능

유연성은 시스템의 형태, 컴포넌트의 배치 방식, 컴포넌트가 상호 연결되는 방식에 크게 의존함

소프트웨어를 부드럽게 만드는 방법

1. 선택사항을 가능한한 많이 (하나의 함수가 다양한 작업을 하도록?)
    
    선택사항 : 중요치 않은 세부사항
    
2. 그리고 가능한 한 오랫동안 열어두는 것 (주석?)

(K 모 특정 개발자가 추구하는 방법인 것 같기도 하다)

모든 소프트웨어 시스템 = 정책 + 세부사항

1. 정책
    
    모든 업무 규칙과 절차를 구체화
    
    시스템의 진정한 가치가 살아 있는 곳
    
2. 세부사항
    
    사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소
    
    정책이 가진 행위에는 조금도 영향을 끼치지 않음
    
    입출력 장치, DB, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등
    

아키텍트의 목표

시스템에서 정책을 `가장 핵심적인 요소로 식별`하고
세부사항은 `정책과 무관하게 만들 수 있는 형태의 시스템을 구축`하는 데 있음

이로 인해 세부사항을 결정하는 일은 미루거나 연기할 수 있게 됨?

ex. 

1. 개발 초기에는 DB 시스템을 선택할 필요가 없음 (관계형이든, 분산형이든 다 동작하도록)
2. 개발 초기에는 웹 서버를 선택할 필요가 없음 (웹을 통해 전송할 것인지 조차도 정할 필요 없음)
3. REST, 마이크로서비스, SOA 다 필요 없음
4. 처음엔 의존성 주입을 쓸 필요가 없음

→ 고수준의 정책은 세부적인 것에 신경을 쓸 필요가 없다.
     세부사항에 신경쓰지 않고 고수준의 정책을 만드는 데 집중하자 (세부사항은 나중으로 미루자)

→ 미리 정하지 않음으로서 실험을 해볼 수 있고, 더 많은 것을 시도할 수 있다.

좋은 아키텍처는 결정되지 않은 사항의 수를 최대화한다.

# __장치 독립성

장치 종속성

- 코드를 입출력 장치와 직접 결합
    
    ex. 프린터 인쇄 시 해당 프린터를 제어하는 입출력 명령어 직접 사용해서 코드를 작성
    
    ex. 카드 판독기를 직접 조작하는 코드를 작성
    
- 데이터 무결성이 대두되면서 실수라는 걸 알게 됨

오늘날 운영체제

입출력 장치를 소프트웨어 함수로 `추상화`함

해당 함수는 단위 레코드를 처리함

프로그램은 운영체제의 서비스를 호출함

해당 서비스가 추상화된 단위 레코드 장치를 처리함

→ 동일한 프로그램을 아무런 변경 없이 카드에서 읽고 쓰거나 테이프에서 읽고 쓸 수 있게됨

     (개방 폐쇄의 원칙)

안드로이드에선 뭘 예로 생각할 수 있을까?

지금 프로젝트에서 차트가 유독 기억에 남는다.
홈 화면에서 사용되던 차트를, BottomSheet 에서도 활용하면서 
일일히 구현을 그대로 복붙에서 똑같은 코드를 만들었다

그 직전에 차트의 ViewModel 종속성을 뺀 적이 있었는데 이게 정말 큰 도움이 되었었다.

이런 과정에서 얻은 생각은 이랬다
좀더 많은 함수와 변수를 추상화 했어야 했고, 함수를 변수화해서 넘기는 건 너무나 사기 기능이다.

아마 차트를 다른 화면에서 사용하는 걸 확장이라 할 수 있을 것 같고
추상화된 함수는 각 OS(OS X, WIndow 등) 의 기본 추상화 함수로 정리가 된다.

# __광고 우편

이름과 주소레코드만 바꿔 지정된 종이 템플릿에 찍기

- 라인 프린터 → 자기 테이프 및 오프라인 프린터 활용 ( + 테스트는 컴퓨터에 직접 연결된 라인프린터)
- 많은 시간 절약

정책 : 이름과 주소 레코드에 대한 서식

세부사항 : 장치

정책에 맞춰 세부사항을 바꿀 수 있어야 한다.

# __물리적 주소 할당

지역 트럭 운정수 조합을 위한 대규모 회계 시스템

- 소프트웨어가 디스크의 상세 구조를 알도록 만듬 ( = 하드 코딩)
- 스케일 업시 하드웨어의 정보를 모두 알 수 있도록 해야 함
- 상대주소를 통해 하드웨어로부터 분리시킴

이런 경우도 있었구나... 

# __결론

좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려냄

정책이 세부사항과 결합되지 않도록 함 
(누가 안드도 파이썬으로 할 수 있게 만들...? 그럼 세부사항(Kotlin) 고민할 필요없어짐)

세부사항을 최대한 뒤로 미루어라

# 16장 독립성

# __유스케이스

시스템의 아키텍처는 시스템의 의도를 지원해야함

ex. 장바구니 애플리케이션

- 장바구니와 관련된 유스케이스를 지원해야 함

아키텍처는 시스템의 행위에 그다지 큰 영향을 주지 않음

- 행위와 관련하여 아키텍처가 열어둘 수 있는 선택사항은 거의 없음
- 행위를 명확히 하고 외부로 드러내며 이를 시스템이 지닌 의도를 
아키텍처 수준에서 알아볼 수 있게 만들어야 함 → ???
- 클래스, 함수 또는 모듈로서 아키텍처 내에서 핵심적인 자리를 차지함
+ 자신의 기능을 분명하게 설명하는 이름을 가질 것

# __운영

시스템이 초당 10만명의 고객을 처리해야 한다면, 
아키텍처는 이 요구와 관련된 각 유스케이스에 걸맞는 처리량과 응답 시간을 보장해야 함

아키텍트는 각 상황에 유연하게 대처할 수 있도록 작성해야함

특정 기능을 알면서 써야하는 이유에 대해 언급한 것 같기도 하다.

# __개발

시스템을 설계하는 조직이라면 어디든지, 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.

잘 격리되어 독립적으로 개발가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 함

# __배포

목표는 즉각적인 배포

시스템이 빌드된 후 즉각 배포될 수 있도록 해야 함

시스템을 컴포넌트 단위로 적절하게 분할하고 격리시키는 게 중요

마스터 컴포넌트는 시스템 전체를 하나로 묶고, 감 컴포넌트를 올바르게 구동, 통합, 관리해야 함

# __선택사항 열어놓기

우리는 모든 유스케이스를 알 수 없다

운영 제약사항, 팀구조, 배포 요구사항도 알 수 없다

생명주기의 단계를 하나씩 거쳐가면서 이 사항들도 바뀐다

몇몇 아키텍처 원칙은 도움이 될 수 있다 (객체지향 5원칙 또 나오나요)

선택사항을 열어두어 언제든 쉽게 변경할 수 있도록 해야함

# __계층 결합 분리

아키텍처는 시스템의 기본적인 의도는 분명히 알고 있음 (시스템이 뭐하는 시스템인지 알고 있음)

단일 책임 원칙, 공통 폐쇄 원칙을 활용해 
다른 이유로 변경 되는 것들은 분리하고, 동일한 이유로 변경되는 건 묶음

서로 다른 이유로 변경되는 것의 예

1. 사용자 인터페이스가 변경되는 이유
    
    업무 규칙과는 아무런 관련이 없음
    
    유스케이스가 두 가지 요소를 모두 포함한다면 
    뛰어난 아키텍트는 유스케이스에서 UI 부분, 업무 규칙 부분을 서로 분리하고자 할 것
    
    두 요소를 독립적으로 변경이 가능해지고, 유스케이스를 분명히 유지 가능
    
2. 카테고리가 다른 업무 규칙
    
    입력 필드 유효성 검사 (애플리케이션 관련 업무 규칙), 계좌 이자 계산(업무 도메인 관련 규칙)
    
    이 두개의 규칙은 다른 속도로, 다른 이유로 변경되므로 분리되어야 함
    

→ 시스템의 나머지 부분으로부터 분리하여 독립적으로 변경할 수 있도록 해야함

그래서 단일 책임 원칙, 공통 폐쇄 원칙을 많이 물어보는구나

모바일에서 위의 두 개를 적극 활용하는 예를 리서치해봐야겠다.

# __유스케이스 결합 분리

1. 유스케이스는 시스템을 분할하는 매우 자연스러운 방법
    
    ex. 주문 입력 시스템에서 `주문을 추가`하는 유스케이스와 `주문을 삭제`하는 유스케이스
    
           개발 속도가 다르고, 다른 이유로 변경될 수 있다.
    
2. 유스케이스는 시스템의 수평적인 계층을 가로지르도록 자른 수직으로 좁다란 조각
    
    각 유스케이스는 UI 일부, 특화업무규칙 일부, 독립적 업무 규칙 일부, DB 일부 등을 사용
    
    시스템을 수평적 계층으로 분할하면서 동시에 
    해당 계층을 가로지르는 얇은 수직적인 유스케이스로 분할할 수 있음 → ???
    
    [위에서 언급한 내용의 예](https://www.notion.so/e1d23623d84b43b7b25eb19ed48f5847)
    
    분석
    
    1. 결합을 분리하기위해 각 유스케이스에 맞춰 UI 를 분리함 (나머지도 마찬가지)
    (수평적 관점)
    2. 아래까지 수직으로 내려가면서 유스케이스는 각 계층에서 겹치지 않음
    (수직적 관점)
    
    DB 에 취소선을 그어가면서 Repository 를 하나로 두고, 업무 로직 계층을 함수로 둔 이유
    
    클린 아키텍처의 예로 모든 로직 자체를 클래스화해서 관리하는 경우도 있긴하다
    (실제 그렇게 작성해보기도 했다)
    
    너무 분리하면 독립성은 높아지지만 그만큼 뻣뻣한 코드가 된다고 생각이 들어 난 이렇게 두어봤다
    
    진짜 저 2개밖에 로직이 없는 경우엔 
    하나의 파일에서 함수형태로 관리해도 가독성이나 로직을 찾는덴 무리가 없다고 느껴진다.
    

서로 다른 이유로 변경되는 요소들의 결합을 분리하면 
기존 요소에 지장을 주지 않고 새로운 유스케이스를 추가시킬 수 있음

유스케이스를 뒷받침하는 UI, 데이터베이스를 묶어
각 유스케이스가 UI 와 데이터베이스의 서로 다른 관점을 사용할 시 
새로운 유스케이스를 추가하더라도 기존 유스케이스에 영향을 주는 일은 거의 없을 것

UseCase 를 클래스 형태로 만들어 직접 invoke 하는 형태로 처리하면 
영향을 주는일이 거의 없긴 할 것이다

또 그걸 쉽게 사용하고 UseCase 의 구현형태는 알 수 없도록 façade 패턴을 사용한다 하면 
으... 머리아프다.

관점지향 프로그래밍 (AOP)

횡단 관심사를 분리하여 모듈화를 높임

코드 자체를 수정하지 않고 기존의 코드에 추가하는 방식(?)으로 구현

ex. 예외처리(?!), 로깅(!!), 인증, 트랜젝션

# __결합 분리 모드

결합이 분리될 시 장점

1. 높은 처리량을 보장하는 유스케이스와, 낮은 처리량으로도 충분한 유스케이스가 이미 분리되어 있음
2. UI 와 DB 가 업무 규칙과 분리되어 있을 시, UI 와 DB는 업무규칙과 다른 서버에서 실행될 수 있음
    
    (높은 처리량이 필요한 유스케이스는 여러 서버로 복제하여 실행 가능)
    
    ( = 제약이 없어짐)
    

결합을 분리할 때 적절한 모드를 선택해야 함

ex. 분리된 컴포넌트를 서로 다른 서버에서 실행해야 할 경우, 
       이들 컴포넌트가 단일 프로세서의 동일한 주소공간에 상주하는 형태로 만들어지면 안됨

분리된 컴포넌트는 반드시 독립된 서비스가 되어야하고, 일종의 네트워크를 통해 서로 통신해야함
(= 마이크로서비스)

우리는 때때로 컴포넌트를 서비스 수준까지도 분리해야함

이전에 배웠다시피 우리는 선택권을 열어두어야 함

# __개발 독립성

컴포넌트가 완전 분리되었다면 팀 사이의 간섭은 줄어듬

ex. 업무 규칙이 UI 를 알지 못하면 UI 에 중점을 둔 팀은 업무 규칙에 중점을 둔 팀에 그다지 영향을 줄 수 없음

ex. 주문 추가 팀이, 주문 제거 팀에 영향을 줄 가능성은 거의 없음

# __배포 독립성

배포 측면에도 고도의 유연성 생김

새로운 유스케이스를 추가하는 일 = 시스템의 나머지는 그대로 둔 채 새로운 jar 파일 및 서비스 몇 개 추가하는 일

# __중복

SW 에서 중복은 일반적으로 나쁜 것

진짜 중복

- 한 인스턴스가 변경되면 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야함

우발적인 중복

- 중복으로 보이는 두 코드 영역이 각자의 경로로 발전한다면 두 코드는 진짜 중복이 아님
(프로필 화면과 1:1 대응에서의 이미지 업로드는 겹치는 게 어쩌면 아니었을까...?)

진짜 중복일까? 우발적 중복일까?

- 사실 중복이 아닐수도 있을 것이다.
- 진짜 중복만 없애도록 하라
- ViewModel 을 별도로 만드는 일은 계층간 결합을 분리하여 유지하는데도 도움이 될 것이다

# __결합 분리 모드(다시)

계층과 유스케이스의 결합을 분리하는 방법은 다양

1. 소스코드 수준에서 분리
    
    소스 코드 모듈 사이의 의존성을 제어
    
    하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 만들 수 있음
    
    모노리틱 구조라고도 부름(?)
    
2. 바이너리 코드 수준에서 분리
    
    jar, DLL, 공유 라이브러리와 같이 배포 가능한 단위들 사이의 의존성을 제어
    
    한 모듈의 소스코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들 수 있음
    
    jar, gem, dll 같이 독립적 배포 가능
    
3. 실행 단위 수준에서 분리
    
    의존하는 수준을 데이터 구조 단위까지 낮춤
    
    순전히 네트워크 패킷을 통해서만 통신하도록 만듬
    
    (ex. 서비스 또는 마이크로 서비스)
    

프로젝트 초기에는 어떤 모드가 정답인지 알 수 없음

나중엔 **`실행 단위 수준에서 분리`**가 필요할 수 있음

단순한 건 **`실행 단위 수준에서 분리`** 선택 (하지만 노력, 메모리, 계산량 측면에서 큰 작업이 될 수 있음)

`바이너리 코드 수준에서 분리` 까지만 두고, 개발 배포 운영 문제 증가 시 
`실행 단위 수준에서 분리`를 고려하는 걸 추천

좋은 아키텍처는 처음에 모노리틱 구조이더라도, 이후에는 서비스 수준까지 성장할 수 있도록 만들 수 있어야함
거꾸로 뒤돌릴수도 있어야 함

개인적으로, 회사원 모두가 이해하고 쉽게 개발, 유지보수가 가능한 구조가
진정한 clean 구조라는 생각이 있다.

# 17장 경계: 선 긋기

SW 아키텍처는 선을 긋는 기술

선

- 경계라고 표현하기도 함
- 소프트웨어 요소를 서로 분리하고 경계 한편에 있는 요소가 
반대편에 있는 요소를 알지 못하도록 막음
- 선이 그어지는 시점은 제각각
- 오랫동안 결정을 연기시키기 위해, 핵심업무로직을 오염시키지 못하도록 하기 위해 선을 그음

아키텍트의 목표 : 필요한 시스템을 만들고 유지하는 데 드는 인적자원을 최소화하는 것

결합`coupling` 

- 결합 (특히 일찍 내려진 결정에 의한 결합)은 인적자원의 효율을 떨어뜨림
- 이른 결정이라 함은, 시스템의 업무 요구사항, 유스케이스와 아무런 관련이 없는 결정
    
    ex. 프레임워크, DB, 웹 서버, 유틸리티 라이브러리, 의존성 주입에 대한 결정 
    
- 이러한 결정이 부수적이며 결정을 연기할 수 있는 게 가장 좋음

좋은 시스템 아키텍처는 이러한 결정을 최후의 순간에 내릴 수 있게함

결정에 대한 영향력 또한 크지 않음

# __두 가지 슬픈 이야기

리치 시스템을 경계할 것

P사 : 단일 서버로 운영해도 되는 내용을, 세 가지 인스턴스로 나누는 등 리치 시스템을 만들어 개발 비용 증가

W사 : SOA 를 너무 일찍 채택해서 망한 케이스

# __FitNesse

위키 페이지

우리만의 웹 서버를 직접 작성하기로 하여, 
기본 뼈대만 갖춘 웹 서버는 어떤 웹 프레임워크를 사용할건지에 대한 결정을 **`늦출 수 있게 됨`**

DB 에 대해 고민하지 않음으로써,
데이터 접근 영역, 데이터 저장소 영역 사이에 인터페이스를 추가하는 간단한 방식을 먼저 사용하고
DB 사용에 대한 결정을 **`늦출 수 있게 됨`**

당장 개발하지 않는 기능들은 Stub (TODO) 상태로 둠
이후 직접 관리하게 되면서 실제로 데이터에 접근하는 로직을 구현

1년 내에 기능들을 차례대로 작성하고
MySQL 을 고민하다가 결국 폐기시킴으로서 `늦출 수 있게 됨`에 대한 보상을 얻음

선이 준 도움

1. 업무 규칙과 DB 사이에 경계선을 그음
2. 경계선을 통해 업무 규칙은 DB 에 관해 어떤 것도 알지 못하게 됨

# __어떻게 선을 그을까? 그리고 언제 그을까?

관련이 있는 것과 없는 것 사이에 선을 그을 것
ex. GUI 와 업무 규칙 사이에 선을 긋기, DB 와 업무 규칙 사이에 선을 긋기

DB 는 업무 규칙이 간접적으로 사용될 수 있는 도구일뿐 ~~업무 규칙을 구체화한 것~~이 아님

아래의 `DB 인터페이스`를 통해 Business Rule 은 DB 를 모르게 할 수 있음
Business Rule ←**`DB 인터페이스`**→ DB Access(`DB 인터페이스` ****Impl**)** → DB

왜 Repository 를 만들고 Impl 을 따로 구현하는지 이해가 될 것이다
하지만 이것도 너무 나눠지게 되면 리치 개발이라는 생각이 개인적으론 든다.
(이거 설계 및 보일러플레이트 코드 작성으로 정신없어짐)

하지만 DB 는 Business Rule 을 알고 있음
(DB 는 Business Rule 이 요청한 호출을 DB 쿼리 언어로 `변환하는 코드`를 담고 있으며, 
`변환하는 코드` 가 DB 가 Business Rule 에 대해 알고 있다는 증거)

# __입력과 출력은?

개발자와 고객은 종종 시스템의 정의를 혼란스러워함
ex. GUI 를 시스템이라고 생각하며, GUI 가 동작하는 모습을 반드시 보고 싶어함

이와 같은 입력과 출력에 신경쓰는 오류를 범하지 말아야 함
ex. 비디오 게임이 화면에 출력되지 않더라도 모델은 게임에서 발생되는 모든 이벤트를 모델링하며 역할을 수행함

중요한 건 `업무규칙`

[위에서 언급한 DB 인터페이스 개념](https://www.notion.so/17-cef46fb52aa6463ab8d1d67ddaf494f3)과 비슷하게 
GUI 는 Business Rule 을 알고 있지만, Business Rule 은 GUI 를 모름

# __플러그인 아키텍처

그러면 GUI, DB 가 Business Rule 을 알고 있고, Business Rule 은 나머지를 모르고 있는 그림이 만들어짐

# __플러그인에 대한 논의

VS ← ReSharper 의 관계 : ReSharper 는 노예수준

종속성으로 업무규칙이 깨지는 걸 막기 위해서는 경계는 필수이다.

선 긋기는 단일 책임 원칙하고도 연관이 있는 내용

# __결론

경계선을 그으려면 먼저 시스템을 컴포넌트 단위로 분할해야 함

그으는 꿀팁

1. 일부 컴포넌트는 `핵심 업무 규칙`에 해당
2. 핵심 업무와는 직접 연관이 없지만 필수기능을 포함하는 나머지 컴포넌트는 `플러그인`에 해당
3. 컴포넌트 사이의 화살표가 핵심 업무를 향하도록 컴포넌트의 소스를 배치함

의존성 역전 원칙, 안정된 추상화 원칙을 응용한 것이기도 함

의존성 화살표는 저수준 세부사항 → 고수준 추상화를 향하도록 배치할 것

# 18장 경계 해부학

시스템 아키텍처는 일련의 소프트웨어 컴포넌트와 그 컴포넌트를 구분하는 경계에 의해 정의됨

# __경계 횡단하기

런타임에 경계를 횡단한다 = 경계 한 쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일 → ???

적절한 위치에서 경계를 횡단하는 비결은 소스코드 의존성 관리에 있음

왜 소스코드일까?

소스 코드 모듈 하나만 변경되어도 
이에 의존하는 다른 소스코드 모듈도 변경하거나, 다시 컴파일해서 배포해야 할 수 있기 때문

경계는 일종의 방화벽

# __두려운 단일체

가장 단순한 아키텍처 : 물리적으로 엄격하게 구분되지 않는 형태 
(함수와 데이터가 단일 프로세서에서 같은 주소공간을 공유하며 나름의 규칙은 있음)
= 단일체, 소스수준 분리 모드, 모노리틱

단일체는 커다란 하나의 파일을 배포하므로 경계선이 없음 (= 배포관점에서 눈에 보이지 않음)

모노리틱에서는 정적 다형성 (ex. 제네릭, 템플릿 등) 을 이용해 내부 의존성을 관리

1. 객체지향 개발이 아주 중요한 패러다임이 될 수 있던 요인
2. 포인터에서 탈출하고 컴포넌트를 분리하려는 시도를 할 수 있게 된 요인

가장 단순한 형태의 경계 횡단 : 저수준 클라이언트 → 고수준 서비스로 향하는 함수 호출

예 1. 왼쪽에서 오른쪽으로 경계를 횡단하는 제어흐름

Client → Service

             ↘︎      ↓

                    Data

         경계선

1. Client 는 Service 의 `f()` 를 호출
2. Client 는 Data 인스턴스를 전달 (여기서 Data 는 고수준 클라이언트)
3. 고수준 클라이언트가 저수준 서비스를 호출해야 할 시, 동작 다형성을 활용해 제어흐름을 역전
(Data)

예 2.  왼쪽에서 오른쪽으로 경계를 횡단하는 제어 흐름

Client → Service ← ServiceImpl 

   ↓                       경계선

Data                                ⏎ 

1. 고수준 클라이언트인 Client 는 Service 인터페이스를 상속받는 ServiceImpl 의 `f()` 호출
2. Data 또한 호출하는 쪽에 위치함

예1, 예2 를 통해 정적 링크된 모노리틱 구조도 이런 규칙적인 방식을 가질 수 있고
이는 개발, 배포, 테스트에 도움이 됨

고수준 컴포넌트는 저수준 세부사항으로부터 독립적으로 유지됨

단일체 내에서 컴포넌트간 통신은 값싸다 (단순 함수호출이므로)

컴파일과 정적 링크 작업을 수반하므로, 모노리틱에서 컴포넌트는 소스코드 형태로 전달됨 → ???

# __배포형 컴포넌트

동적 링크 라이브러리를 통해 아키텍처의 경계가 물리적으로 드러날 수 있음

닷넷 DLL, jar 파일, 유닉스 공유 라이브러리가 그 예

배포 수준 결합 분리 모드에 해당함

배포 가능한 단위를 좀 더 편리한 상태로 묶는 일에 지나지 않음
(WAR 파일, 디렉터리 형태로 묶음)

왠만한 전략들은 단일체와 동일

단일체와 마찬가지로 함수호출에 지나지 않으므로 매우 값싸며, 
동적 링크, 런타임 로딩 등의 변수가 있지만 경계를 가로지르는 통신은 매우 빈번할 것

# __스레드

단일체, 배포형 모두 활용 가능

실행 계획과 순서를 체계화 하는 방법에 가까움

# __로컬 프로세스

명령행이나 시스템 호출을 통해 생성

동일한 프로세서, 하나의 멀티코어 시스템에 속한 여러프로세서들에서 실행됨
각각의 독립된 주소공간에서 실행됨

운영체제 호출, 데이터 마샬링/언마샬링, 프로세스간 문맥 교환, 소켓, 메일박스, 메시지큐 등 
운영체제 차원의 통신 기능을 활용하여 서로 통신

일종의 최상위 컴포넌트라 봐도 무방

저수준 내용을 고수준이 알면 안됨

# __서비스

가장 강한 물리적 형태를 띄는 경계

모든 통신이 네트워크를 통해 이뤄진다 가정함

빈번하게 통신하는 일을 피해야 함 (API 통신이 될수도 있으니까)

고수준 서비스에는 저수준 서비스를 특정짓는 어떤 물리적인 정보(ex. URI 등) 도 포함되면 안됨

# __결론

단일체를 제외하면 저 위의 경우 중 하나의 아키텍트를 가지고 있음

한 시스템 안에서도 빈번한 로컬 경계와 지연을 중요하게 고려해야 하는 경계가 혼합되어 있음

# __결론

시스템의 결합 분리 모드는 시간이 지나면서 바뀌고, 변경을 예측하여 무리없이 반영할 수 있도록 해야함

# 19장 정책과 수준
소프트웨어 시스템 : 정책을 기술한 것

컴퓨터 프로그램 : 각 입력을 출력으로 변환하는 정책을 상세하게 기술한 설명

대다수의 주요 시스템에서 하나의 정책은 
이 정책을 서술하는 여러개의 조그만 정책들로 쪼갤 수 있음

ex. 집계와 관련된 업무 규칙을 처리하는 방식을 서술하는 정책 
       (앱에도 회원, 상품 등 각 항목마다 정책이 있다)

아키텍처 개발 기술에는 `정책을 신중하게 분리`하고, 정책 변경 양상에 따라 `정책을 재편성`하는 일도 포함됨

정책을 신중하게 분리

1. 동일한 이유로, 동일한 시점에 변경되는 정책은 동일한 컴포넌트에 속해야 함
2. 다른 이유, 다른 시점은 다른 컴포넌트로 분리되어야 함

정점 : 동일한 수준을 나타내는 컴포넌트

간선 : 컴포넌트 사이의 의존성

의존성의 예 : Java 의 import, C# 의 using, 루비의 require 구문 등

의존성의 방향이 컴포넌트의 수준을 기반으로 연결되도록 만들어야 함 
(= 저수준 컴포넌트가 고수준 컴포넌트를 의존하도록 해야 함)

# __수준

입력과 출력까지의 거리

입력과 출력 모두로부터 멀수록 정책의 수준은 높아짐

입력과 출력을 다루는 정책은 시스템에서 최하위 수준에 위치함

예 1. 간단한 암호화 프로그램

입력 장치에서 문자를 읽어, 테이블을 참조하여 문자를 번역한 후, 번역된 문자를 출력 장치로 기록

도식화 형태로 표현한다면

        문자       문자

        →          →

문자 읽기 `→` 번역 `←` 문자 쓰기

프로그램을 제대로 설계했다면 `블록 처리` 된 화살표는 점선이 되어야 함

특징

1. 번역 컴포넌트는 가장 고수준의 컴포넌트 (입력과 출력에서 가장 멀리 떨어져 있기 때문)
2. 데이터 흐름과 소스코드 의존성이 항상 같은 방향을 가리키지는 않음
3. 무조건 데이터의 흐름을 기준대로, 소스코드 의존성을 처리하면 안됨

잘못된 아키텍트

```kotlin
fun encrypt() {
	while(true){
		writeChar(translate(readChar()));
	}
}
```

암호화 함수가 저수준인 읽기와 쓰기 함수에 의존하기 때문에 잘못된 아키텍트

올바른 아키텍트

```kotlin
val charReader: CharReader = ConsoleReader()
val charWriter: CharWriter = ConsoleWriter()

fun encrypt() {
	charWriter.writeChar(translate(charReader.read())));
}
```

별 차이가 없어보이지만 encrypt 함수와 
실질적 입출력을 담당하는 ConsoleReader, ConsoleWriter 는 
CharReader, CharWriter 에 의존한다

입출력에 변화가 생기면 ConsoleReader, ConsoleWriter 을 수정하면 됨
(encrypt() 에는 영향을 1도 끼치지 않음)

단일 책임 원칙 (SRP), 공통 폐쇄 원칙 (CCP) 에 따르면 동일한 시점에 변경되는 정책은 함께 묶임

고수준은 변경이 덜하고, 보다 중요한 이유로 변경됨
저수준은 변경이 빈번하고, 보다 긴급을 요하고 덜 중요한 이유로 변경됨

위 내용은 저수준 컴포넌트가 고수준 컴포넌트에 플러그인 되어야 한다는 관점으로 볼 수도 있음

Encryption <= IO Device

# __결론

객체지향 5원칙을 모두 포함하는 내용이었음

각 원칙이 어떻게 사용되었는지 분석할 필요가 있음

# 20장 업무 규칙
업무 규칙 : 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차

업무 규칙이 실제 무엇인지 잘 이해해야 함

ex. 대출에 N% 이자를 부과 : 은행이 돈 버는 업무 규칙

핵심 업무 규칙

사업 자체에 핵심적이며 반드시 존재해야 하는 `업무 규칙`

보통 핵심 업무 데이터를 요구 (ex. 대출 : 대출 잔액, 이자율, 지급 일정)

핵심 업무 규칙과 핵심 업무 데이터는 본질적으로 결합되어 있고 객체로 만들기 좋음
( = 엔티티)

# __엔티티

컴퓨터 시스템 내부의 객체

핵심 업무 데이터를 기반으로 동작하는 일련의 핵심 업무 규칙을 구체화함

ex. 대출 (Loan)

```kotlin
class Loan {
  val principle: Long
  val rate: Double
  val period: Int
  
  fun makePayment(){}
  fun applyInterest(){}
  fun chargeLateFee(){}
}
```

업무의 대표자로서 독립적으로 존재함

DB, 사용자 인터페이스 등 다른 요소에 의해 오염되면 절대 안됨

어떤 시스템에서도 업무를 수행할 수 있음 (순전한 업무에 대한 것만 있으며 이외의 것은 없음)

# __유스케이스

자동화된 시스템이 사용되는 방법을 설명 (일종의 비즈니스 로직?)

ex. 대출 담당자가 신청자의 신상 정보를 수집하여 검증한 후 
       신청자의 신용도가 500보다 낮다면 대출 견적제공 안하기로 함

아래 내용을 기술함

1. 사용자가 제공해야 하는 입력
2. 사용자에게 보여줄 출력
3. 해당 출력을 생성하기 위한 처리단계

예제로 살펴보기. 신규 대출을 위한 신상정보 수집하기

입력: 이름, 주소, 생일 등

출력 : 사용자 확인을 위한 동일한 정보, 신용도

기본 과정

1. 이름을 받아 검증
2. 주소 생일 등을 검증
3. 신용도를 얻음
4. 신용도가 500보다 낮으면 거절 활성화
5. 높으면 customer 생성 및 LoanEstimation (대출 견적) 을 활성화

특징

1. 엔티티에 대한 참조가 있을수도 있음
    
    위에서는 Customer 엔티티 언급을 통해 참조하며
    은행과 고객의 관계를 결정짓는 핵심 업무 규칙이 Custom 엔티티에 포함됨을 의미함
    
2. 사용자 인터페이스를 기술하지 않음
    
    뭘 통해 전달되는지, 어떤 기반인지 등을 일절 알수 없음
    
    사용자에게 어떻게 보이는지 설명하지 않음
    
3. 객체
    
    업무 규칙, 업무 데이터를 가지고 있음
    
4. 엔티티는 자신을 제어하는 유스케이스에 대해 알지 못함
    
    엔티티는 고수준 개념
    
    엔티티는 유스케이스에 의존하지 않음
    
    의존성 역전 원칙을 준수하는 의존성 방향의 또다른 예
    
5. 저수준
    
    단일 애플리케이션에 특화되어 있으므로 시스템의 입출력과 가까움
    
    (엔티티는 일반화된 개념이므로 멀리 떨어져 있는 편)
    

<aside>
💭 어찌보면 당연한 내용을 풀어쓴건데 
원칙에 입각해서 현재 플젝을 바라볼 수 있게 되는듯하다.

</aside>

# __요청 및 응답 모델

유스케이스는 입력 데이터를 받아 출력 데이터를 생성

유스케이스 객체는 데이터를 사용자나 또 다른 컴포넌트에 주고받는 방식에 대해 전혀 몰라야 함

ex. 유스케이스의 코드가 HTML 이나 SQL 에 대해 몰라야 함

```kotlin
단순한 요청 데이터 구조를 입력으로 받아들이고 
단순한 응답 데이터 구조를 출력으로 반환해야 함
```

요청 및 응답이 의존적이라면 그 모델에 의존하는 유스케이스도 의존성에 결합되어 버림 (종속의 늪)

`엔티티 객체`를 가리키는 참조를 `요청 및 응답 데이터 구조`에 포함하려는 유혹을 받을 수 있음

두 객체의 목적은 완전히 다르며 반드시 분리될 것임

# __결론

업무 규칙은 소프트웨어 시스템이 존재하는 이유

업무 규칙은 집안의 가보

시스템에서 가장 독립적이고, 가장 재사용할 수 있어야 함

# 21장 소리치는 아키텍처

우리의 서비스는 어떤 외침을 하고 있는가?

1. 헬스 케어 시스템이야
2. 루비 온 레일스야
3. MVVM 이야

# __아키텍처의 테마

Object Oriented Software Engineering - 유스케이스 주도 접근법

소프트웨어 아키텍처는 시스템의 유스케이스를 지원하는 구조

아키텍처는 프레임워크에 대한 것이 아님 (그래선 안됨)

유스케이스(업무 규칙)이 중심이 되어야 함

# __아키텍처의 목적

주택은 거주(유스케이스)에 적합해야지, 벽돌 품질(프레임워크)가 중요한 것이 아님

정하더라도 유스케이스를 먼저 만족시키고 해야함

지엽적인 관심사에 대한 결합은 분리시킴 (선택을 열어두고 쉽게 바꿀 수 있도록)

# __하지만 웹은?

단순 전달 매개체일뿐

아키텍처를 고치지 않더라도 어디든지 보낼 수 있어야 함

# __프레임워크는 도구일 뿐, 삶의 방식은 아니다

아키텍처를 유스케이스에 중점을 둔채 그대로 보존할 수 있을지를 생각하기

<aside>
💭 모바일은 언어 종속성이 있어 해당되지 않겠다고 생각하겠지만 전혀 아니다
이는 아키텍처 구조, 라이브러리 등에 대치시켜 생각할 수 있다.

MV 라고 해서 유지보수가 어렵거나, 코드 파악이 어려운 건 아니고
MVVM 이나 MVI 라고 해서 무조건 파악이 쉬운건 아니다

어떤 라이브러리 (ex. ~~Volley~~, Retrofit, only OkHttp3 등) 를 쓰느냐에 따라 
Api 단이 바뀌어야지 Repository 단이 바뀌면 안된다.

</aside>

# __테스트하기 쉬운 아키텍처

유스케이스 전체에 대해 단위 테스트를 할 수 있어야 함

엔티티 객체는 간단한 객체여야함

DB, 웹서버가 있어야만 테스트가 가능해서도 안됨

<aside>
💭 개인적으로 유닛 테스트를 좋아하는 이유가 이것

속도 뿐만 아니라 이런 종속성 없이 체크하는 데 너무나도 편하다

하지만 어쩔 수 없는 경우(UI 테스트)엔 종속성이 필요할 것이다

UI 테스트 속도가 개차반이긴 하지만 지금 activity 에 기반하여 작성되어있는 유닛 테스트는

언젠가 UI 테스트로 바뀌어야 될 것 같다는 생각이다.

</aside>

# __결론

아키텍처는 시스템을 말해야 함

위에서 보았다시피 우리 앱을 말할 때 주제를 이야기해야 함 (헬스 케어 시스템)

누군가 구조에 대해 물어본다면 나중에 결정될 내용이라 쳐낼 수 있어야 함

# 22장 클린 아키텍처

`관심사의 분리`가 주 목적

소프트웨어를 계층으로 분리하여 이 목표를 달성하려 함

아래 요건을 지키고자 함

1. 프레임워크 독립성
    
    프레임워크에 의존하지 않는다.
    
2. 테스트 용이성
    
    업무 규칙은 UI, DB, 웹서버 없이도 테스트 가능해야 함
    
3. UI 독립성
    
    시스템을 변경하지 않고도 UI 를 변경할 수 있어야 함
    
4. DB 독립성
    
    어떤 DB 를 쓰든 동작해야 함
    
5. 모든 외부 에이전시에 대한 독립성
    
    업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못해야 함

![image](https://user-images.githubusercontent.com/13694046/140648106-bae516b6-57c6-4c38-805b-3f75401fe118.png)

# __의존성 규칙

안으로 들어갈수록 고수준

바깥쪽 원은 매커니즘, 안쪽 원은 정책

<aside>
👉 **소스코드 의존성은 반드시 안쪽으로`만` 향해야 한다**

</aside>

내부 원은 외부에 대해 일절 몰라야 함

## 엔티티 (노란색)

전사적인 핵심 업무 규칙을 캡슐화

메서드를 가지고 있는 객체이거나, 일련의 데이터 구조와 함수의 집합이거나

재사용할수만 있다면 형태는 중요하지 않음

운영 관점에서 애플리케이션을 변경하더라도 엔티티에는 절대 영향을 주면 안됨

## 유스 케이스 (주황색)

애플리케이션에 특화된 업무 규칙을 포함함

시스템의 모든 유스케이스를 캡슐화하고 구현함

엔티티가 자신의 핵심 업무 규칙(메서드)를 사용해서 
유스케이스의 목적을 달성하도록 이끔

## 인터페이스 어댑터 (초록색)

일련의 어댑터로 구성

GUI, MVC 아키텍처(프레젠터, 뷰, 컨트롤러, 뷰모델), DB(SQL) 모두 포괄

데이터를 외부 서비스와 같은 외부적인 형식에서 
유스케이스나 엔티티에서 사용되는 내부적인 형식으로 변환하는 또다른 어댑터가 필요 (Mapper?)

## 프레임워크와 드라이버 (파란색)

프레임워크, 도구

모든 세부사항이 위치함 (ex. 웹, DB)

## 원이 4개여야 하나?

예시일뿐이며 원의 의존성에 대해 이해하는 게 더 중요함

## 경계 횡단하기

![image](https://user-images.githubusercontent.com/13694046/140648095-dac105cb-112b-44f2-8bff-4c2320a8131e.png)

## 경계를 횡단하는 데이터는 어떤 모습인가?

경계를 가로지르는 데이터는 흔히 간단한 데이터 구조

기본적인 구조체 or 간단한 데이터 전송 객체 (DTO)

간단한 인자를 이용해 데이터로 전달 or 해시맵으로 묶거나 객체로 구성할수도 있음

이 데이터가 경계를 가로지른다는 게 중요한 key Point

ex. DB 프레임워크 : 쿼리에 대한 응답으로 사용하기 편한 데이터 포맷 사용

행 구조인 경우가 많은데, 이 행 자체가 내부로 그대로 전달되는 걸 원하지 않음
(내부의 원에서 외부 원의 무언가를 알아야 하기 때문)

데이터는 내부의 원에서 사용하기 가장 편리해야함

<aside>
💭 엔티티를 처음엔 데이터 객체로 생각했었는데 다른 의미인것 같다

</aside>

# __전형적인 시나리오

이건 계속 책의 내용을 보면서 이해하는 걸 추천한다

<aside>
💭 TextExt, TextUtil 형태로 모든 화면에서 종속성을 갖는 함수를 가지면서
단순 유틸 기능을 갖는 로직은 어떻게 처리하는 게 좋을까?

View 는 필수이고 경우에 따라 ViewModel 또는 Repository 등에서도 활용될 수 있는데 
이 코드 하나만 고치면 모든 곳에 영향을 끼치게 된다

하지만 이로 인해 중복을 줄일 수 있고, 정책에 순조롭게 맞춰 작업할 수 있다

</aside>

# __결론

이러한 클린 구조는 테스트 하기에도 편해진다.

프레젠터는 험블 객체 패턴을 따른 형태

험블 객체 : 대강 만든 객체

이케틱처 경계를 식별하고 보호하는 데 도움이 됨

클린 아키텍처는 험블 객체 구현체로 가득차 있음

# 23장 프레젠터와 험블 객체

# __험블 객체 패턴

디자인 패턴으로 테스트하기 어려운 행위, 테스트하기 쉬운 행위를 
단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안됨

행위들을 두개의 모듈 또는 클래스로 나눔 (이들 모듈 중 하나가 험블)

기본적인 본질은 남기고 어려운 행위를 모두 험블로 옮김

나머지 모듈에는 테스트하기 쉬운 행위를 옮김

ex. GUI 와 프레젠터

GUI 는 화면 표시를 보아야 하므로 테스트를 작성하기 매우 어렵

GUI 에서 수행하는 행위의 대다수는 테스트 가능한 영역

험블 객체 패턴을 활용해 GUI 와 프레젠터 영역을 나눌 수 있음

# __프레젠터와 뷰

뷰

1. 험블 객체이며 테스트가 어려움
2. 데이터를 GUI 로 이동시키지만 데이터를 직접 처리하지 않음

프레젠터

1. 테스트가 쉬움
2. 데이터를 받아 화면에 표현할 수 있는 포맷으로 만드는 것 (데이터 처리)

ex. 애플리케이션 어떤 필드에 날짜 표시

1. 프레젠터에 Date 객체 전달
2. 프레젠터는 데이터를 적절한 문자열로 다음고 ViewModel 에 담아놓음
3. 뷰는 ViewModel 에서 데이터를 찾음

ex2. 화면에 금액 표시

1. 프레젠터에 Currency 객체 전달
2. 프레젠터는 객체를 적절하게 변환하고 ViewModel 에 담아놓음
3. 뷰는 ViewModel 에서 데이터를 찾음

뷰는 ViewModel 의 데이터를 화면에 로드할 뿐

<aside>
💭 정리하다 보니, ViewModel, DataBinding 의 원론적인 내용을 이야기하는 것 같기도 하다

</aside>

# __테스트와 아키텍처

험블 객체 패턴을 통해 자연스레 경계가 생김 (ex. 프레젠터와 뷰)

# __데이터베이스 게이트웨이

유스케이스 인터렉터, DB 사이에 존재

게이트웨이 : 다형적 인터페이스로, DB에 수행하는 생성, 조회, 갱신, 삭제 작업과 관련된 모든 메서드를 포함

ex. UserGateWay 는 어제 로그인한 사용자의 성을 알 수 있는 함수를 가지고 있음

유스케이스는 SQL 을 사용하지 않고, 게이트웨이 인터페이스 호출로 간접적으로 사용

인터페이스 구현체는 험블 객체, 인터렉터 자체는 험블 객체가 아님

→ mockking 이나 stub 를 통해 적절히 대처할 수 있음

# __데이터 매퍼

객체 관계 매퍼 같은 건 존재하지 않음 (?)

객체는 데이터 구조가 아니기 때문 (객체는 private 모음)

사용자의 관점에서 객체는 단순히 오퍼레이션의 집합

데이터 구조는 public 모음

데이터 매퍼 : 특정 저장소에서 가져온 데이터를, 활용할 구조(ex. 모바일, 웹 등)에 맞게 변환함

이런 매퍼는 DB 계층에 존재해야 한다!

# __서비스 리스너

외부로 나가는 것, 받는 것 모두 험블 객체 패턴을 적용할 수 있음

이 데이터 구조는 서비스 경계를 가로지름

# __결론

각 아키텍처 경계마다 험블 객체 패턴을 발견할 수 있음

험블 객체 패턴을 통해 테스트 가능, 불가능 영역을 나누어 테스트 용이성을 높여보자

# 24장 부분적 경계

경계를 완벽하게 만드는 데는 비용이 많이 든다

1. 다형적 Boundary 인터페이스
2. Input Output 을 위한 데이터 구조
3. 두 영역을 독립적으로 컴파일하고 배포할 수 있는 컴포넌트로 격리하기 위한
모든 의존성을 관리
4. 유지하는데도 비용 소모

애자일에선 이런 설계를 탐탁치 않게 여김

YAGNI (= 필요한 작업만 해라) 를 위배하기 때문

아키텍트 관점에선 필요할 수 있는 작업

# __마지막 단계를 건너뛰기

부분적 경계를 생성하는 방법

독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 뒤
단일 컴포넌트에 그대로 모아만 두기 → ???

부분적 경계 vs 완벽한 경계

1. 부분적 경계 또한 완벽한 경계를 만들때 만큼의 코드량과 사전 설계 필요
2. 다수의 컴포넌트를 관리하는 작업은 하지 않아도 됨
3. 부분적 경계는 추적을 위한 버전 번호도 없고, 배포 관리 부담도 없음

ex. FitNesse

웹 서버 컴포넌트는 FitNesse 의 위키나 테스트 영역과는 분리되도록 설계

버전 호환성, 다른 jar 파일 찾기 같은거 없이 바로 다운 후 실행할 수 있도록 함

두번 다운로드를 막기 vs 환경을 다르게 바라보는 앱 분리

# __일차원 경계

완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로 쌍방향 Boundary 인터페이스 사용

이런 격리 상태를 유지하는 데 리소스도 많이 들긴 함

간단한 구조를 활용해보자(?) - Strategy 패턴

Client → Service boundary

             ↖︎  Service Impl

쩝... 그래 의존성 역전이 맞고.... 이게 간단한 구조이긴 하지....

# __퍼사드

위보다 훨씬 단순한 경계

의존성 관계까지도 희생하며 경계는 Facade Class 로만 간단히 정의 됨

Facade 는 모든 서비스 클래스를 메서드 형태로 정의하고 
서비스 호출이 발생 시 해당 서비스 클래스로 호출을 전달 

Client → Facade
                       → Service
                       → Service
                       → Service

Client 는 서비스 클래스에 직접 접근 가능

Client 가 모든 서비스 클래스에 대해 추이 종속성을 갖게 되는 건 단점

# __결론

마지막 단계를 건너 뛰기는 잘 이해가 안된다.

경계가 언제, 어디에 존재해야 할지, 
그 경계를 완벽하게 구현할지 부분으로 구현할지 결정 또한 아키텍트의 몫

# 25장 계층과 경계

시스템 구성 요소 = UI, 업무 규칙, DB + `알파`

우리는 `알파`를 생각해야 한다.

# __움퍼스 사냥 게임

1. UI 가 어떤 컴포넌트를 사용하더라도 게임 규칙을 재사용할 수 있음
    
    ex. English UI, Spanish UI 등 어떤 언어를 사용하더라도 게임 규칙을 재사용할 수 있다
    
2. 게임 규칙이 데이터 저장소에 대해 알지 않기를 원함
    
    ex. English UI, Spanish UI → Game Rules ← Flash Data, Cloud Data
    

# __클린 아키텍처?

Language UI 가 유일한 변경의 축은 아님

ex. Text 전달 방식 (SMS, Mail, Console 등), Data Storage (cloud, flash 등)

복잡한 다이어그램이 그려질 수 있지만, 점선은 추상 컴포넌트

책내의 구조에서 아래 내용을 확인할 수 있음

1. GameRules 에서, GameRules 가 정의하고 Language 가 구현하는 API 를 통해 Language 와 통신
2. Language 에서, Language 가 정의하고 TextDelivery 가 구현하는 API 를 통해 TextDelivery 와 통신
3. GameRules 에서 구현하고 Language 내부 코드에서 구현하는 다형적 Boundary 인터페이스
4. Language 에서 사용하고 GameRules 내부 코드에서 구현하는 다형적 Boundary 인터페이스

정리 : 모든 컴포넌트 (Language, Data Storage, TextDelivery) 가 최종적으로 GameRules 를 바라봄

# __흐름 횡단하기

Network 가 추가되고 이 역시 GameRules 를 바라봄

# __흐름 분리하기

GameRules 역시 다양한 Rule 존재 (ex. 지도 등)

그리고 상위 구조가 존재할 수 있음 (ex. 플레이어의 정보 정책 (생명력 등))

# __결론

아키텍처의 경계는 어디에서나 존재한다

경계를 구현하려면 비용이 많이 든다

나중에 추가하는 비용이 더 크다

오버 엔지니어링이 언더 엔지니어링보다 나쁠때가 많다 (YAGNI 이론을 생각해보자)

비용을 산정하고, 어디에 아키텍처 경계를 두어야 할지, 완벽 / 부분 경계를 어떻게 둘지 등의 미래를 
아키텍처는 내다볼 줄 알아야한다.

초반에는 경계를 결정하기 어려우므로 지켜봐야 한다

경계가 필요해질 때 해당 경계를 구현하는 비용 vs 무시할 때 감수할 비용을 비교해야 한다

<aside>
💭 말이 쉽다
</aside>

# 26장 메인(Main) 컴포넌트

모든 시스템에는 최소한 하나의 컴포넌트 존재

이 컴포넌트(메인)이 나머지 컴포넌트를 생성하고 조정하며 관리

# __궁극적인 세부사항

메인 컴포넌트

1. 궁극적인 세부사항
2. 가장 낮은 수준의 정책
3. 시스템의 초기 진입점
4. 운영체제만 의존

움퍼스 게임에서 바라본 main

1. main 에서 선언된 문자열들을 다른 파일에서 알지 못하게 함
2. 팩토리를 통해 인스턴스를 만들고, 단순히 인스턴스의 메서드를 호출하도록 함
( = 클래스에 변경이 생기더라도 메인을 재컴파일, 배포하지 않도록 하기 위함)
    
    명령어 실제 처리도 인스턴스 메서드 호출로 진행
    
3. 지도 생성 등의 지저분한 역할 모두 main 에서 진행

메인은 클린 아키텍처에서 가장 바깥원에 위치하는 지저분한 저수준의 모듈

고수준의 시스템을 위한 모든 것을 로드한 후, 제어권을 고수준 시스템에게 넘김

# __결론

메인 = 애플리케이션의 플러그인

메인은 초기 조건과 설정을 구성하고 
외부 자원을 모두 수집한 후 
제어권을 애플리케이션의 고수준으로 넘기는 플러그인

메인은 여러개 만들수도 있음

1. 개발용 메인 플러그인
2. 테스트용 메인 플러그인
3. 상용 메인 플러그인

# 27장 ‘크고 작은 모든’ 서비스들

서비스에 대한 오해

1. 서비스를 사용하면 `상호 결합이 철저하게 분리`되는 것처럼 보임 (일부만 맞는 말)
2. 서비스를 사용하면 `개발과 배포 독립성을 지원`하는 것처럼 보임 (일부만 맞는 말)

# __서비스 아키텍처?

시스템의 아키텍처는 의존성 규칙을 준수하며 
고수준의 정책을 저수준의 세부사항으로부터 분리되는 경계에 의해 정의

모든 서비스가 반드시 아키텍처 관점에서 중요해야만 한다는 뜻은 아님 → ???

기능을 프로세스나 플랫폼에 독립적으로 되게끔 서비스들을 생성하면 
의존성 규칙 준수 여부와 상관없이 큰 도움이 될 때가 많음

시스템의 나머지 많은 함수들은 행위를 서로 분리할뿐이며 아키텍처적으로는 전혀 중요하지 않음

서비스는 단순히 프로세스나 플랫폼의 `경계를 가로지르는 함수 호출`에 지나지 않음

# __서비스의 이점?

## 결합 분리의 오류

시스템들을 서비스로 분리하여 얻게 되는 이점은, 서비스 사이의 결합이 분리되는 것

서비스는 다른 서비스의 변수에 직접 접근 불가능

공유하는 데이터 혹은 자원이 있다면 이로 인해 서비스는 강력하게 결합되어 버림

(서비스가 데이터 레코드에 결합되는 경우 (`as like` Repository 내의 변수))

함수의 경우에도 마찬가지

서비스 인터페이스가 함수 인터페이스보다 더 엄밀하거나, 더 엄격하고, 더 잘 정의되는 건 아님

<aside>
💭 종속되는 건 어쩔 수 없는 사실이다

하지만 어쩔 수 없이 종속 시켜야 하는 경우도 있지 않을까 개인적으로 생각한다

(ex. SharedPref 에서 받아온 토큰을 변수화하여 Repository 내에서 사용 
이 변수에 많은 함수들이 종속되는 데 이 경우는 안티패턴인가?
매번 SharedPref 에서 가져올수는 없는 노릇 아닌가?)

</aside>

## 개발 및 배포 독립성의 오류

서비스의 이점 : 전담팀이 서비스를 소유하고 운영한다는 점 (독립적인 개발 및 배포가 가능함)

하지만 극히 일부일 뿐

1. 대규모 엔터프라이즈 시스템은 모노리틱으로도 충분히 할 수 있음
2. 서비스라고 해서 독립적으로 개발, 배포, 운영할 수 있는 건 아님
    
    (데이터나 행위에서 어느정도 결합되어 있을 경우 결합된 정도에 맞게 개발, 배포, 운영을 조정해야 함)
    

# __야옹이 문제

택시 통합 시스템

1. 많은 택시 업체를 알고 있음
2. 승차 시간, 비용, 고급 택시여부, 운전자 경력 등에 따라 다양한 기준의 택시를 선택할 수 있음

최대한 쪼개봄

1. TaxiUI : 고객을 담당하며 모바일 기기를 통해 택시를 호출
2. TaxiFinder : 여러 TaxiSupplier 현황을 검토하여 사용자에게 적합한 택시 후보 선별
3. TaxiSelector : 사용자의 선택에 맞게 적합한 택시를 선택해줌

행복하게 살다가 마케팅 부서에서 야옹이를 배달하는 서비스를 제공하겠다고 함

(ex. 자신의 집, 사무실로 야옹이를 배달해달라고 할 수 있음)

다양한 고려사항이 생길 것이다

1. 동참하지 않는 택시 회사 존재
2. 고양이 알러지로 인해 일부 운전자 거부

이 고려사항을 반영하려면? 전부다 수정해야 함 (개발과 배포 전략을 신중히 조정해야 함)

위의 예는 횡단 관심사가 지닌 문제

모든 소프트웨어는 이걸 경험할 수 있음

서비스 차원에서는 새로운 기능이 기능적 행위를 횡단하는 상황에 매우 취약함

<aside>
💭 이건 모노리틱도 마찬가지 아닌가

</aside>

# __객체가 구출하다

`다형적으로 확장할 수 있는 클래스 집합을 생성`해 새로운 기능을 처리하도록 하여 해결 가능

1. 두 개의 컴포넌트로 분리
    1. 기존 배차에 특화된 부분은 Rides 컴포넌트로 추출
    2. 야옹이에 대한 신규 기능은 Kittens 컴포넌트에 들여보냄
2. 기존 컴포넌트들에 있는 추상 기반 클래스를 
템플릿 메서드나 전략 패턴 등을 활용해 위의 두 컴포넌트를 재정의함

결과

1. 두 개의 신규 컴포넌트가 의존성 규칙을 준수하면서 UI 의 제어하에 팩토리가 생성됨
2. 야옹이 기능은 결합이 분리되며 독립적으로 개발하여 배포 할 수 있음

<aside>
💭 그런데 야옹이를 받을 때에 대한 처리를 어짜피 해주어야 하니까 결국은 똑같은 거 아닌가?

추상 클래스의 템플릿 메서드를 활용하니까, 빌드 관념에서 큰 무리는 없을꺼고 
야옹이에 대한 엔티티 상세 구현 내용(Impl)만 수정하면 되니까 그런건가?

이렇게 듣고 보니 Activity 를 2개로 제네릭하는 게 왜 이야기 나왔는지 언뜻 알 것 같기도 하다

</aside>

# __컴포넌트 기반 서비스

서비스에도 위와 같이 할 수 있음

기존 컴포넌트를 교체하지 않고도 새로운 컴포넌트 추가 가능

서비스를 하나 이상의 jar 파일에 포함되는 `추상 클래스들의 집합`이라고 생각하기

- 새로운 기능 추가 혹은 기능 확장은 새로운 jar 파일로 처리함 (추상 메서드)
- jar 파일에 정의 되어 있는 추상 클래스를 확장하여 구현하기

이로인해

- 새로운 기능 배포는 서비스 재배포가 아닌 jar 파일 추가 단위로 문제가 좁혀짐
- 새로운 기능을 배포하는 것은 개방 폐쇄 원칙을 지키게 됨

<aside>
💭 결국은 jar 파일에 추가된 기능을 반영해야하는거 아닌가?

</aside>

# __횡단 관심사

횡단 관심사 : 모든 주요 시스템이 직면하는 내용

- 아키텍처 경계는 서비스 사이에 있지 않음
- 오히려 서비스를 관통하며, 서비스를 컴포넌트 단위로 분할함

의존성 규칙을 준수하는 아키텍처로 설계하면 횡단 관심사를 처리할 수 있음

# __결론

서비스 자체로는 아키텍처적으로 그리 중요한 요소는 아님

시스템의 아키텍처는 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의됨

시스템의 구성 요소가 통신하고 실행되는 물리적인 매커니즘에 의해 아키텍처가 정의되는 것이 아님 → ??

서비스는 단 하나의 아키텍처 경계로 둘러싸인 단일 컴포넌트로 만들 수 있음

여러 아키텍처 경계로 분리된 다수의 컴포넌트로 구성 할수도 있음

클라이언트와 서비스가 강하게 결합되어 아키텍처로 의미가 없는 경우도 있음
(웹 내에 백 앤드 내용도 전부 박혀있는걸 이야기하는건가?)

# 28장 테스트 경계

테스트는 시스템의 일부이며 아키텍처에 관여하기도 함

# __시스템 컴포넌트인 테스트

아키텍처 관점에서 모든 테스트는 동일

- TDD 로 생성된 작은 테스트든, 대규모의 테스트이든 아키텍처 상으론 동등함

테스트는 태생적으로 의존성 규칙을 따름

- 테스트는 세부적이며 구체적인 것
- 의존성은 항상 테스트 대상이 되는 코드를 말함

테스트는 아키텍처 상에서 가장 바깥쪽 원

- 시스템 내부에 어떤 것도 테스트에는 의존하지 않음
- 테스트는 시스템의 컴포넌트를 향해 항상 원의 안쪽으로 이동

테스트는 독립적으로 배포 가능함

- 테스트는 테스트 시스템에만 배포하며 상용 시스템에는 배포하지 않음

시스템 컴포넌트 상에서 가장 고립되어 있음

- 테스트가 운영에 꼭 필요하진 않음
- 어떤 사용자도 의존하지 않음
- 테스트는 운영이 아니라 개발 지원이 목적
- 다른 모든 시스템 컴포넌트가 `반드시 지켜야 하는 모델을 표현`함

# __테스트를 고려한 설계

테스트가 지닌 극단적인 고립성이, 테스트는 대체로 배포하지 않는 사실과 어우러짐

개발자는 종종 테스트가 시스템 설계 범위 밖에 있다고 여김 (치명적인 시각)

테스트가 시스템의 설계와 잘 통합되지 않을 시 테스트는 깨지기 쉽고 시스템은 뻣뻣해져 변경이 어려움

시스템 컴포넌트에서 생긴 사소한 변경도 수많은 테스트를 망가뜨림 (짜증을 유발하는 gradle.... 오류)

깨지기 쉬운 테스트 문제 (Fragile Test Problem)

- ex. 로그인 화면에서 페이지 구조를 탐색해 나가며 특정 업무 규칙을 검사하는 테스트
    
    → 로그인 페이지 탐색 구조 어딘가가 달라지면 엄청난 수의 테스트가 망가짐
    
- 시스템을 뻣뻣하게 만든다는 단점도 존재

해결책

1. 변동성이 있는 것에 의존하지 말 것
    
    GUI 는 변동성이 크고, 시스템을 조작하는 테스트 스위트는 분명 깨지기 쉬움
    
    GUI 를 사용하지 않고 업무 규칙을 테스트할 수 있도록 해야함
    
    <aside>
    💭 안 사용해도 Android 기반을 사용하지 않는 특이 케이스 오류 때문에 넘나 테스트가 빡셉니다...
    
    </aside>
    

# __테스트 API

테스트가 모든 업무 규칙을 검증하는 데 사용할 수 있도록 특화된 API 를 만들기

보안 제약사항, DB 같은 값비싼 자원을 건너뛰고, 테스트 가능한 특정한 상태로 강제하도록 함 (Mockking)

테스트를 어플리케이션으로부터 분리할 목적으로 사용할 것

단순히 테스트를 UI 에서 분리하는 것이 아닌 테스트 구조를 애플리케이션 구조로부터 결합을 분리하도록 하기

## 구조적 결합

가장 은밀하게 퍼져나가고 가장 강한 테스트 결합

모든 상용 클래스에 테스트 클래스가 각각 존재하고, 모든 메서드에 테스트가 있다고 가정한다면
이 테스트 스위트는 애플리케이션 구조에 강하게 결합 되어 있다고 볼 수 있음

조금이라도 변경되면 테스트 모두 망가지므로 상용 코드를 뻣뻣하게 만듬

테스트 API 의 역할은 `애플리케이션 구조를 테스트로부터 숨기는 데` 의의가 있음

상용코드를 리펙터링하거나 진화시키더라도 상용코드에는 영향을 주지 않음

구조적 결합이 강하면 필수적인 진화 과정을 방해할 뿐 아니라 상용코드의 범용성과 유연성이 나빠짐

## 보안

테스트 API 가 지닌 강력한 힘을 운영 시스템에 배포하면 위험해질 수 있음

독립적으로 둘 것

# __결론

테스트는 시스템 외부에 있는 게 아님 (시스템의 일부임)

# 29장 클린 임베디드 아키텍처

```kotlin
소프트웨어는 닳지 않지만, 펌웨어와 하드웨어는 낡아가므로 소프트웨어도 수정해야한다.
```

중요한 key point

1. 소프트웨어는 긴 시간 유용하게 쓸 수 있는 것
2. 펌웨어는 하드웨어가 발전할수록 낡아갈 것

하드웨어는 발전됨과 동시에 소프트웨어는 새로운 기능이 추가되어 복잡도가 계속 증가함

```kotlin
소프트웨어는 닳지 않지만, 펌웨어와 하드웨어에 대한 의존성을 관리하지 않으면 안으로부터 파괴될 수 있다.
```

하드웨어에 의존함으로 인해 소프트웨어 생명이 줄어들 수 있음

펌웨어의 특징 (조금 구닥다리의 면도 있음)

1. ROM, EPROM 과 같은 비휘발성 메모리에 유지
(ROM 에만 있지 않으며 저장 위치에 종속되는 게 아님)
2. 하드웨어 장치에 프로그래밍된 소프트웨어 프로그램 혹은 명령어 집합
3. 펌웨어는 개별 하드웨어에 내장되는 소프트웨어
4. 펌웨어는 읽기 전용 메모리에 쓰여진 소프트웨어

코드에 SQL 을 심어놓거나 개발하는 코드 전반에 플랫폼 의존성을 퍼뜨린다면 이미 펌웨어를 만들고 있는 것

# __앱-티튜드 테스트

임베디드 코드가 동작하게 만드는 데 대부분의 노력을 하고, 
오랫동안 유용하게 남도록 구조화하는 데는 신경쓰지 않기 때문에 
많은 펌웨어 비슷한 소프트웨어가 만들어짐

1. 동작하게 만들어라
2. 올바르게 만들어라 (코드를 리펙터링해서 다른 사람이 이해할 수 있게 만들기)
3. 빠르게 만들어라 (요구하는 성능을 빠르게 반영하기)

앱_티튜드 테스트

1. 동작하도록 만드는 것
2. 이것만 한다면 제품과 고용주에게 몹쓸 짓을 하는 것

# __타깃-하드웨어 병목현상

임베디드만이 다루는 특수한 현상

1. 제한된 메모리 공간
2. 실시간성 제약과 처리 완료시간
3. 제한된 입출력
4. 특이한 사용자 인터페이스
5. 여러 센서와 실제 세상과의 상호작용

임베디드 코드가 클린 아키텍처 원칙과 실천법을 따르지 않고 작성된다면
대개의 경우 코드를 테스트할 수 있는 환경이 해당 특정 타깃으로 국한될 것

## 클린 임베디드 아키텍처는 테스트하기 쉬운 임베디드 아키텍처이다

### 계층

하드웨어는 계속 개선됨

소프트웨어와 펌웨어가 서로 섞이면 안티패턴

변경하는 일 자체가 위험을 수반하게 됨

### 하드웨어는 세부사항

소프트웨어와 펌웨어의 경계는 정의하기 어려움

소프트웨어와 펌웨어 사이의 경계는 `하드웨어 추상화 계층`(HAL) 이라고도 부름

소프트웨어의 저장이 클라우드에 저장되는지, 플래시 메모리에 저장되는지 등에 관심을 가지면 안됨
(알게 되는 방법이 있어서도 안됨, 임베디드 차원에서 가려야 함)

### HAL 사용자에게 하드웨어 세부사항을 드러내지 않기

HAL 을 제대로 만들었다면 HAL 은 타겟과 상관없이 테스트할 수 있는 경계층 또는 일련의 대체 지점을 제공함

### 프로세서는 세부사항이다.

하드웨어 류는 함부로 접근하려 하면 안됨 (종속되어버리니까)

stdio, stdint 의 역할이 이런거였군요

### 운영체제는 세부사항이다.

작성된 코드의 수명을 늘리려면 무조건 운영체제를 세부사항으로 취급해야한다
(오 그러고 싶다. iOS 도 Kotlin 으로 하고 싶거든)

기존의 복잡한 코드 덩어리 수정 vs **`인터페이스에 맞춰 새로운 코드를 작성`**

### 인터페이스를 통하고 대체 가능성을 높이는 방향으로 프로그래밍 하라

관심사 분리에는 인터페이스가 제격

계층형 아키텍처는 인터페이스를 통해 프로그래밍하자는 발상을 기반으로 함

경험 법칙에 따르면 인터페이스 정의는 헤더 파일에 해야하지만 신중할 것
(헤더 파일에는 함수 선언, 상수 구조의 이름만 포함시켜야 함)

<aside>
💭 interface 가 뭔지를 생각해보자

</aside>

### DRY 원칙 : 조건부 컴파일 지시자를 반복하지 말라

조건부 컴파일 대신 사용할 수 있는 일련의 인터페이스를 제공한다면 
이를 소프트웨어와 하드웨어 연결의 매개체로 활용할 수 있음

# __결론

제품의 장기간 생명을 유지시키려면 펌웨어가 되는 것을 막을 것
