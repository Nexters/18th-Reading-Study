# 15장 아키텍처란?

권력과 신비로움? 누군가는 꿈꿀 수 있는 이상적인 직업?

소프트웨어 아키텍트

1. 프로그래머
2. 고수준의 문제에만 집중해야 하는 건 아님
3. 최고의 프로그래머이자 앞으로도 프로그래밍 작업을 맡을 뿐 아니라
나머지 팀원들이 생산성을 극대화할 수 있는 설계를 하도록 방향을 이끔
4. 프로그래밍 작업은 지속적으로 참여

소프트웨어 시스템의 아키텍쳐

1. 시스템을 구축했던 사람들이 만들어낸 시스템의 형태
2. 아키텍처 안에 담긴 SW 시스템이 쉽게 개발, 배포, 운영, 유지보수 되도록 만들어짐
3. 가능한한 많은 선택지로, 가능한한 오래 남겨두는 전략을 따라야 함
4. 소프트웨어 아키텍처의 목표는 시스템의 동작 여부와는 관련이 멈
(형편 없는 아키텍처도 동작은 함)
5. 운영보다는 배포, 유지보수, 개발 과정에서 어려움이 있음

좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하고, 쉽게 유지보수하고, 쉽게 배포하게 해줌

# __개발

팀원이 작을 경우, 모노리틱 시스템으로도 운영 가능
(오히려 아키텍처가 방해가 될 수 있음)

팀원이 많을 경우 (7명씩으로 구성된 총 5팀), 
잘 설계된 컴포넌트 단위로 분리하지 않으면 개발이 진척되지 않음

팀별 단일 컴포넌트 아키텍처가 시스템을 배포, 운영, 유지보수하는 데 최적일 가능성은 거의 없음

순전히 일정에만 쫒겨일한다면 이렇게 될 것

시스템 아키텍처는 `개발팀이 시스템을 쉽게 개발할 수 있도록` 해야함

# __배포

배포 비용이 높을수록 시스템의 유용성은 떨어짐

시스템을 `단 한번에 쉽게 배포할 수 있도록` 만드는데 그 목표를 두어야 함

마이크로서비스 아키텍처

- 컴포넌트 경계가 뚜렷해지고 인터페이스도 대체로 안정화되므로 
시스템을 매우 쉽게 개발할 수 있다고 판단했을 확률이 높음
- 하지만 배포 시기 시 마이크로서비스들을 서로 연결하기 위한 설정, 작동순서 결정 등
오히려 오작동이 발생할 원천이 생길수도 있음

더 적은 서비스를 사용, 서비스 컴포넌트와 프로세스 수준의 컴포넌트를 하이브리드 형태로 융합하며 
좀 더 통합된 도구로 사용해 상호 연결을 관리했어야 함 → ??

# __운영

개발, 배포, 유지보수에 미치는 영향보다는 덜 극적

하드웨어 단순 투입으로도 해결 가능

하지만 아주 연관이 없지만은 않음 - 시스템을 운영하는 데 필요한 요구도 알려줌

개발자에게 시스템의 운영 방식을 잘 드러내준다고 할 수 있음

유스케이스, 기능, 시스템의 필수행위를 1급 엔티티로 격상시킴

→ 솔직히 잘 이해되지 않음

# __유지보수

유지보수는 소프트웨어 시스템에서 가장 비싼 작업

탐사와 이로 인한 위험 부담

탐사
기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때 
소프트웨어를 파헤쳐 어디를 수정해야 하는지, 어떤 전략을 써야할지를 결정할 때 드는 비용

시스템을 컴포넌트로 분리하기

안정된 인터페이스를 두어 격리하기 
(최근 프로젝트에서 차트 로직 및 변수를 인터페이스로 분리해서 기능 추가에 별다른 어려움을 겪지 않았음)

# __선택사항 열어 두기

소프트웨어는 행위적 가치, **`구조적 가치`**를 지님

`구조적 가치` : 소프트웨어를 유연하게 만듬

소프트웨어를 만든 이유 : 기계의 행위를 빠르고 쉽게 변경 가능

유연성은 시스템의 형태, 컴포넌트의 배치 방식, 컴포넌트가 상호 연결되는 방식에 크게 의존함

소프트웨어를 부드럽게 만드는 방법

1. 선택사항을 가능한한 많이 (하나의 함수가 다양한 작업을 하도록?)
    
    선택사항 : 중요치 않은 세부사항
    
2. 그리고 가능한 한 오랫동안 열어두는 것 (주석?)

(K 모 특정 개발자가 추구하는 방법인 것 같기도 하다)

모든 소프트웨어 시스템 = 정책 + 세부사항

1. 정책
    
    모든 업무 규칙과 절차를 구체화
    
    시스템의 진정한 가치가 살아 있는 곳
    
2. 세부사항
    
    사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소
    
    정책이 가진 행위에는 조금도 영향을 끼치지 않음
    
    입출력 장치, DB, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등
    

아키텍트의 목표

시스템에서 정책을 `가장 핵심적인 요소로 식별`하고
세부사항은 `정책과 무관하게 만들 수 있는 형태의 시스템을 구축`하는 데 있음

이로 인해 세부사항을 결정하는 일은 미루거나 연기할 수 있게 됨?

ex. 

1. 개발 초기에는 DB 시스템을 선택할 필요가 없음 (관계형이든, 분산형이든 다 동작하도록)
2. 개발 초기에는 웹 서버를 선택할 필요가 없음 (웹을 통해 전송할 것인지 조차도 정할 필요 없음)
3. REST, 마이크로서비스, SOA 다 필요 없음
4. 처음엔 의존성 주입을 쓸 필요가 없음

→ 고수준의 정책은 세부적인 것에 신경을 쓸 필요가 없다.
     세부사항에 신경쓰지 않고 고수준의 정책을 만드는 데 집중하자 (세부사항은 나중으로 미루자)

→ 미리 정하지 않음으로서 실험을 해볼 수 있고, 더 많은 것을 시도할 수 있다.

좋은 아키텍처는 결정되지 않은 사항의 수를 최대화한다.

# __장치 독립성

장치 종속성

- 코드를 입출력 장치와 직접 결합
    
    ex. 프린터 인쇄 시 해당 프린터를 제어하는 입출력 명령어 직접 사용해서 코드를 작성
    
    ex. 카드 판독기를 직접 조작하는 코드를 작성
    
- 데이터 무결성이 대두되면서 실수라는 걸 알게 됨

오늘날 운영체제

입출력 장치를 소프트웨어 함수로 `추상화`함

해당 함수는 단위 레코드를 처리함

프로그램은 운영체제의 서비스를 호출함

해당 서비스가 추상화된 단위 레코드 장치를 처리함

→ 동일한 프로그램을 아무런 변경 없이 카드에서 읽고 쓰거나 테이프에서 읽고 쓸 수 있게됨

     (개방 폐쇄의 원칙)

안드로이드에선 뭘 예로 생각할 수 있을까?

지금 프로젝트에서 차트가 유독 기억에 남는다.
홈 화면에서 사용되던 차트를, BottomSheet 에서도 활용하면서 
일일히 구현을 그대로 복붙에서 똑같은 코드를 만들었다

그 직전에 차트의 ViewModel 종속성을 뺀 적이 있었는데 이게 정말 큰 도움이 되었었다.

이런 과정에서 얻은 생각은 이랬다
좀더 많은 함수와 변수를 추상화 했어야 했고, 함수를 변수화해서 넘기는 건 너무나 사기 기능이다.

아마 차트를 다른 화면에서 사용하는 걸 확장이라 할 수 있을 것 같고
추상화된 함수는 각 OS(OS X, WIndow 등) 의 기본 추상화 함수로 정리가 된다.

# __광고 우편

이름과 주소레코드만 바꿔 지정된 종이 템플릿에 찍기

- 라인 프린터 → 자기 테이프 및 오프라인 프린터 활용 ( + 테스트는 컴퓨터에 직접 연결된 라인프린터)
- 많은 시간 절약

정책 : 이름과 주소 레코드에 대한 서식

세부사항 : 장치

정책에 맞춰 세부사항을 바꿀 수 있어야 한다.

# __물리적 주소 할당

지역 트럭 운정수 조합을 위한 대규모 회계 시스템

- 소프트웨어가 디스크의 상세 구조를 알도록 만듬 ( = 하드 코딩)
- 스케일 업시 하드웨어의 정보를 모두 알 수 있도록 해야 함
- 상대주소를 통해 하드웨어로부터 분리시킴

이런 경우도 있었구나... 

# __결론

좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려냄

정책이 세부사항과 결합되지 않도록 함 
(누가 안드도 파이썬으로 할 수 있게 만들...? 그럼 세부사항(Kotlin) 고민할 필요없어짐)

세부사항을 최대한 뒤로 미루어라

# 16장 독립성

# __유스케이스

시스템의 아키텍처는 시스템의 의도를 지원해야함

ex. 장바구니 애플리케이션

- 장바구니와 관련된 유스케이스를 지원해야 함

아키텍처는 시스템의 행위에 그다지 큰 영향을 주지 않음

- 행위와 관련하여 아키텍처가 열어둘 수 있는 선택사항은 거의 없음
- 행위를 명확히 하고 외부로 드러내며 이를 시스템이 지닌 의도를 
아키텍처 수준에서 알아볼 수 있게 만들어야 함 → ???
- 클래스, 함수 또는 모듈로서 아키텍처 내에서 핵심적인 자리를 차지함
+ 자신의 기능을 분명하게 설명하는 이름을 가질 것

# __운영

시스템이 초당 10만명의 고객을 처리해야 한다면, 
아키텍처는 이 요구와 관련된 각 유스케이스에 걸맞는 처리량과 응답 시간을 보장해야 함

아키텍트는 각 상황에 유연하게 대처할 수 있도록 작성해야함

특정 기능을 알면서 써야하는 이유에 대해 언급한 것 같기도 하다.

# __개발

시스템을 설계하는 조직이라면 어디든지, 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.

잘 격리되어 독립적으로 개발가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 함

# __배포

목표는 즉각적인 배포

시스템이 빌드된 후 즉각 배포될 수 있도록 해야 함

시스템을 컴포넌트 단위로 적절하게 분할하고 격리시키는 게 중요

마스터 컴포넌트는 시스템 전체를 하나로 묶고, 감 컴포넌트를 올바르게 구동, 통합, 관리해야 함

# __선택사항 열어놓기

우리는 모든 유스케이스를 알 수 없다

운영 제약사항, 팀구조, 배포 요구사항도 알 수 없다

생명주기의 단계를 하나씩 거쳐가면서 이 사항들도 바뀐다

몇몇 아키텍처 원칙은 도움이 될 수 있다 (객체지향 5원칙 또 나오나요)

선택사항을 열어두어 언제든 쉽게 변경할 수 있도록 해야함

# __계층 결합 분리

아키텍처는 시스템의 기본적인 의도는 분명히 알고 있음 (시스템이 뭐하는 시스템인지 알고 있음)

단일 책임 원칙, 공통 폐쇄 원칙을 활용해 
다른 이유로 변경 되는 것들은 분리하고, 동일한 이유로 변경되는 건 묶음

서로 다른 이유로 변경되는 것의 예

1. 사용자 인터페이스가 변경되는 이유
    
    업무 규칙과는 아무런 관련이 없음
    
    유스케이스가 두 가지 요소를 모두 포함한다면 
    뛰어난 아키텍트는 유스케이스에서 UI 부분, 업무 규칙 부분을 서로 분리하고자 할 것
    
    두 요소를 독립적으로 변경이 가능해지고, 유스케이스를 분명히 유지 가능
    
2. 카테고리가 다른 업무 규칙
    
    입력 필드 유효성 검사 (애플리케이션 관련 업무 규칙), 계좌 이자 계산(업무 도메인 관련 규칙)
    
    이 두개의 규칙은 다른 속도로, 다른 이유로 변경되므로 분리되어야 함
    

→ 시스템의 나머지 부분으로부터 분리하여 독립적으로 변경할 수 있도록 해야함

그래서 단일 책임 원칙, 공통 폐쇄 원칙을 많이 물어보는구나

모바일에서 위의 두 개를 적극 활용하는 예를 리서치해봐야겠다.

# __유스케이스 결합 분리

1. 유스케이스는 시스템을 분할하는 매우 자연스러운 방법
    
    ex. 주문 입력 시스템에서 `주문을 추가`하는 유스케이스와 `주문을 삭제`하는 유스케이스
    
           개발 속도가 다르고, 다른 이유로 변경될 수 있다.
    
2. 유스케이스는 시스템의 수평적인 계층을 가로지르도록 자른 수직으로 좁다란 조각
    
    각 유스케이스는 UI 일부, 특화업무규칙 일부, 독립적 업무 규칙 일부, DB 일부 등을 사용
    
    시스템을 수평적 계층으로 분할하면서 동시에 
    해당 계층을 가로지르는 얇은 수직적인 유스케이스로 분할할 수 있음 → ???
    
    [위에서 언급한 내용의 예](https://www.notion.so/e1d23623d84b43b7b25eb19ed48f5847)
    
    분석
    
    1. 결합을 분리하기위해 각 유스케이스에 맞춰 UI 를 분리함 (나머지도 마찬가지)
    (수평적 관점)
    2. 아래까지 수직으로 내려가면서 유스케이스는 각 계층에서 겹치지 않음
    (수직적 관점)
    
    DB 에 취소선을 그어가면서 Repository 를 하나로 두고, 업무 로직 계층을 함수로 둔 이유
    
    클린 아키텍처의 예로 모든 로직 자체를 클래스화해서 관리하는 경우도 있긴하다
    (실제 그렇게 작성해보기도 했다)
    
    너무 분리하면 독립성은 높아지지만 그만큼 뻣뻣한 코드가 된다고 생각이 들어 난 이렇게 두어봤다
    
    진짜 저 2개밖에 로직이 없는 경우엔 
    하나의 파일에서 함수형태로 관리해도 가독성이나 로직을 찾는덴 무리가 없다고 느껴진다.
    

서로 다른 이유로 변경되는 요소들의 결합을 분리하면 
기존 요소에 지장을 주지 않고 새로운 유스케이스를 추가시킬 수 있음

유스케이스를 뒷받침하는 UI, 데이터베이스를 묶어
각 유스케이스가 UI 와 데이터베이스의 서로 다른 관점을 사용할 시 
새로운 유스케이스를 추가하더라도 기존 유스케이스에 영향을 주는 일은 거의 없을 것

UseCase 를 클래스 형태로 만들어 직접 invoke 하는 형태로 처리하면 
영향을 주는일이 거의 없긴 할 것이다

또 그걸 쉽게 사용하고 UseCase 의 구현형태는 알 수 없도록 façade 패턴을 사용한다 하면 
으... 머리아프다.

관점지향 프로그래밍 (AOP)

횡단 관심사를 분리하여 모듈화를 높임

코드 자체를 수정하지 않고 기존의 코드에 추가하는 방식(?)으로 구현

ex. 예외처리(?!), 로깅(!!), 인증, 트랜젝션

# __결합 분리 모드

결합이 분리될 시 장점

1. 높은 처리량을 보장하는 유스케이스와, 낮은 처리량으로도 충분한 유스케이스가 이미 분리되어 있음
2. UI 와 DB 가 업무 규칙과 분리되어 있을 시, UI 와 DB는 업무규칙과 다른 서버에서 실행될 수 있음
    
    (높은 처리량이 필요한 유스케이스는 여러 서버로 복제하여 실행 가능)
    
    ( = 제약이 없어짐)
    

결합을 분리할 때 적절한 모드를 선택해야 함

ex. 분리된 컴포넌트를 서로 다른 서버에서 실행해야 할 경우, 
       이들 컴포넌트가 단일 프로세서의 동일한 주소공간에 상주하는 형태로 만들어지면 안됨

분리된 컴포넌트는 반드시 독립된 서비스가 되어야하고, 일종의 네트워크를 통해 서로 통신해야함
(= 마이크로서비스)

우리는 때때로 컴포넌트를 서비스 수준까지도 분리해야함

이전에 배웠다시피 우리는 선택권을 열어두어야 함

# __개발 독립성

컴포넌트가 완전 분리되었다면 팀 사이의 간섭은 줄어듬

ex. 업무 규칙이 UI 를 알지 못하면 UI 에 중점을 둔 팀은 업무 규칙에 중점을 둔 팀에 그다지 영향을 줄 수 없음

ex. 주문 추가 팀이, 주문 제거 팀에 영향을 줄 가능성은 거의 없음

# __배포 독립성

배포 측면에도 고도의 유연성 생김

새로운 유스케이스를 추가하는 일 = 시스템의 나머지는 그대로 둔 채 새로운 jar 파일 및 서비스 몇 개 추가하는 일

# __중복

SW 에서 중복은 일반적으로 나쁜 것

진짜 중복

- 한 인스턴스가 변경되면 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야함

우발적인 중복

- 중복으로 보이는 두 코드 영역이 각자의 경로로 발전한다면 두 코드는 진짜 중복이 아님
(프로필 화면과 1:1 대응에서의 이미지 업로드는 겹치는 게 어쩌면 아니었을까...?)

진짜 중복일까? 우발적 중복일까?

- 사실 중복이 아닐수도 있을 것이다.
- 진짜 중복만 없애도록 하라
- ViewModel 을 별도로 만드는 일은 계층간 결합을 분리하여 유지하는데도 도움이 될 것이다

# __결합 분리 모드(다시)

계층과 유스케이스의 결합을 분리하는 방법은 다양

1. 소스코드 수준에서 분리
    
    소스 코드 모듈 사이의 의존성을 제어
    
    하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 만들 수 있음
    
    모노리틱 구조라고도 부름(?)
    
2. 바이너리 코드 수준에서 분리
    
    jar, DLL, 공유 라이브러리와 같이 배포 가능한 단위들 사이의 의존성을 제어
    
    한 모듈의 소스코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들 수 있음
    
    jar, gem, dll 같이 독립적 배포 가능
    
3. 실행 단위 수준에서 분리
    
    의존하는 수준을 데이터 구조 단위까지 낮춤
    
    순전히 네트워크 패킷을 통해서만 통신하도록 만듬
    
    (ex. 서비스 또는 마이크로 서비스)
    

프로젝트 초기에는 어떤 모드가 정답인지 알 수 없음

나중엔 **`실행 단위 수준에서 분리`**가 필요할 수 있음

단순한 건 **`실행 단위 수준에서 분리`** 선택 (하지만 노력, 메모리, 계산량 측면에서 큰 작업이 될 수 있음)

`바이너리 코드 수준에서 분리` 까지만 두고, 개발 배포 운영 문제 증가 시 
`실행 단위 수준에서 분리`를 고려하는 걸 추천

좋은 아키텍처는 처음에 모노리틱 구조이더라도, 이후에는 서비스 수준까지 성장할 수 있도록 만들 수 있어야함
거꾸로 뒤돌릴수도 있어야 함

개인적으로, 회사원 모두가 이해하고 쉽게 개발, 유지보수가 가능한 구조가
진정한 clean 구조라는 생각이 있다.

# 17장 경계: 선 긋기

SW 아키텍처는 선을 긋는 기술

선

- 경계라고 표현하기도 함
- 소프트웨어 요소를 서로 분리하고 경계 한편에 있는 요소가 
반대편에 있는 요소를 알지 못하도록 막음
- 선이 그어지는 시점은 제각각
- 오랫동안 결정을 연기시키기 위해, 핵심업무로직을 오염시키지 못하도록 하기 위해 선을 그음

아키텍트의 목표 : 필요한 시스템을 만들고 유지하는 데 드는 인적자원을 최소화하는 것

결합`coupling` 

- 결합 (특히 일찍 내려진 결정에 의한 결합)은 인적자원의 효율을 떨어뜨림
- 이른 결정이라 함은, 시스템의 업무 요구사항, 유스케이스와 아무런 관련이 없는 결정
    
    ex. 프레임워크, DB, 웹 서버, 유틸리티 라이브러리, 의존성 주입에 대한 결정 
    
- 이러한 결정이 부수적이며 결정을 연기할 수 있는 게 가장 좋음

좋은 시스템 아키텍처는 이러한 결정을 최후의 순간에 내릴 수 있게함

결정에 대한 영향력 또한 크지 않음

# __두 가지 슬픈 이야기

리치 시스템을 경계할 것

P사 : 단일 서버로 운영해도 되는 내용을, 세 가지 인스턴스로 나누는 등 리치 시스템을 만들어 개발 비용 증가

W사 : SOA 를 너무 일찍 채택해서 망한 케이스

# __FitNesse

위키 페이지

우리만의 웹 서버를 직접 작성하기로 하여, 
기본 뼈대만 갖춘 웹 서버는 어떤 웹 프레임워크를 사용할건지에 대한 결정을 **`늦출 수 있게 됨`**

DB 에 대해 고민하지 않음으로써,
데이터 접근 영역, 데이터 저장소 영역 사이에 인터페이스를 추가하는 간단한 방식을 먼저 사용하고
DB 사용에 대한 결정을 **`늦출 수 있게 됨`**

당장 개발하지 않는 기능들은 Stub (TODO) 상태로 둠
이후 직접 관리하게 되면서 실제로 데이터에 접근하는 로직을 구현

1년 내에 기능들을 차례대로 작성하고
MySQL 을 고민하다가 결국 폐기시킴으로서 `늦출 수 있게 됨`에 대한 보상을 얻음

선이 준 도움

1. 업무 규칙과 DB 사이에 경계선을 그음
2. 경계선을 통해 업무 규칙은 DB 에 관해 어떤 것도 알지 못하게 됨

# __어떻게 선을 그을까? 그리고 언제 그을까?

관련이 있는 것과 없는 것 사이에 선을 그을 것
ex. GUI 와 업무 규칙 사이에 선을 긋기, DB 와 업무 규칙 사이에 선을 긋기

DB 는 업무 규칙이 간접적으로 사용될 수 있는 도구일뿐 ~~업무 규칙을 구체화한 것~~이 아님

아래의 `DB 인터페이스`를 통해 Business Rule 은 DB 를 모르게 할 수 있음
Business Rule ←**`DB 인터페이스`**→ DB Access(`DB 인터페이스` ****Impl**)** → DB

왜 Repository 를 만들고 Impl 을 따로 구현하는지 이해가 될 것이다
하지만 이것도 너무 나눠지게 되면 리치 개발이라는 생각이 개인적으론 든다.
(이거 설계 및 보일러플레이트 코드 작성으로 정신없어짐)

하지만 DB 는 Business Rule 을 알고 있음
(DB 는 Business Rule 이 요청한 호출을 DB 쿼리 언어로 `변환하는 코드`를 담고 있으며, 
`변환하는 코드` 가 DB 가 Business Rule 에 대해 알고 있다는 증거)

# __입력과 출력은?

개발자와 고객은 종종 시스템의 정의를 혼란스러워함
ex. GUI 를 시스템이라고 생각하며, GUI 가 동작하는 모습을 반드시 보고 싶어함

이와 같은 입력과 출력에 신경쓰는 오류를 범하지 말아야 함
ex. 비디오 게임이 화면에 출력되지 않더라도 모델은 게임에서 발생되는 모든 이벤트를 모델링하며 역할을 수행함

중요한 건 `업무규칙`

[위에서 언급한 DB 인터페이스 개념](https://www.notion.so/17-cef46fb52aa6463ab8d1d67ddaf494f3)과 비슷하게 
GUI 는 Business Rule 을 알고 있지만, Business Rule 은 GUI 를 모름

# __플러그인 아키텍처

그러면 GUI, DB 가 Business Rule 을 알고 있고, Business Rule 은 나머지를 모르고 있는 그림이 만들어짐

# __플러그인에 대한 논의

VS ← ReSharper 의 관계 : ReSharper 는 노예수준

종속성으로 업무규칙이 깨지는 걸 막기 위해서는 경계는 필수이다.

선 긋기는 단일 책임 원칙하고도 연관이 있는 내용

# __결론

경계선을 그으려면 먼저 시스템을 컴포넌트 단위로 분할해야 함

그으는 꿀팁

1. 일부 컴포넌트는 `핵심 업무 규칙`에 해당
2. 핵심 업무와는 직접 연관이 없지만 필수기능을 포함하는 나머지 컴포넌트는 `플러그인`에 해당
3. 컴포넌트 사이의 화살표가 핵심 업무를 향하도록 컴포넌트의 소스를 배치함

의존성 역전 원칙, 안정된 추상화 원칙을 응용한 것이기도 함

의존성 화살표는 저수준 세부사항 → 고수준 추상화를 향하도록 배치할 것

# 18장 경계 해부학

시스템 아키텍처는 일련의 소프트웨어 컴포넌트와 그 컴포넌트를 구분하는 경계에 의해 정의됨

# __경계 횡단하기

런타임에 경계를 횡단한다 = 경계 한 쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일 → ???

적절한 위치에서 경계를 횡단하는 비결은 소스코드 의존성 관리에 있음

왜 소스코드일까?

소스 코드 모듈 하나만 변경되어도 
이에 의존하는 다른 소스코드 모듈도 변경하거나, 다시 컴파일해서 배포해야 할 수 있기 때문

경계는 일종의 방화벽

# __두려운 단일체

가장 단순한 아키텍처 : 물리적으로 엄격하게 구분되지 않는 형태 
(함수와 데이터가 단일 프로세서에서 같은 주소공간을 공유하며 나름의 규칙은 있음)
= 단일체, 소스수준 분리 모드, 모노리틱

단일체는 커다란 하나의 파일을 배포하므로 경계선이 없음 (= 배포관점에서 눈에 보이지 않음)

모노리틱에서는 정적 다형성 (ex. 제네릭, 템플릿 등) 을 이용해 내부 의존성을 관리

1. 객체지향 개발이 아주 중요한 패러다임이 될 수 있던 요인
2. 포인터에서 탈출하고 컴포넌트를 분리하려는 시도를 할 수 있게 된 요인

가장 단순한 형태의 경계 횡단 : 저수준 클라이언트 → 고수준 서비스로 향하는 함수 호출

예 1. 왼쪽에서 오른쪽으로 경계를 횡단하는 제어흐름

Client → Service

             ↘︎      ↓

                    Data

         경계선

1. Client 는 Service 의 `f()` 를 호출
2. Client 는 Data 인스턴스를 전달 (여기서 Data 는 고수준 클라이언트)
3. 고수준 클라이언트가 저수준 서비스를 호출해야 할 시, 동작 다형성을 활용해 제어흐름을 역전
(Data)

예 2.  왼쪽에서 오른쪽으로 경계를 횡단하는 제어 흐름

Client → Service ← ServiceImpl 

   ↓                       경계선

Data                                ⏎ 

1. 고수준 클라이언트인 Client 는 Service 인터페이스를 상속받는 ServiceImpl 의 `f()` 호출
2. Data 또한 호출하는 쪽에 위치함

예1, 예2 를 통해 정적 링크된 모노리틱 구조도 이런 규칙적인 방식을 가질 수 있고
이는 개발, 배포, 테스트에 도움이 됨

고수준 컴포넌트는 저수준 세부사항으로부터 독립적으로 유지됨

단일체 내에서 컴포넌트간 통신은 값싸다 (단순 함수호출이므로)

컴파일과 정적 링크 작업을 수반하므로, 모노리틱에서 컴포넌트는 소스코드 형태로 전달됨 → ???

# __배포형 컴포넌트

동적 링크 라이브러리를 통해 아키텍처의 경계가 물리적으로 드러날 수 있음

닷넷 DLL, jar 파일, 유닉스 공유 라이브러리가 그 예

배포 수준 결합 분리 모드에 해당함

배포 가능한 단위를 좀 더 편리한 상태로 묶는 일에 지나지 않음
(WAR 파일, 디렉터리 형태로 묶음)

왠만한 전략들은 단일체와 동일

단일체와 마찬가지로 함수호출에 지나지 않으므로 매우 값싸며, 
동적 링크, 런타임 로딩 등의 변수가 있지만 경계를 가로지르는 통신은 매우 빈번할 것

# __스레드

단일체, 배포형 모두 활용 가능

실행 계획과 순서를 체계화 하는 방법에 가까움

# __로컬 프로세스

명령행이나 시스템 호출을 통해 생성

동일한 프로세서, 하나의 멀티코어 시스템에 속한 여러프로세서들에서 실행됨
각각의 독립된 주소공간에서 실행됨

운영체제 호출, 데이터 마샬링/언마샬링, 프로세스간 문맥 교환, 소켓, 메일박스, 메시지큐 등 
운영체제 차원의 통신 기능을 활용하여 서로 통신

일종의 최상위 컴포넌트라 봐도 무방

저수준 내용을 고수준이 알면 안됨

# __서비스

가장 강한 물리적 형태를 띄는 경계

모든 통신이 네트워크를 통해 이뤄진다 가정함

빈번하게 통신하는 일을 피해야 함 (API 통신이 될수도 있으니까)

고수준 서비스에는 저수준 서비스를 특정짓는 어떤 물리적인 정보(ex. URI 등) 도 포함되면 안됨

# __결론

단일체를 제외하면 저 위의 경우 중 하나의 아키텍트를 가지고 있음

한 시스템 안에서도 빈번한 로컬 경계와 지연을 중요하게 고려해야 하는 경계가 혼합되어 있음

# __결론

시스템의 결합 분리 모드는 시간이 지나면서 바뀌고, 변경을 예측하여 무리없이 반영할 수 있도록 해야함

# 19장 정책과 수준
소프트웨어 시스템 : 정책을 기술한 것

컴퓨터 프로그램 : 각 입력을 출력으로 변환하는 정책을 상세하게 기술한 설명

대다수의 주요 시스템에서 하나의 정책은 
이 정책을 서술하는 여러개의 조그만 정책들로 쪼갤 수 있음

ex. 집계와 관련된 업무 규칙을 처리하는 방식을 서술하는 정책 
       (앱에도 회원, 상품 등 각 항목마다 정책이 있다)

아키텍처 개발 기술에는 `정책을 신중하게 분리`하고, 정책 변경 양상에 따라 `정책을 재편성`하는 일도 포함됨

정책을 신중하게 분리

1. 동일한 이유로, 동일한 시점에 변경되는 정책은 동일한 컴포넌트에 속해야 함
2. 다른 이유, 다른 시점은 다른 컴포넌트로 분리되어야 함

정점 : 동일한 수준을 나타내는 컴포넌트

간선 : 컴포넌트 사이의 의존성

의존성의 예 : Java 의 import, C# 의 using, 루비의 require 구문 등

의존성의 방향이 컴포넌트의 수준을 기반으로 연결되도록 만들어야 함 
(= 저수준 컴포넌트가 고수준 컴포넌트를 의존하도록 해야 함)

# __수준

입력과 출력까지의 거리

입력과 출력 모두로부터 멀수록 정책의 수준은 높아짐

입력과 출력을 다루는 정책은 시스템에서 최하위 수준에 위치함

예 1. 간단한 암호화 프로그램

입력 장치에서 문자를 읽어, 테이블을 참조하여 문자를 번역한 후, 번역된 문자를 출력 장치로 기록

도식화 형태로 표현한다면

        문자       문자

        →          →

문자 읽기 `→` 번역 `←` 문자 쓰기

프로그램을 제대로 설계했다면 `블록 처리` 된 화살표는 점선이 되어야 함

특징

1. 번역 컴포넌트는 가장 고수준의 컴포넌트 (입력과 출력에서 가장 멀리 떨어져 있기 때문)
2. 데이터 흐름과 소스코드 의존성이 항상 같은 방향을 가리키지는 않음
3. 무조건 데이터의 흐름을 기준대로, 소스코드 의존성을 처리하면 안됨

잘못된 아키텍트

```kotlin
fun encrypt() {
	while(true){
		writeChar(translate(readChar()));
	}
}
```

암호화 함수가 저수준인 읽기와 쓰기 함수에 의존하기 때문에 잘못된 아키텍트

올바른 아키텍트

```kotlin
val charReader: CharReader = ConsoleReader()
val charWriter: CharWriter = ConsoleWriter()

fun encrypt() {
	charWriter.writeChar(translate(charReader.read())));
}
```

별 차이가 없어보이지만 encrypt 함수와 
실질적 입출력을 담당하는 ConsoleReader, ConsoleWriter 는 
CharReader, CharWriter 에 의존한다

입출력에 변화가 생기면 ConsoleReader, ConsoleWriter 을 수정하면 됨
(encrypt() 에는 영향을 1도 끼치지 않음)

단일 책임 원칙 (SRP), 공통 폐쇄 원칙 (CCP) 에 따르면 동일한 시점에 변경되는 정책은 함께 묶임

고수준은 변경이 덜하고, 보다 중요한 이유로 변경됨
저수준은 변경이 빈번하고, 보다 긴급을 요하고 덜 중요한 이유로 변경됨

위 내용은 저수준 컴포넌트가 고수준 컴포넌트에 플러그인 되어야 한다는 관점으로 볼 수도 있음

Encryption <= IO Device

# __결론

객체지향 5원칙을 모두 포함하는 내용이었음

각 원칙이 어떻게 사용되었는지 분석할 필요가 있음

# 20장 업무 규칙
업무 규칙 : 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차

업무 규칙이 실제 무엇인지 잘 이해해야 함

ex. 대출에 N% 이자를 부과 : 은행이 돈 버는 업무 규칙

핵심 업무 규칙

사업 자체에 핵심적이며 반드시 존재해야 하는 `업무 규칙`

보통 핵심 업무 데이터를 요구 (ex. 대출 : 대출 잔액, 이자율, 지급 일정)

핵심 업무 규칙과 핵심 업무 데이터는 본질적으로 결합되어 있고 객체로 만들기 좋음
( = 엔티티)

# __엔티티

컴퓨터 시스템 내부의 객체

핵심 업무 데이터를 기반으로 동작하는 일련의 핵심 업무 규칙을 구체화함

ex. 대출 (Loan)

```kotlin
class Loan {
  val principle: Long
  val rate: Double
  val period: Int
  
  fun makePayment(){}
  fun applyInterest(){}
  fun chargeLateFee(){}
}
```

업무의 대표자로서 독립적으로 존재함

DB, 사용자 인터페이스 등 다른 요소에 의해 오염되면 절대 안됨

어떤 시스템에서도 업무를 수행할 수 있음 (순전한 업무에 대한 것만 있으며 이외의 것은 없음)

# __유스케이스

자동화된 시스템이 사용되는 방법을 설명 (일종의 비즈니스 로직?)

ex. 대출 담당자가 신청자의 신상 정보를 수집하여 검증한 후 
       신청자의 신용도가 500보다 낮다면 대출 견적제공 안하기로 함

아래 내용을 기술함

1. 사용자가 제공해야 하는 입력
2. 사용자에게 보여줄 출력
3. 해당 출력을 생성하기 위한 처리단계

예제로 살펴보기. 신규 대출을 위한 신상정보 수집하기

입력: 이름, 주소, 생일 등

출력 : 사용자 확인을 위한 동일한 정보, 신용도

기본 과정

1. 이름을 받아 검증
2. 주소 생일 등을 검증
3. 신용도를 얻음
4. 신용도가 500보다 낮으면 거절 활성화
5. 높으면 customer 생성 및 LoanEstimation (대출 견적) 을 활성화

특징

1. 엔티티에 대한 참조가 있을수도 있음
    
    위에서는 Customer 엔티티 언급을 통해 참조하며
    은행과 고객의 관계를 결정짓는 핵심 업무 규칙이 Custom 엔티티에 포함됨을 의미함
    
2. 사용자 인터페이스를 기술하지 않음
    
    뭘 통해 전달되는지, 어떤 기반인지 등을 일절 알수 없음
    
    사용자에게 어떻게 보이는지 설명하지 않음
    
3. 객체
    
    업무 규칙, 업무 데이터를 가지고 있음
    
4. 엔티티는 자신을 제어하는 유스케이스에 대해 알지 못함
    
    엔티티는 고수준 개념
    
    엔티티는 유스케이스에 의존하지 않음
    
    의존성 역전 원칙을 준수하는 의존성 방향의 또다른 예
    
5. 저수준
    
    단일 애플리케이션에 특화되어 있으므로 시스템의 입출력과 가까움
    
    (엔티티는 일반화된 개념이므로 멀리 떨어져 있는 편)
    

<aside>
💭 어찌보면 당연한 내용을 풀어쓴건데 
원칙에 입각해서 현재 플젝을 바라볼 수 있게 되는듯하다.

</aside>

# __요청 및 응답 모델

유스케이스는 입력 데이터를 받아 출력 데이터를 생성

유스케이스 객체는 데이터를 사용자나 또 다른 컴포넌트에 주고받는 방식에 대해 전혀 몰라야 함

ex. 유스케이스의 코드가 HTML 이나 SQL 에 대해 몰라야 함

```kotlin
단순한 요청 데이터 구조를 입력으로 받아들이고 
단순한 응답 데이터 구조를 출력으로 반환해야 함
```

요청 및 응답이 의존적이라면 그 모델에 의존하는 유스케이스도 의존성에 결합되어 버림 (종속의 늪)

`엔티티 객체`를 가리키는 참조를 `요청 및 응답 데이터 구조`에 포함하려는 유혹을 받을 수 있음

두 객체의 목적은 완전히 다르며 반드시 분리될 것임

# __결론

업무 규칙은 소프트웨어 시스템이 존재하는 이유

업무 규칙은 집안의 가보

시스템에서 가장 독립적이고, 가장 재사용할 수 있어야 함

# 21장 소리치는 아키텍처

우리의 서비스는 어떤 외침을 하고 있는가?

1. 헬스 케어 시스템이야
2. 루비 온 레일스야
3. MVVM 이야

# __아키텍처의 테마

Object Oriented Software Engineering - 유스케이스 주도 접근법

소프트웨어 아키텍처는 시스템의 유스케이스를 지원하는 구조

아키텍처는 프레임워크에 대한 것이 아님 (그래선 안됨)

유스케이스(업무 규칙)이 중심이 되어야 함

# __아키텍처의 목적

주택은 거주(유스케이스)에 적합해야지, 벽돌 품질(프레임워크)가 중요한 것이 아님

정하더라도 유스케이스를 먼저 만족시키고 해야함

지엽적인 관심사에 대한 결합은 분리시킴 (선택을 열어두고 쉽게 바꿀 수 있도록)

# __하지만 웹은?

단순 전달 매개체일뿐

아키텍처를 고치지 않더라도 어디든지 보낼 수 있어야 함

# __프레임워크는 도구일 뿐, 삶의 방식은 아니다

아키텍처를 유스케이스에 중점을 둔채 그대로 보존할 수 있을지를 생각하기

<aside>
💭 모바일은 언어 종속성이 있어 해당되지 않겠다고 생각하겠지만 전혀 아니다
이는 아키텍처 구조, 라이브러리 등에 대치시켜 생각할 수 있다.

MV 라고 해서 유지보수가 어렵거나, 코드 파악이 어려운 건 아니고
MVVM 이나 MVI 라고 해서 무조건 파악이 쉬운건 아니다

어떤 라이브러리 (ex. ~~Volley~~, Retrofit, only OkHttp3 등) 를 쓰느냐에 따라 
Api 단이 바뀌어야지 Repository 단이 바뀌면 안된다.

</aside>

# __테스트하기 쉬운 아키텍처

유스케이스 전체에 대해 단위 테스트를 할 수 있어야 함

엔티티 객체는 간단한 객체여야함

DB, 웹서버가 있어야만 테스트가 가능해서도 안됨

<aside>
💭 개인적으로 유닛 테스트를 좋아하는 이유가 이것

속도 뿐만 아니라 이런 종속성 없이 체크하는 데 너무나도 편하다

하지만 어쩔 수 없는 경우(UI 테스트)엔 종속성이 필요할 것이다

UI 테스트 속도가 개차반이긴 하지만 지금 activity 에 기반하여 작성되어있는 유닛 테스트는

언젠가 UI 테스트로 바뀌어야 될 것 같다는 생각이다.

</aside>

# __결론

아키텍처는 시스템을 말해야 함

위에서 보았다시피 우리 앱을 말할 때 주제를 이야기해야 함 (헬스 케어 시스템)

누군가 구조에 대해 물어본다면 나중에 결정될 내용이라 쳐낼 수 있어야 함

# 22장 클린 아키텍처

`관심사의 분리`가 주 목적

소프트웨어를 계층으로 분리하여 이 목표를 달성하려 함

아래 요건을 지키고자 함

1. 프레임워크 독립성
    
    프레임워크에 의존하지 않는다.
    
2. 테스트 용이성
    
    업무 규칙은 UI, DB, 웹서버 없이도 테스트 가능해야 함
    
3. UI 독립성
    
    시스템을 변경하지 않고도 UI 를 변경할 수 있어야 함
    
4. DB 독립성
    
    어떤 DB 를 쓰든 동작해야 함
    
5. 모든 외부 에이전시에 대한 독립성
    
    업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못해야 함

![image](https://user-images.githubusercontent.com/13694046/140648106-bae516b6-57c6-4c38-805b-3f75401fe118.png)

# __의존성 규칙

안으로 들어갈수록 고수준

바깥쪽 원은 매커니즘, 안쪽 원은 정책

<aside>
👉 **소스코드 의존성은 반드시 안쪽으로`만` 향해야 한다**

</aside>

내부 원은 외부에 대해 일절 몰라야 함

## 엔티티 (노란색)

전사적인 핵심 업무 규칙을 캡슐화

메서드를 가지고 있는 객체이거나, 일련의 데이터 구조와 함수의 집합이거나

재사용할수만 있다면 형태는 중요하지 않음

운영 관점에서 애플리케이션을 변경하더라도 엔티티에는 절대 영향을 주면 안됨

## 유스 케이스 (주황색)

애플리케이션에 특화된 업무 규칙을 포함함

시스템의 모든 유스케이스를 캡슐화하고 구현함

엔티티가 자신의 핵심 업무 규칙(메서드)를 사용해서 
유스케이스의 목적을 달성하도록 이끔

## 인터페이스 어댑터 (초록색)

일련의 어댑터로 구성

GUI, MVC 아키텍처(프레젠터, 뷰, 컨트롤러, 뷰모델), DB(SQL) 모두 포괄

데이터를 외부 서비스와 같은 외부적인 형식에서 
유스케이스나 엔티티에서 사용되는 내부적인 형식으로 변환하는 또다른 어댑터가 필요 (Mapper?)

## 프레임워크와 드라이버 (파란색)

프레임워크, 도구

모든 세부사항이 위치함 (ex. 웹, DB)

## 원이 4개여야 하나?

예시일뿐이며 원의 의존성에 대해 이해하는 게 더 중요함

## 경계 횡단하기

![image](https://user-images.githubusercontent.com/13694046/140648095-dac105cb-112b-44f2-8bff-4c2320a8131e.png)

## 경계를 횡단하는 데이터는 어떤 모습인가?

경계를 가로지르는 데이터는 흔히 간단한 데이터 구조

기본적인 구조체 or 간단한 데이터 전송 객체 (DTO)

간단한 인자를 이용해 데이터로 전달 or 해시맵으로 묶거나 객체로 구성할수도 있음

이 데이터가 경계를 가로지른다는 게 중요한 key Point

ex. DB 프레임워크 : 쿼리에 대한 응답으로 사용하기 편한 데이터 포맷 사용

행 구조인 경우가 많은데, 이 행 자체가 내부로 그대로 전달되는 걸 원하지 않음
(내부의 원에서 외부 원의 무언가를 알아야 하기 때문)

데이터는 내부의 원에서 사용하기 가장 편리해야함

<aside>
💭 엔티티를 처음엔 데이터 객체로 생각했었는데 다른 의미인것 같다

</aside>

# __전형적인 시나리오

이건 계속 책의 내용을 보면서 이해하는 걸 추천한다

<aside>
💭 TextExt, TextUtil 형태로 모든 화면에서 종속성을 갖는 함수를 가지면서
단순 유틸 기능을 갖는 로직은 어떻게 처리하는 게 좋을까?

View 는 필수이고 경우에 따라 ViewModel 또는 Repository 등에서도 활용될 수 있는데 
이 코드 하나만 고치면 모든 곳에 영향을 끼치게 된다

하지만 이로 인해 중복을 줄일 수 있고, 정책에 순조롭게 맞춰 작업할 수 있다

</aside>

# __결론

이러한 클린 구조는 테스트 하기에도 편해진다.
