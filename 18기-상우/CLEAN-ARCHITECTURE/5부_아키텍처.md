# 15장 아키텍처란?

권력과 신비로움? 누군가는 꿈꿀 수 있는 이상적인 직업?

소프트웨어 아키텍트

1. 프로그래머
2. 고수준의 문제에만 집중해야 하는 건 아님
3. 최고의 프로그래머이자 앞으로도 프로그래밍 작업을 맡을 뿐 아니라
나머지 팀원들이 생산성을 극대화할 수 있는 설계를 하도록 방향을 이끔
4. 프로그래밍 작업은 지속적으로 참여

소프트웨어 시스템의 아키텍쳐

1. 시스템을 구축했던 사람들이 만들어낸 시스템의 형태
2. 아키텍처 안에 담긴 SW 시스템이 쉽게 개발, 배포, 운영, 유지보수 되도록 만들어짐
3. 가능한한 많은 선택지로, 가능한한 오래 남겨두는 전략을 따라야 함
4. 소프트웨어 아키텍처의 목표는 시스템의 동작 여부와는 관련이 멈
(형편 없는 아키텍처도 동작은 함)
5. 운영보다는 배포, 유지보수, 개발 과정에서 어려움이 있음

좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하고, 쉽게 유지보수하고, 쉽게 배포하게 해줌

# __개발

팀원이 작을 경우, 모노리틱 시스템으로도 운영 가능
(오히려 아키텍처가 방해가 될 수 있음)

팀원이 많을 경우 (7명씩으로 구성된 총 5팀), 
잘 설계된 컴포넌트 단위로 분리하지 않으면 개발이 진척되지 않음

팀별 단일 컴포넌트 아키텍처가 시스템을 배포, 운영, 유지보수하는 데 최적일 가능성은 거의 없음

순전히 일정에만 쫒겨일한다면 이렇게 될 것

시스템 아키텍처는 `개발팀이 시스템을 쉽게 개발할 수 있도록` 해야함

# __배포

배포 비용이 높을수록 시스템의 유용성은 떨어짐

시스템을 `단 한번에 쉽게 배포할 수 있도록` 만드는데 그 목표를 두어야 함

마이크로서비스 아키텍처

- 컴포넌트 경계가 뚜렷해지고 인터페이스도 대체로 안정화되므로 
시스템을 매우 쉽게 개발할 수 있다고 판단했을 확률이 높음
- 하지만 배포 시기 시 마이크로서비스들을 서로 연결하기 위한 설정, 작동순서 결정 등
오히려 오작동이 발생할 원천이 생길수도 있음

더 적은 서비스를 사용, 서비스 컴포넌트와 프로세스 수준의 컴포넌트를 하이브리드 형태로 융합하며 
좀 더 통합된 도구로 사용해 상호 연결을 관리했어야 함 → ??

# __운영

개발, 배포, 유지보수에 미치는 영향보다는 덜 극적

하드웨어 단순 투입으로도 해결 가능

하지만 아주 연관이 없지만은 않음 - 시스템을 운영하는 데 필요한 요구도 알려줌

개발자에게 시스템의 운영 방식을 잘 드러내준다고 할 수 있음

유스케이스, 기능, 시스템의 필수행위를 1급 엔티티로 격상시킴

→ 솔직히 잘 이해되지 않음

# __유지보수

유지보수는 소프트웨어 시스템에서 가장 비싼 작업

탐사와 이로 인한 위험 부담

탐사
기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때 
소프트웨어를 파헤쳐 어디를 수정해야 하는지, 어떤 전략을 써야할지를 결정할 때 드는 비용

시스템을 컴포넌트로 분리하기

안정된 인터페이스를 두어 격리하기 
(최근 프로젝트에서 차트 로직 및 변수를 인터페이스로 분리해서 기능 추가에 별다른 어려움을 겪지 않았음)

# __선택사항 열어 두기

소프트웨어는 행위적 가치, **`구조적 가치`**를 지님

`구조적 가치` : 소프트웨어를 유연하게 만듬

소프트웨어를 만든 이유 : 기계의 행위를 빠르고 쉽게 변경 가능

유연성은 시스템의 형태, 컴포넌트의 배치 방식, 컴포넌트가 상호 연결되는 방식에 크게 의존함

소프트웨어를 부드럽게 만드는 방법

1. 선택사항을 가능한한 많이 (하나의 함수가 다양한 작업을 하도록?)
    
    선택사항 : 중요치 않은 세부사항
    
2. 그리고 가능한 한 오랫동안 열어두는 것 (주석?)

(K 모 특정 개발자가 추구하는 방법인 것 같기도 하다)

모든 소프트웨어 시스템 = 정책 + 세부사항

1. 정책
    
    모든 업무 규칙과 절차를 구체화
    
    시스템의 진정한 가치가 살아 있는 곳
    
2. 세부사항
    
    사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소
    
    정책이 가진 행위에는 조금도 영향을 끼치지 않음
    
    입출력 장치, DB, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등
    

아키텍트의 목표

시스템에서 정책을 `가장 핵심적인 요소로 식별`하고
세부사항은 `정책과 무관하게 만들 수 있는 형태의 시스템을 구축`하는 데 있음

이로 인해 세부사항을 결정하는 일은 미루거나 연기할 수 있게 됨?

ex. 

1. 개발 초기에는 DB 시스템을 선택할 필요가 없음 (관계형이든, 분산형이든 다 동작하도록)
2. 개발 초기에는 웹 서버를 선택할 필요가 없음 (웹을 통해 전송할 것인지 조차도 정할 필요 없음)
3. REST, 마이크로서비스, SOA 다 필요 없음
4. 처음엔 의존성 주입을 쓸 필요가 없음

→ 고수준의 정책은 세부적인 것에 신경을 쓸 필요가 없다.
     세부사항에 신경쓰지 않고 고수준의 정책을 만드는 데 집중하자 (세부사항은 나중으로 미루자)

→ 미리 정하지 않음으로서 실험을 해볼 수 있고, 더 많은 것을 시도할 수 있다.

좋은 아키텍처는 결정되지 않은 사항의 수를 최대화한다.

# __장치 독립성

장치 종속성

- 코드를 입출력 장치와 직접 결합
    
    ex. 프린터 인쇄 시 해당 프린터를 제어하는 입출력 명령어 직접 사용해서 코드를 작성
    
    ex. 카드 판독기를 직접 조작하는 코드를 작성
    
- 데이터 무결성이 대두되면서 실수라는 걸 알게 됨

오늘날 운영체제

입출력 장치를 소프트웨어 함수로 `추상화`함

해당 함수는 단위 레코드를 처리함

프로그램은 운영체제의 서비스를 호출함

해당 서비스가 추상화된 단위 레코드 장치를 처리함

→ 동일한 프로그램을 아무런 변경 없이 카드에서 읽고 쓰거나 테이프에서 읽고 쓸 수 있게됨

     (개방 폐쇄의 원칙)

안드로이드에선 뭘 예로 생각할 수 있을까?

지금 프로젝트에서 차트가 유독 기억에 남는다.
홈 화면에서 사용되던 차트를, BottomSheet 에서도 활용하면서 
일일히 구현을 그대로 복붙에서 똑같은 코드를 만들었다

그 직전에 차트의 ViewModel 종속성을 뺀 적이 있었는데 이게 정말 큰 도움이 되었었다.

이런 과정에서 얻은 생각은 이랬다
좀더 많은 함수와 변수를 추상화 했어야 했고, 함수를 변수화해서 넘기는 건 너무나 사기 기능이다.

아마 차트를 다른 화면에서 사용하는 걸 확장이라 할 수 있을 것 같고
추상화된 함수는 각 OS(OS X, WIndow 등) 의 기본 추상화 함수로 정리가 된다.

# __광고 우편

이름과 주소레코드만 바꿔 지정된 종이 템플릿에 찍기

- 라인 프린터 → 자기 테이프 및 오프라인 프린터 활용 ( + 테스트는 컴퓨터에 직접 연결된 라인프린터)
- 많은 시간 절약

정책 : 이름과 주소 레코드에 대한 서식

세부사항 : 장치

정책에 맞춰 세부사항을 바꿀 수 있어야 한다.

# __물리적 주소 할당

지역 트럭 운정수 조합을 위한 대규모 회계 시스템

- 소프트웨어가 디스크의 상세 구조를 알도록 만듬 ( = 하드 코딩)
- 스케일 업시 하드웨어의 정보를 모두 알 수 있도록 해야 함
- 상대주소를 통해 하드웨어로부터 분리시킴

이런 경우도 있었구나... 

# __결론

좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려냄

정책이 세부사항과 결합되지 않도록 함 
(누가 안드도 파이썬으로 할 수 있게 만들...? 그럼 세부사항(Kotlin) 고민할 필요없어짐)

세부사항을 최대한 뒤로 미루어라

# 16장 독립성

# __유스케이스

시스템의 아키텍처는 시스템의 의도를 지원해야함

ex. 장바구니 애플리케이션

- 장바구니와 관련된 유스케이스를 지원해야 함

아키텍처는 시스템의 행위에 그다지 큰 영향을 주지 않음

- 행위와 관련하여 아키텍처가 열어둘 수 있는 선택사항은 거의 없음
- 행위를 명확히 하고 외부로 드러내며 이를 시스템이 지닌 의도를 
아키텍처 수준에서 알아볼 수 있게 만들어야 함 → ???
- 클래스, 함수 또는 모듈로서 아키텍처 내에서 핵심적인 자리를 차지함
+ 자신의 기능을 분명하게 설명하는 이름을 가질 것

# __운영

시스템이 초당 10만명의 고객을 처리해야 한다면, 
아키텍처는 이 요구와 관련된 각 유스케이스에 걸맞는 처리량과 응답 시간을 보장해야 함

아키텍트는 각 상황에 유연하게 대처할 수 있도록 작성해야함

특정 기능을 알면서 써야하는 이유에 대해 언급한 것 같기도 하다.

# __개발

시스템을 설계하는 조직이라면 어디든지, 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.

잘 격리되어 독립적으로 개발가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 함

# __배포

목표는 즉각적인 배포

시스템이 빌드된 후 즉각 배포될 수 있도록 해야 함

시스템을 컴포넌트 단위로 적절하게 분할하고 격리시키는 게 중요

마스터 컴포넌트는 시스템 전체를 하나로 묶고, 감 컴포넌트를 올바르게 구동, 통합, 관리해야 함

# __선택사항 열어놓기

우리는 모든 유스케이스를 알 수 없다

운영 제약사항, 팀구조, 배포 요구사항도 알 수 없다

생명주기의 단계를 하나씩 거쳐가면서 이 사항들도 바뀐다

몇몇 아키텍처 원칙은 도움이 될 수 있다 (객체지향 5원칙 또 나오나요)

선택사항을 열어두어 언제든 쉽게 변경할 수 있도록 해야함

# __계층 결합 분리

아키텍처는 시스템의 기본적인 의도는 분명히 알고 있음 (시스템이 뭐하는 시스템인지 알고 있음)

단일 책임 원칙, 공통 폐쇄 원칙을 활용해 
다른 이유로 변경 되는 것들은 분리하고, 동일한 이유로 변경되는 건 묶음

서로 다른 이유로 변경되는 것의 예

1. 사용자 인터페이스가 변경되는 이유
    
    업무 규칙과는 아무런 관련이 없음
    
    유스케이스가 두 가지 요소를 모두 포함한다면 
    뛰어난 아키텍트는 유스케이스에서 UI 부분, 업무 규칙 부분을 서로 분리하고자 할 것
    
    두 요소를 독립적으로 변경이 가능해지고, 유스케이스를 분명히 유지 가능
    
2. 카테고리가 다른 업무 규칙
    
    입력 필드 유효성 검사 (애플리케이션 관련 업무 규칙), 계좌 이자 계산(업무 도메인 관련 규칙)
    
    이 두개의 규칙은 다른 속도로, 다른 이유로 변경되므로 분리되어야 함
    

→ 시스템의 나머지 부분으로부터 분리하여 독립적으로 변경할 수 있도록 해야함

그래서 단일 책임 원칙, 공통 폐쇄 원칙을 많이 물어보는구나

모바일에서 위의 두 개를 적극 활용하는 예를 리서치해봐야겠다.

# __유스케이스 결합 분리

1. 유스케이스는 시스템을 분할하는 매우 자연스러운 방법
    
    ex. 주문 입력 시스템에서 `주문을 추가`하는 유스케이스와 `주문을 삭제`하는 유스케이스
    
           개발 속도가 다르고, 다른 이유로 변경될 수 있다.
    
2. 유스케이스는 시스템의 수평적인 계층을 가로지르도록 자른 수직으로 좁다란 조각
    
    각 유스케이스는 UI 일부, 특화업무규칙 일부, 독립적 업무 규칙 일부, DB 일부 등을 사용
    
    시스템을 수평적 계층으로 분할하면서 동시에 
    해당 계층을 가로지르는 얇은 수직적인 유스케이스로 분할할 수 있음 → ???
    
    [위에서 언급한 내용의 예](https://www.notion.so/e1d23623d84b43b7b25eb19ed48f5847)
    
    분석
    
    1. 결합을 분리하기위해 각 유스케이스에 맞춰 UI 를 분리함 (나머지도 마찬가지)
    (수평적 관점)
    2. 아래까지 수직으로 내려가면서 유스케이스는 각 계층에서 겹치지 않음
    (수직적 관점)
    
    DB 에 취소선을 그어가면서 Repository 를 하나로 두고, 업무 로직 계층을 함수로 둔 이유
    
    클린 아키텍처의 예로 모든 로직 자체를 클래스화해서 관리하는 경우도 있긴하다
    (실제 그렇게 작성해보기도 했다)
    
    너무 분리하면 독립성은 높아지지만 그만큼 뻣뻣한 코드가 된다고 생각이 들어 난 이렇게 두어봤다
    
    진짜 저 2개밖에 로직이 없는 경우엔 
    하나의 파일에서 함수형태로 관리해도 가독성이나 로직을 찾는덴 무리가 없다고 느껴진다.
    

서로 다른 이유로 변경되는 요소들의 결합을 분리하면 
기존 요소에 지장을 주지 않고 새로운 유스케이스를 추가시킬 수 있음

유스케이스를 뒷받침하는 UI, 데이터베이스를 묶어
각 유스케이스가 UI 와 데이터베이스의 서로 다른 관점을 사용할 시 
새로운 유스케이스를 추가하더라도 기존 유스케이스에 영향을 주는 일은 거의 없을 것

UseCase 를 클래스 형태로 만들어 직접 invoke 하는 형태로 처리하면 
영향을 주는일이 거의 없긴 할 것이다

또 그걸 쉽게 사용하고 UseCase 의 구현형태는 알 수 없도록 façade 패턴을 사용한다 하면 
으... 머리아프다.

관점지향 프로그래밍 (AOP)

횡단 관심사를 분리하여 모듈화를 높임

코드 자체를 수정하지 않고 기존의 코드에 추가하는 방식(?)으로 구현

ex. 예외처리(?!), 로깅(!!), 인증, 트랜젝션

# __결합 분리 모드

결합이 분리될 시 장점

1. 높은 처리량을 보장하는 유스케이스와, 낮은 처리량으로도 충분한 유스케이스가 이미 분리되어 있음
2. UI 와 DB 가 업무 규칙과 분리되어 있을 시, UI 와 DB는 업무규칙과 다른 서버에서 실행될 수 있음
    
    (높은 처리량이 필요한 유스케이스는 여러 서버로 복제하여 실행 가능)
    
    ( = 제약이 없어짐)
    

결합을 분리할 때 적절한 모드를 선택해야 함

ex. 분리된 컴포넌트를 서로 다른 서버에서 실행해야 할 경우, 
       이들 컴포넌트가 단일 프로세서의 동일한 주소공간에 상주하는 형태로 만들어지면 안됨

분리된 컴포넌트는 반드시 독립된 서비스가 되어야하고, 일종의 네트워크를 통해 서로 통신해야함
(= 마이크로서비스)

우리는 때때로 컴포넌트를 서비스 수준까지도 분리해야함

이전에 배웠다시피 우리는 선택권을 열어두어야 함

# __개발 독립성

컴포넌트가 완전 분리되었다면 팀 사이의 간섭은 줄어듬

ex. 업무 규칙이 UI 를 알지 못하면 UI 에 중점을 둔 팀은 업무 규칙에 중점을 둔 팀에 그다지 영향을 줄 수 없음

ex. 주문 추가 팀이, 주문 제거 팀에 영향을 줄 가능성은 거의 없음

# __배포 독립성

배포 측면에도 고도의 유연성 생김

새로운 유스케이스를 추가하는 일 = 시스템의 나머지는 그대로 둔 채 새로운 jar 파일 및 서비스 몇 개 추가하는 일

# __중복

SW 에서 중복은 일반적으로 나쁜 것

진짜 중복

- 한 인스턴스가 변경되면 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야함

우발적인 중복

- 중복으로 보이는 두 코드 영역이 각자의 경로로 발전한다면 두 코드는 진짜 중복이 아님
(프로필 화면과 1:1 대응에서의 이미지 업로드는 겹치는 게 어쩌면 아니었을까...?)

진짜 중복일까? 우발적 중복일까?

- 사실 중복이 아닐수도 있을 것이다.
- 진짜 중복만 없애도록 하라
- ViewModel 을 별도로 만드는 일은 계층간 결합을 분리하여 유지하는데도 도움이 될 것이다

# __결합 분리 모드(다시)

계층과 유스케이스의 결합을 분리하는 방법은 다양

1. 소스코드 수준에서 분리
    
    소스 코드 모듈 사이의 의존성을 제어
    
    하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 만들 수 있음
    
    모노리틱 구조라고도 부름(?)
    
2. 바이너리 코드 수준에서 분리
    
    jar, DLL, 공유 라이브러리와 같이 배포 가능한 단위들 사이의 의존성을 제어
    
    한 모듈의 소스코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들 수 있음
    
    jar, gem, dll 같이 독립적 배포 가능
    
3. 실행 단위 수준에서 분리
    
    의존하는 수준을 데이터 구조 단위까지 낮춤
    
    순전히 네트워크 패킷을 통해서만 통신하도록 만듬
    
    (ex. 서비스 또는 마이크로 서비스)
    

프로젝트 초기에는 어떤 모드가 정답인지 알 수 없음

나중엔 **`실행 단위 수준에서 분리`**가 필요할 수 있음

단순한 건 **`실행 단위 수준에서 분리`** 선택 (하지만 노력, 메모리, 계산량 측면에서 큰 작업이 될 수 있음)

`바이너리 코드 수준에서 분리` 까지만 두고, 개발 배포 운영 문제 증가 시 
`실행 단위 수준에서 분리`를 고려하는 걸 추천

좋은 아키텍처는 처음에 모노리틱 구조이더라도, 이후에는 서비스 수준까지 성장할 수 있도록 만들 수 있어야함
거꾸로 뒤돌릴수도 있어야 함

개인적으로, 회사원 모두가 이해하고 쉽게 개발, 유지보수가 가능한 구조가
진정한 clean 구조라는 생각이 있다.

# __결론

시스템의 결합 분리 모드는 시간이 지나면서 바뀌고, 변경을 예측하여 무리없이 반영할 수 있도록 해야함
