SOLID 원칙 : 벽과 방에 벽돌을 배치하는 방법

컴포넌트 원칙 : 빌딩에 방을 배치하는 방법

# 12장 컴포넌트

컴포넌트는 배포 단위

시스템의 구성요소로 배포할 수 있는 가장 작은 단위 (ex. java의 jar 파일, 닷넷의 DLL 파일)

컴파일형 언어에서 컴포넌트 : 바이너리 파일의 결합체

인터프리터형 언어에서의 컴포넌트 : 소스 파일의 결합체

모든 언어에서의 컴포넌트 : 배포할 수 있는 단위 입자

여러 컴포넌트를 서로 연결해 실행 가능한 단일 파일로 생성할 수 있음

또는 여러 컴포넌트를 서로 묶어 war 파일과 같은 단일 아카이브로 만들 수 있음

컴포넌트 각각을 동적으로 로드할 수 있는 플러그인(ex. jar, DLL)이나 exe 로 만들어 독립적으로 배포할 수 있음

잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능하고, 독립적으로 개발 가능할 것

# 컴포넌트의 간략한 역사

소프트웨어 개발 초창기

- 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어
- 프로그램을 메모리에 어느 위치에 로드할지까지도 정함
    
    해당 위치가 한 번 결정되면 재배치는 불가능
    
- 라이브러리 함수의 소스 코드를 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일
(= 라이브러리는 바이너리가 아닌 소스코드 형태)
- 메모리 한계 등으로, 함수 라이브러리가 크면 클수록 컴파일은 더 오래 걸림

개선 과정

- 컴파일 시간 단축을 위해 함수 라이브러리의 소스 코드를 애플리케이션 외부로 분리함
- 애플리케이션 실행 시 바이너리 함수 라이브러리를 로드한 다음 애플리케이션 로드
- 고정 메모리를 가지다가 애플리케이션이 커지면서 세그먼트 형태로 분리하여 관리
    
    ( = 임시방편)
    

# 재배치성

1. 재배치가 가능한 바이너리로 위 문제를 해결하려 함
    
    `지능적인 로더`를 사용해 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정
    
    지능적인 로더??
    
    로더는 재배치 코드가 자리할 위치 정보를 전달 받음
    
    재배치 코드에는 로드한 데이터에서 
    어느 부분을 수정해야 정해진 주소에 로드할 수 있는지를 알려주는 플래그가 삽입됨
    (이러한 플래그는 바이너리에서 참조하는 메모리의 시작 주소)
    
    로더는 여러개의 바이너리를 입력받은 후 
    단순히 하나씩 차례로 메모리에 로드하면서 재배치하는 작업을 처리함
    
    위 로더 덕분에 이제 프로그래머는 
    함수 라이브러리를 로드할 위치, 애플리케이션을 로드할 위치를 로더에게 직접 지시할 수 있게 됨
    
2. 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 `메타데이터 형태`로 생성하도록 수정
    
    프로그램이 라이브러리 함수를 호출할 때, 컴파일러는 `라이브러리 함수 이름`을 `외부 참조`로 생성함
    
    반면 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 `해당 프로그램`을 `외부 정의`로 생성함
    
    → 외부 정의를 로드할 위치가 정해지기만 하면, 로더가 외부 참조를 외부 정의에 링크시킬 수 있게 됨
    
    → 링킹 로더(프로그램을 로드하면서 링크까지 수행함) 의 탄생
    

# 링커

링킹 로더 덕분에, 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할 가능해짐

작은 프로그램, 작은 라이브러리에서는 잘 동작하지만 클 경우에는 링킹 로더가 너무 느림
(프로그램 하나 로드하는 데 1시간 이상 걸림)

결국 로드와 링크가 분리됨

링커

프로그래머는 링크를 맡으며, 링커라는 별도의 어플리케이션으로 이 작업을 별도 처리

링크가 완료된 재배치 코드를 만들어, 로딩 속도를 빠르게 만듬 
(한 번 만들어둔 실행파일은 언제라도 빠르게 로드 가능)

그 이후

소스 모듈은 .c 파일에서 .o 파일로 컴파일된 후 링커로 전달되어 
빠르게 로드될 수 있는 형태의 실행 파일로 만들어짐

전체 모듈을 컴파일하는 과정은 꽤 많은 시간이 걸림

하드웨어를 발전시키면서 이는 자연스레 해결

무어의 법칙 : 컴퓨터 속도, 메모리, 집적도가 매 18개월마다 2배로 증가한다. 
(2000년도 이후엔 불가능)

그그 이후

액티브X, 공유 라이브러리 시대가 열리고 jar 파일 등장

다수의 jar 파일, 공유 라이브러리를 순식간에 링크하고, 링크가 끝난 프로그램을 실행함 
(로드와 링크가 다시 합쳐짐)

플러그인 아키텍처로 발전함

ex. 

마인크래프트에 모드를 생성하고 싶을 때 : 단순히 특정 폴더에 우리가 수정한 jar 을 붙임

네이버 로그인을 추가하고 싶을 때 : 네이버 jar 을 넣음 (근데 아직도 jar 로 넣어야 하나?)

# 결론

런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일 = 소프트웨어 컴포넌트

# 13장 컴포넌트 응집도

어떤 클래스를 어느 컴포넌트에 포함시켜야 할까?

# 1. REP: 재사용/릴리스 등가 원칙

재사용 단위는 릴리스 단위와 같다

모듈 관리 도구가 많이 등장함 (ex. Maven 등)

이젠 SW 재사용의 시대에 살고 있음

너무나도 당연해 보임

- 소프트웨어 컴포넌트가 릴리즈 절차를 통해 관리되지 않거나 릴리즈 번호가 부여되지 않는다면
해당 컴포넌트를 사용하지 않음
- 릴리즈 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법도 없음
릴리즈 노트가 왜 있어야 하는지를 생각해보자 (keyword : 히스토리)
- 새로운 릴리즈가 나온다고 하면 기존 버전을 계속 쓸지 여부를 결정함 
(as like 글라이드 버전 업데이트 등)

이 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 

1. 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함
2. 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 함
3. 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리즈가 가능해야 함

이 원칙들을 어긴다면...

# CCP: 공통 폐쇄 원칙

동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶고
서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라

[단일 원칙 책임](https://www.notion.so/7-SRP-aad1ea8e57ec403e9ecbc4ec18e9aa5d)을 컴포넌트 관점에서 다시 쓴 것

단일 컴포넌트는 변경의 이유가 여러개가 있어선 안됨

변경이 여러 컴포넌트 도처에 분산되어 발생하기 보다는 
차라리 변경 모두가 단일 컴포넌트에서 발생하는 것이 낫다

CCP 는 `변경될 가능성이 있는 클래스는 한 곳으로 묶기`를 권장함

물리 혹은 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야 함

동일한 시점에 동일한 이유로 변경되는 것들을 한 곳에 묶고
서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하기

# CRP: 공통 재사용 원칙

컴포넌트 사용자들을, 필요 없는 것에 의존하게 강요하지 않기

같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함시키기

개별 클래스가 단독으로 재사용되는 경우는 거의 없음

대체로 재사용 가능한 클래스는 재사용 모듈의 일부로서 
해당 모듈의 다른 클래스와 상호작용하는 경우가 많은데
CRP 에서는 이런 클래스들이 동일한 컴포넌트에 속해있어야 한다고 주장함

ex. 컨테이너 클래스와 해당 클래스의 이터레이터 클래스

- 이들 클래스는 서로 강하게 결합되어 있음
- 그러므로 동일한 컴포넌트에 위치해야 함

CRP 는 각 컴포넌트에 어떤 클래스들을 포함시켜야 하는지를 설명함

더불어 동일한 클래스로 묶이면 안 되는 클래스가 무엇인지도 설명함 (의존성...)

인지해야 할 내용

1. 한 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없음
2. CRP 로 어떤 클래스를 묶기 보다는, 묶지 않는 쪽에 더 집중해서 보자

인터페이스 분리 원칙(ISP) 과의 관계

ISP 는 사용하지 않은 메서드가 있는 클래스에 의존하지 말라고 함

CRP 는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 함

→ 필요하지 않은 것에 의존하지 마라

# 컴포넌트 응집도에 대한 균형 다이어그램

REP : 재사용성을 위한 그룹

CCP : 유지 보수성을 위한 그룹

CRP : 불필요한 릴리즈를 줄이기 위해 분리하기

REP, CCP 는 포함원칙 ↔ CRP 는 배제원칙

일부 상충되는 내용이 존재하며, 이로 인한 균형 다이어그램도 존재

REP, CRP 에만 중점을 둘 시, 사소한 변경이 생길 시 많은 컴포넌트에 영향을 끼침 
(TextUtil 의 함수명 바꿀 시 모든 패키지에 영향을 끼침)

CCP 와 REP 에만 중점을 둘 시, 불필요한 릴리즈가 많아짐
(각 비즈니스 로직을 모두 클래스화했다고 생각해보자)

처음 프로젝트는 CCP 를 생각하며 시작하고, 점차 REP 를 살려나간다
( = 프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변한다)

# 결론

모듈은 단 하나의 기능만 수행한다 로 이야기되기엔 
컴포넌트 응집도에 대한 3가지 원칙은 훨씬 복잡한 다양성을 설명한다

시간의 흐름에 따라 프로젝트의 초점이 개발가능성에서 재사용성으로 바뀌고
그에 따라 컴포넌트를 구성하는 방식도 진화한다.

# 14장 컴포넌트 결합

개발 가능성과 논리적 설계 사이의 균형

# ADP: 의존성 비순환 원칙

컴포넌트 의존성 그래프에 순환이 있어서는 안된다.

숙취 증후군 : 릴리즈를 작동하게 만들고 퇴근했는데, 누가 수정해서 안 되기 시작했다.

이를 해결하기 위한 방법

1. 주단위 빌드
2. 의존성 비순환 원칙

## 주 단위 빌드

중간 규모의 프로젝트에서 흔하게 사용됨

순서

1. 일주일의 첫 4일동안은 서로 신경쓰지 않음
작업을 어떻게 통합할지도 걱정하지 않음
2. 금요일이 되면 변경된 코드를 통합하여 시스템을 빌드

특징

장점

단순하고 개발자의 부담을 줄임

단점

금요일 하루안에 모두 합치기는 불가능해지며 
통합이 점차 무거워짐 (어느새 작업의 절반 이상)

## 순환 의존성 제거하기

개발 환경을 릴리즈 가능한 컴포넌트 단위로 분리하기

컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있게 됨 (ex. 백앤드 클레임 파트, 장바구니/주문 파트 등)

순서

1. 개발자가 해당 컴포넌트가 동작하도록 만든 후 
해당 컴포넌트를 릴리즈하여 다른 개발자가 사용할 수 있도록 만듬
2. 이 컴포넌트에 릴리즈 번호를 부여하고 
다른 팀에서 사용할 수 있는 위치로 이동시킴
3. 자신의 공간에서 해당 컴포넌트를 지속적으로 수정하고
나머지 개발자는 릴리즈된 버전 사용

특징

릴리즈를 적용할지 말지는 각 팀에 상황에 따름

준비가 되었다고 판단되면 새 릴리즈 적용할 수 있음

장점

1. 어떤 팀도 다른 팀에 의해 좌우되지 않음
2. 컴포넌트가 변경되어도 
다른 팀에 즉각 영향을 주지 않음
3. 통합은 점진적으로 이루어짐

단점

1. 이 절차가 성공적으로 동작하려면 
컴포넌트 사이의 의존성 구조를 
반드시 관리해야 함
2. 의존성 구조에 순환이 있으면 안됨

## 의존성 구조의 순환?

의존성 구조에 순환이 생기면 숙취 증후군을 피할 수 없음

의존성이 비순환인 경우, 어느 컴포넌트에서 시작하더라도 
의존성 관계를 따라가면서 최초의 컴포넌트로 돌아갈 일이 없음

ex. main 만 건드렸을 경우 아무 곳에도 영향이 없음, presenter 가 수정되면 view 와 main 만 영향이 감

시스템 전체를 릴리즈 해야하는 경우 릴리즈는 상향식으로 진행됨

ex. 가장 많은 영향을 끼치는 곳부터 빌드 → 그 다음 곳 부터 차례대로 빌드

## 순환이 컴포넌트 의존성 그래프에 끼치는 영향

만약 순환이 생길 경우, 순환의 부분에 의존하는 파트는 그 순환 전체가 작업 커버리지가 되어버림

ex. (책 내에서) Entities 의 User 클래스에서 Authorizer 의 Permission 로직을 을 사용하는 경우

테스트를 할 경우에도 관련 순환 부분을 전체 빌드하고 통합한 이후에 해야함

가장 많은 영향을 끼치는 곳이 애매모호해지기 때문에, 시스템 전체 릴리즈의 순서도 헷갈려짐
(가장 많은 영향을 끼치는 곳 → 순환 영역 → 이 영역중에 뭐부터 테스트하지....)

## 순환 끊기

방법은 있다.

### 1. 의존성 역전 원칙(DIP) 를 이용한다

의존성을 역전하여 순환의 화살표를 반대로 바꿔버림

ex. Entities 내의 Authorizer 구현체를 인터페이스로 바꿔버림

1. Permission 메서드를 제공하는 Author 인터페이스를 Entities 에 생성
2. Authorizer 에서 이 인터페이스를 상속받도록 함

→ Entities 의 Permissions 를 최종 의존지로 두게 되고, 뭉뚱그려 Entities 가 최종 목적지가 됨

### 2. 각 순환의 원인이 된 당사자가 모두 의존하는 새로운 컴포넌트를 만든다

새로운 최종 의존지를 만들어 최종 목적지로 만들어버림

ex. Authorizer 구현체 내 Permission 을 따로 기능을 뺌

컴포넌트 구조가 변경되고 흐트러지지만 긍정적인 흐트러짐임

# 하향식(top-down) 설계

컴포넌트 구조는 하향식으로 설계될 수 없다

시스템이 성장하고 변경할 때 함께 진화함

컴포넌트 의존성 다이어그램은, 애플리케이션의 빌드가능성과 유지보수성을 보여주는 지도와 같다

→ 만약 빌드하거나 유지보수할 소프트웨어가 없다면 컴포넌트 의존성 다이어그램은 필요가 없다

→ **컴포넌트 구조는 초기에 설계할 수 없다.**

그러나 시간이 지날수록..!

구현과 설계가 이뤄지는 프로젝트 초기에 모듈들이 점차 쌓이기 시작하면 
숙취 증후군을 겪지 않고 프로젝트를 개발하기 위해서 의존성 관리에 대한 요구가 점차 늘어나게 됨

단일 책임 원칙 (SRP), 공통 폐쇄 원칙(CCP) 가 대두되고 클래스를 정리하기 시작

의존성 구조와 관련된 최우선 관심사 : 변동성 격리

우리는 변덕스러운 이유로 자주 변경되는 컴포넌트로 인해
다른 곳에 영향을 끼치는 걸 원치 않음

ex. GUI 변동 시 업무 규칙에까지 영향을 주기 싫어함

애플리케이션이 성장하면서 우리는 `재사용 가능한 요소를 만드는 일`에 관심을 가짐

컴포넌트를 조합하는 과정에 공통 재사용 원칙(CRP) 가 영향을 끼치기 시작

아래 내용을 기억하자.

아무런 클래스도 설계하지 않은 상태에서 컴포넌트 의존성 구조를 설계할 수 없다

우리는 미래를 알 수 없기 때문이다 (공통 폐쇄가 얼마나 있는지, 얼만큼 재사용 가능 요소가 얼마나 있는지 등)

# SDP: 안정된 의존성 원칙

안정성의 방향으로 의존하라 (안정된 쪽에 의존하라)

설계는 정적일 수 없다

공통 폐쇄 원칙을 준수하며 특정 유형의 변경에만 민감하게 만들 수 있음

변경이 어려운 컴포넌트가, 가변적인 컴포넌트에 의존하게 만들면 안됨

안정적 의존성 원칙을 준수하면 위 문제를 피할 수 있음

## 안정성

쉽게 움직이지 않는!

변화가 발생하는 빈도는 안정성과 연관이 없다.

특정 기능 X가 의존을 받고 있는데, X는 더 이상 뻗어나가는 의존이 없다면 
X는 `독립적`이라고 말한다.

특정 기능 Y가 다양한 파일에 의존하고 있다면 
Y는 `책임성이 없다`고 할 수 있고, `상당히 불안정`하다고 말할 수 있다
Y는 `의존적`이라고 말한다.

## 안정성 지표

컴포넌트 안정성을 측정할 수 있는 방법? 
컴포넌트로 들어오고 나가는 의존성의 개수를 세어보자

Fan-in : 안으로 들어오는 의존성. 
컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래스 개수를 나타냄
(ex. 이 파일을 직접 호출하는 클래스들)

Fan-out : 바깥으로 나가는 의존성
컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 개수를 나타냄
(ex. Repository 구현체를 직접 사용, include / import 를 호출해 사용)

I(불안정성) = Fan-out / (Fan-in + Fan-out)
0이면 안정적 / 1이면 의존적

## 모든 컴포넌트가 안정적이어야 하는 것은 아니다

의존적, 안정적인 파일이 공존하는 것이 가장 이상적인 구조

stable 이 갑자기 flexable (유동적인) 컴포넌트에 의존하게 되는 경우 SDP를 위배하게 됨

SDP 를 위배하게 되면 최종 의존 목적지는 수정이 어려워지게 됨

해결책

DIP 를 도입하면 위 문제를 해결할 수 있음

Stable 과 Flexable 에 인터페이스를 두어 (하나는 상속받고, 하나는 구현체 두고)
두 개의 의존성을 끊고 인터페이스로 향하게 만들면 해결

### 추상 컴포넌트

오로지 인터페이스만을 포함하는 컴포넌트를 생성하는 게 이상하게 보일수도 있음

하지만 상당히 흔하고 꼭 필요한 전략

# SAP: 안정된 추상화 원칙

컴포넌트는 안정된 정도만큼만 추상화되어야 한다

자주 변경해서는 안되는 소프트웨어도 존재 (ex. 고수준 아키텍처, 정책 관련 소프트웨어)

하지만 그만큼 안정적이면서 수정이 어려워진다 (자신이 최종 의존 목적지가 되어버리니까!)

해결책

개방 폐쇄 원칙(OCP)

클래스를 수정하지 않아도 확장성을 높이고 유연하게 만들 수 있음

추상 클래스는 이 원칙을 준수함

## 안정된 추상화 원칙

SAP 라고도 함

안정성과 추상화 정도 사이의 관계를 정의함

안정된 컴포넌트는 추상컴포넌트여야 하며, 
이를 통해 안정성이 컴포넌트를 확장하는 일을 방해하면 안됨

안정적인 컴포넌트라면, 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 함

이로서 유연성을 얻고, 아키텍처를 과도하게 제약하지 않음

SAP + SDP = 컴포넌트에 대한 DIP

- SDP : 의존성이 반드시 안정성의 방향으로 가야 함
- SAP : 안정성이 결국 추상화를 의미함
- DIP : 의존성은 추상화의 방향으로 향하게 됨

DIP 는 클래스에 대한 원칙이며 클래스는 중간이 존재하지 않음 (추상적이거나 아니거나)

SDP, SAP는 컴포넌트에 대한 원칙이며, 어떤 부분은 추상적이고 다른 부분은 안정적일 수 있음

## 추상화 정도 측정하기

Nc : 컴포넌트의 클래스 개수

Na : 컴포넌트의 추상 클래스와 인터페이스의 개수

A(추상화 정도) = Na / Nc
1 이면 컴포넌트는 오로지 추상 클래스만을 포함, 0이면 추상클래스가 하나도 없음

## 주계열

안정성(I), 추상화정도(A) 의 관계

추상 클래스는 흔히 또 다른 추상클래스로부터 파생해서 만들곤 함
추상적이면서 의존성을 가짐 → 추상적이지만 안정적인 것은 아님

### 고통의 구역 (표에서 0, 0 에 근접한 좌측하단 영역)

안정적이며 구체적

뻣뻣하기 때문에, 바람직한 상태는 아님

추상적이지 않으므로 확장 불가능, 안정적이므로 변경도 어려움

ex. DB 스키마

1. 변동성이 높기로 악명이 높으며, 극단적으로 구체적이고 많은 컴포넌트가 여기에 의존
2. 애플리케이션 ↔ DB 사이에 위치한 인터페이스는 관리가 어렵고 스키마 변경시 고통

ex2. 구체적인 유틸리티 라이브러리

1. 안정성이 높더라도 실제로는 변동성이 거의 없음
2. String 에 속한 클래스가 변동된다고 생각해보자 (어머 끔찍)
3. 변동성이 없다고 픽스된 컴포넌트는 (0,0) 에 있어도 해롭지 않음

변동 가능성이 있는 게 고통 영역에 있는 게 문제

### 쓸모 없는 구역 (표에서 1,1 에 근접한 우측 상단 영역)

최고로 추상적이지만, 누구도 컴포넌트에 의존하지 않음 → 컴포넌트는 쓸모가 없음 (폐기물)

대체로 누구도 구현하지 않은 채 남겨진 추상클래스인 경우가 많음

### 배제구역 벗어나기 (표에서 1,0 과 0,1 을 잇는 가운데 영역)

`주계열`이라고 명명

안정성에 비해 너무 추상적이지도 않고, 추상화 정도에 비해 너무 불안정하지도 않음

100% 안정적이거나 100% 추상적인 경우는 없으므로 해당 영역에 가깝게 위치할 때 가장 이상적

### 주계열과의 거리

주계열에서의 거리를 구하고 분석하여 설계를 통계적으로 분석하는 일 또한 가능해짐 
(평균과 분산을 구한다 등등)

# 결론

의존성 관리 지표는 설계의 의존성과 추상화 정도가 
`주관적으로 생각하는` 훌륭한 패턴 수준에 얼마나 잘 부합하는지를 측정함

지표는 신이 아님

지표로부터 유용점을 찾는 게 중요
