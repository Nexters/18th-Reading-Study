# Chapter 01. 티켓 판매 애플리케이션 구현하기

- '이론이 먼저일까, 실무가 먼저일까?'
- 이론보다 실무가 먼저다. 따라서 어떤 분야든 초기 단계에서는 아무것도 없는 상태에서 이론을 정립하기보다는 실무를 관찰한 결과를 바탕으로 이론을 정립하는 것이 최선이다.
- 실무에서는 다양한 규모의 소프트웨어를 성공적으로 유지보수하고 있지만, 소프트웨어 유지보수와 관련된 효과적인 이론이 발표된 적은 거의 없다.
- 결론적으로 소프트웨어 설계와 유지보수에 중점을 두려면 이론이 아닌 실무에 초점을 맞추는 것이 효과적이다.

## 01. 티켓 판매 애플리케이션 구현하기

- 연극이나 음악회를 공연할 수 있는 작은 소극장을 경여하고 있다고 상상해 보자.
- 소극장의 홍보도 겸할 겸 관람객들의 발길이 이어지도록 작은 이벤트를 기획하기로 했다.
- 이벤트의 내용은 추첨을 통해 선정된 관람객에게 공연을 무료로 관람할 수 있는 초대장을 발송하는 것이다.
- 이벤트는 마감됐고 공연날이 밝았다. 소극장의 문을 열어 관람객들을 맞이하자.

### 소극장 - 티켓 판매 시나리오

> 이벤트에 당첨된 관람객과 그렇지 못한 관람객은 다른 방식으로 입장시켜야 한다.  
> 이벤트에 당첨된 관람객은 초대장을 티켓으로 교환한 후에 입장할 수 있다.  
> 이벤트에 당첨되지 않은 관람객은 티켓을 구매해야만 입장할 수 있다.

- 관람객을 입장시키기 전에 이벤트 당첨 여부를 확인해야 하고 이벤트 당첨자가 아닌 경우에는 티켓을 판매 후에 입장
  - 이벤트 당첨자에게 발송되는 초대장 ('Invitation' Class)
  - 공연을 관람하기를 원하는 모든 사람들은 티켓을 소지하고 있어야만 한다. ('Ticket' Class)
  - 관람객이 가지고 올 수 있는 소지품은 초대장, 현금, 티켓 세 가지 뿐이다. **관람객은 가방을 들고 올 수 있다고 가정하자** ('Bag' Class)
    - 이벤트에 당첨되지 않은 관람객의 가방 안에는 초대장이 들어있지 않을 것이다.
  - 관람객이라는 개념을 구현 ('Audience' Class)
    - 관람객은 소지품을 보관하기 위해 가방을 소지할 수 있다.
  - 매표소를 구현 ('TicketOffice' Class)
    - 관람객이 소극장에 입장하기 위해서는 매표소에 초대장을 티켓으로 교환하거나 구매해야 한다.
    - 매표소에는 관람객에게 판매할 티켓과 티켓의 판매 금액이 보관돼 있어야 한다.
  - 매표소에서 초대장을 티켓으로 교환해 주거나 티켓을 판매하는 역할을 수행하는 판매원 구현 ('TicketSeller' Class)
  - 관람객을 맞이할 수 있도록 소극장 구현 ('Theater' Class)

## 02. 무엇이 문제인가

- 소프트웨어 모듈이 가져야 하는 세 가지 기능
  - 실행 중에 제대로 동작하는 것
  - 변경을 위해 존재
  - 코드를 읽는 사람과 의사소통 해야 한다.

### 예상을 빗나가는 코드

이해 가능한 코드란 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드다.

- 앞에서 시나리오 대로 작성한 Theater 클래스의 enter 메서드

> 소극장은 관람객의 가방을 열어 그 안에 초대장이 들어 있는지 살펴본다. 가방안에 초대장이 들어 있으면 판매원은 매표소에 보관돼 있는 티켓을 관람객의 가방안으로 옮긴다. 가방안에 초대장이 들어 있지 않다면 관람객의 가방에서 티켓 금액만큼의 현금을 꺼내 매표소에 적립한 후에 매표소에 보관돼 있는 티켓을 관람객의 가방안으로 옮긴다.

- 소극장은 관람객의 가방을 열어(?)
- 판매원이 티켓을 관람객의 가방안으로 옮긴다. (?)
- 판매원이 관람객의 가방에서 티켓 금액만큼의 현금을 꺼내 매표소에 적립한다. (?)
- 티켓을 관람객의 가방안으로 옮긴다. (?)

### 변경에 취약한 코드

- 관람객이 가방을 들고 있다는 가정이 바뀌면, Audience 클래스에서 Bag 을 제거해야 할 뿐만 아니라 Audience 의 Bag 에 직접 접근하는 Theater 의 enter 메서드 역시 수정해야 한다.
- Theater 는 관람객이 가방을 들고 있고 판매원이 매표서에서만 티켓을 판매한다는 지나치게 세부적인 사실에 의존해서 동작한다.
- 객체 사이의 의존성과 관련된 문제.
- 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것.
- 객체 사이의 의존성이 과한 경우를 가리켜 결합고다 높다고 말한다.

## 03. 설계 개선하기

### 자율성을 높이자
* 각 도메인에 책임을 적절히 부여해서 자율적인 존재가 되도록 설계를 변경해야 한다.
* 캡슐화를 통해 객체 내부로의 접근을 제한하며, 객체 사이의 결합도를 낮추어 변경하기 쉬운 객체로 만들어야 한다.
  * 캡슐화(encapsulation): 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것
* 객체간의 의존하게 되는 관계가 형성 되면, 의존 관계는 인터페이스(interface)를 이용하여 실제 구현(implementation)은 의존 관계에 영향을 주지 않게 설계 한다.

> 객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙.

*  캡슐화를 개선한 후에 가장 크게 달라진 점은 Audience 와 TicketSeller 가 내부 구현을 외부에 노출하지 않고 자신의 문제를 스스로 책임지고 해결한다는 것이며, 이는 두 객체가 자율적인 존재가 된 것.

### 무엇이 개선됐는가
* 캡슐화를 통해 'Audience' 와 'TicketSeller' 의 내부 구현이 변경되어도, 'Theater' 를 함께 변경할 필요가 없어졌다는 것.

> 'Theater' 내부에 'Audience' 와 'TicketSeller' 가 해야할 일들이 구현되어 있었으며, 그 일들의 책임을 'Theater' 로 부터 옮기며, 각 클래스가 해야할 일들을 정의했다. 그리고, 각 클래스를 사용하는 'Theater' 에서 인터페이스를 참조하여 각 클래스의 세부 구현이 달라지더라도 'Theater' 에서 'Audience' 나 'TicketSeller' 의 구현을 변경하지 않도록 했다. 각 클래스의 역할을 구분하며 각각의 역할에 맞는 로직만 구현하면 된다.

### 어떻게 한 것인가
* 자기 자신의 문제를 스스로 해결하도록 코드를 변경한 것.

### 캡슐화와 응집도
* 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이 핵심이다.
* 'Theater' 는 'TicketSeller' 의 내부에 대해서는 전혀 알지 못하며, 단지 'TicketSeller'가 'sellTo' 메시지를 이해하고 응답할 수 있다는 사실만 알고 있을 뿐.
* 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도롤 낮출 수 있을뿐더러 응집도(cohesion)를 높일 수 있다.
* 객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임져야 한다.
* 외부의 간섭을 최대한 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 얻을 수 있는 지름길.

### 절차지향과 객체지향
* 프로세스(process)와 데이터(data)를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍(Procedural Programming) 이라 한다.
  * 'Theater' 가 'TicketSeller', 'TicketOffice', 'Audience', 'Bag' 을 모두 의존하고 있으며, 모든 처리는 하나의 클래스 안에 위치하고, 나머지 클래스는 단지 데이터의 역할만 수행한다.
* 변경하기 쉬운 설계는 한 번에 하난의 클래스만 변경할 수 있는 설계다.
* 절차적 프로그래밍은 프로세스가 필요한 모든 데이터에 의존해야 한다는 근본적인 문제점 떄문에 변경에 취약할 수 밖에 없다.
* 자신의 데이터를 스스로 처리하도록 프로세스의 적절한 단계를 각 클래스로 이동 시키는 것이다.
* 이처럼 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 객체지향 프로그래밍 이라고 부른다.
* 훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이다.

### 책임의 이동
* 기능을 처리하는 방법을 살펴보면 책임의 이동(shift of responsibility)을 이해 할 수 있다.
  * 작업의 흐름이 주로 'Theater' 에 의해 제어되고 있다.
* 각 객체가 자신을 스스로 책임지게 만들기 위해 책임을 이동시킨다.
* 객체지향 프로그래밍은 데이터와 프로세스를 하나의 단위로 통합해 놓는 방식으로 표현하기도 한다.
* 설계를 어렵게 만드는 것은 의존성. 의존성을 제거함으로써 객체 사이의 결합도를 낮춤. 결합도를 낮추기 위해 각 객체에 책임에 맡는 데이터와 프로세스를 부여하여 캡슐화 한다.
* 결과적으로 캡슐화는 객체들의 결합도는 낮추고 응집도를 높여 최소한의 의존성만 남기는 훌륭한 객체지향 설계의 특성이다.

### 더 개선할 수 있다
* 어떤 기능을 설계하는 방법은 한 가지 이상일 수 있다.
* 동일한 기능을 한 가지 이상의 방법으로 설계할 수 있ㅅ기 때문에 결국 설계는 트레이드오프의 산물이다.
* 훌륭한 설계는 적절한 트레이드오프의 결과물이다.

### 그래, 거짓말이다!
* 비록 현실에서는 수동적인 존재라고 하더라도 일단 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다.
* 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 가리켜 의인화(anthropomorphism)라고 부른다.
