# 5장. any 다루기

## 아이템 38. any 타입은 가능한 한 좁은 범위에서만 사용하기

- 타입스크립트가 함수의 반환타입을 추론할 수 있는 경우에도 함수의 반환타입을 명시하는 것이 좋다.
- 의도치 않은 타입 안전성의 손실을 피하기 위해 `any`의 사용 범위를 최소한으로 좁히자.

## 아이템 39. any를 구체적으로 변형해서 사용하기

- 객체지만 속성에 접근할 수 없어야 한다면 `unknown`이 필요할 수 있다.
- 함수의 타입에도 단순히 `any`를 사용해서는 안 된다.

## 아이템 40. 함수 안으로 타입 단언문 감추기

- 함수의 모든 부분을 안전한 타입으로 구현하는 것이 이상적이지만 불필요한 예외 상황까지 고려해 가며 타입 정보를 힘들게 구성할 피요는 없다.
- 함수 내부에는 타입 단언을 사용하고 함수 외부로 드러나는 타입 정의를 정확히 명시하는 정도로 끝내는 게 낫다.

## 아이템 41. any의 진화를 이해하기

- 타입의 진화는 타입 좁히기와 다르다.
- any 타입의 진화는 `noImplicityAny`가 설정된 상태에서 변수의 타입이 암시적 any인 경우에만 일어난다. 암시적 any 타입은 어떤 값을 할당할 때만 진화가 발생하므로 함수 호출을 거쳐도 진화하지 않는다.

## 아이템 42. 모르는 타입의 값에는 any 대신 unknown을 사용하기

- **any가 강력하고 위험한 이유**
  - 어떠한 타입이든 any 타입에 할당 가능하다
  - any 타입은 어떠한 타입으로도 할당 가능하다 (never 예외)
- **어떠한 값이 있지만 그 타입을 모르는 경우에** `unknown`을 사용한다.
- 제너릭보다는 unknwon을 반환하고 사용자가 직접 단언문을 사용하거나 원하는 대로 타입을 좁히도록 강제하는 것이 좋다.
- `unknown`과 유사한 타입으로 `object`나 `{}`을 사용할 수 있다.
  - `{}` 타입은 `null`과 `undefined`를 제외한 모든 값을 포함한다.

## 아이템 43. 몽키 패치보다는 안전한 타입을 사용하기

- 자바스크립트는 객체와 클래스에 임의의 속성을 추가할 수 있다. 그러나 가장 좋은 것은 document 또는 DOM으로부터 데이터를 분리하는 것이다.
- 분리할 수 없는 경우 두 가지 차선책이 있다.
  1. `interface`의 보강 기법 사용
  2. 더 구체적인 타입 선언문을 사용

## 아이템 44. 타입 커버리지를 추적하여 타입 안전성 유지하기

### `any` 타입이 여전히 프로그램 내에 존재할 수 있는 경우

1. 명시적 any 타입
2. 서드파티 타입 선언

```bash
$ npx type-coverage
```

- `type-coverage` 패키지를 활용하여 any 추적 가능
