# 2장. 타입스크립트의 타입 시스템

## 아이템 6. 편집기를 사용하여 타입 시스템 탐색하기

- 편집기를 사용하면 타입 시스템의 동작 방식, 타입 추론에 대한 개념을 잡을 수 있다.

## 아이템 7. 타입이 값들의 집합이라고 생각하기

- 타입스크립트에서 **가장 작은 집합은 아무 값도 포함하지 않는 공집합**이며, `never` 타입을 의미한다. **아무런 값도 할당할 수 없다.**

```ts
const x: never = 12;
// ~ '12' 형식은 'never' 형식에 할당할 수 없습니다.
```

- 그 다음으로 작은 집합은 한 가지 값만 포함하는 타입이다. `유닛(unit)` 타입이라고 불리는 `리터럴(literal)` 타입이다.
- 두 개 이상으로 묶으려면 **유니온(union) 타입**을 사용한다.
- 타입 체커의 주요 역할은 하나의 집합이 다른 집합의 부분 집합인지 검사하는 것이다. (집합의 관점)
- 타입이 값의 집합이라는 건, 동일한 값의 집합을 가지는 두 타입은 같다는 의미

> 타입을 값의 집합으로 생각하면 이해하기 편하다. `타입의 범위`

## 아이템 8. 타입 공간과 값 공간의 심벌 구분하기

- 타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재한다.
- 값으로 쓰이는 `this`는 자바스크립트의 `this` 키워드이고, 타입으로 쓰이는 `this`는 다형성 this라고 불리는 타입이다. 서브클래스의 **메서드 체인을 구현할 때** 유용하다.
- 모든 값은 타입을 가지지만, 타입은 값을 가지지 않는다.

## 아이템 9. 타입 단언보다는 타입 선언을 사용하기

- 타입 단언보다 타입 선언을 사용하는 게 낫다.
- null이 아님을 단언할 때는 `!` 을 사용한다.
- 타입스크립트보다 타입 정보를 더 잘 알고 있는 상황에서는 타입 단언문을 사용한다.

## 아이템 10. 객체 래퍼 타입 피하기

- 타입스크립트는 기본형과 객체 래퍼 타입을 별도로 모델링한다.
- `string`은 `String`에 할당할 수 있지만 `String`은 `string`에 할당할 수 없다.
- 타입스크립트 객체 래퍼 타입은 지양하고, 대신 기본형 타입을 사용하자.

## 아이템 11. 잉여 속성 체크의 한계 인지하기

- 타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립트는 **해당 타입의 속성이 있는지, 그리고 '그 외의 속성은 없는지' 확인한다.**
- 잉여 속성 체크가 할당 가능 검사와는 별도의 과정이라는 것을 알아야 타입스크립트 타입 시스템에 대한 개념을 정확히 잡을 수 있다.

## 아이템 12. 함수 표현식에 타입 적용하기

- 타입스크립트에서는 함수 표현식을 사용하는 것이 좋다. 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있기 때문.
- 함수 매개변수에 타입 선언을 하는 것보다 함수 표현식 전체 타입을 정의하는 것이 코드도 간결하고 안전하다.

## 아이템 13. 타입과 인터페이스의 차이점 알기

- 대부분의 경우 타입과 인터페이스 모두 사용해도 되지만 차이를 아고, 일관성을 유지해야 한다.
- `I` `T` 접두사를 붙이는 네이밍 방식은 지양해야 한다. (C#에서 유래)

### `인터페이스 선언`과 `타입 선언`의 비슷한 점

1. **인덱스 시그니처**는 인터페이스와 타입에서 모두 사용할 수 있다.
2. **함수 타입**도 인터페이스나 타입으로 정의할 수 있다.
3. 타입 별칭과 인터페이스는 모두 **제너릭**이 가능하다.
4. 인터페이스는 타입을 확장할 수 있으며, 타입은 인터페이스를 확장할 수 있다.
5. **클래스를 구현**할 때는 타입과 인터페이스 둘 다 사용할 수 있다.

- 선언 병합은 주로 타입 선언 파일에서 사용된다.
- 타입은 기존 타입에 추가적인 보강이 없는 경우에만 사용해야 한다.

## 아이템 14. 타입 연산과 제너릭 사용으로 반복 줄이기

> Don't repeat yourself : 같은 코드를 반복하지 말라.

- 제너릭 타입은 **타입을 위한 함수**와 같다. 타입을 반복하는 대신 제너릭 타입을 사용하여 타입들 간에 매핑을 하는 것이 좋다.
- 제너릭 타입에서 매개변수를 제한할 수 있는 방법은 `extends`를 사용하는 것이다.
- 표준 라이브러리에 정의된 Pick, Partial, ReturnType 같은 제너릭 타입에 익숙해져야 한다.

## 아이템 15. 동적 데이터에 인덱스 시그니처 사용하기

- 인덱스 시그니처는 동적 데이터를 표현할 때 사용한다.
- 런타임 때까지 객체의 속성을 알 수 없을 경우에만 인덱스 시그니처를 사용하자

## 아이템 16. number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기

- 타입스크립트는 자바스크립트의 배열 키가 문자열로 처리되는 혼란을 바로잡기 위해 숫자 키를 허용하고, 문자열 키와 다른 것으로 인식한다. 이는 실제로는 동작하지 않고 런타임에 타입 정보가 제거된다.
- 어떤 길이를 가지는 배열과 비슷한 형태의 튜플을 사용하고 싶다면 타입스크립트에 있는 `ArrayLike` 타입을 사용한다.

## 아이템 17. 변경 관련된 오류 방지를 위해 readonly 사용하기

- `readonly number[]`는 타입이다. 배열의 요소를 **읽을 수 있지만,** 쓸 수는 없으며 **length를 변경할 수 없다**. 또한 pop을 비롯한 **배열을 변경하는 다른 메서드를 호출할 수 없다.**

### 매개변수를 `readonly`로 설정하면?

- 타입스크립트는 매개변수가 함수 내에서 변경이 일어나는지 체크한다.
- 호출하는 쪽에서는 함수가 매개변수를 변경하지 않는다는 보장을 받는다.

## 아이템 18. 매핑된 타입을 사용하여 값을 동기화하기

- 인터페이스 새로운 속성을 추가할 때, 선택을 강제하도록 매핑된 타입을 고려해야 한다.
