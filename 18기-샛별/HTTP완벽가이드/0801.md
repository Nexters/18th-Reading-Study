## 4.4 병렬 커넥션

### 3) 병렬 커넥션은 더 빠르게 '느껴질 수' 있다.

- 병렬 커넥션이 페이지를 항상 더 빠르게 로드하지는 않지만 사용자는 더 빠르게 내려받고 있는 것처럼 **느낄 수 있다.**

## 4.5 지속 커넥션

- 사이트 지역성(site locality) : 서버에 HTTP 요청을 하기 시작한 애플리케이션은 웹 페이지 내의 이미지 등을 가져오기 위해 그 서버에 또 요쳥하게 되는 속성
- 처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션을 `지속 커넥션`이라고 부른다. 지속 커넥션을 재사용함으로써 커넥션을 맺기 위한 준비작업에 따르는 시간을 절약할 수 있다.

### 1) 지속 커넥션 vs. 병렬 커넥션

- 병렬 커넥션에 비해 **지속 커넥션이 갖는 장점**
    1. 커넥션을 맺기 위한 사전 작업과 지연의 감소
    2. 튜닝된 커넥션 유지 (한 번에 다수의 패킷 전송 가능한 권한을 얻음)
    3. 커넥션의 수를 줄여줌

-> 😯 지속 커넥션을 **잘못 관리할 경우**, 연결된 상태의 커넥션이 계속 쌓이게 됨 (리소스의 불필요한 소모 발생)

- 지속 커넥션은 병렬 커넥션과 함께 사용될 때 가장 효과적
- 오늘날 많은 웹 애플리케이션은 적은 수의 병렬 커넥션만을 맺고 유지

### 2) HTTP/1.0+의 Keep-Alive 커넥션

- `keep-alive` 커넥션의 성능상의 장점 : 커넥션을 맺고 끊는 데 필요한 작업이 없어 시간의 단축

### 3) Keep-Alive 동작

- `keep-alive`는 사용하지 않기로 결정되어 HTTP/1.1 명세에서 빠졌지만 브라우저와 서버 간에 `keep-alive` 핸드셰이크가 널리 사용되므로 HTTP 애플리케이션은 이를 처리하도록 해야 한다.
- HTTP/1.0 `keep-alive` 커넥션을 구현한 클라이언트는 커넥션을 유지하기 위해 요청에 `Connection:Keep-Alive` 헤더를 포함시킨다. **서버가 그 다음 요청도 이 커넥션을 통해 받고자 하면 같은 헤더를 응답 메시지에 포함시킨다.**

### 4) Keep-Alive 옵션

- `keep-alive` 동작은 `keep-alive` 헤더의 쉼표로 구분된 옵션들로 제어할 수 있다.

```
timeout : 커넥션이 얼마나 유지될 것인지를 의미 (보장은 없음)
max : 커넥션이 몇 개의 HTTP 트랜잭션을 처리할 때까지 유지될 것인지 의미 (보장은 없음)
임의의 속성 -> 이름[=값]
```

### 5) `keep-alive` 커넥션 제한과 규칙

- 기본으로 사용되지 않으므로 클라는 `keep-alive` 요청 헤더를 보내야 함
- 커넥션을 계속 유지하려면 모든 메시지에 `keep-alive` 헤더를 포함해야 함
- 클라는 응답 헤더가 없는 것을 보고 서버가 응답 후에 커넥션을 끊을 것임을 알 수 있음
- 엔터티 본문의 길이를 알 수 있어야 커넥션을 유지할 수 있음
- 프락시와 게이트웨이는 Connection 헤더의 규칙을 철저히 지켜야 함
- 정석대로라면 `keep-alive` 커넥션은 Connection 헤더를 인식하지 못하는 프락시 서버와 맺어지면 안 된다. (현실적으로 어려움)
- 클라이언트는 응답 전체를 모두 받기 전에 커넥션이 끊어졌을 경우 별다른 문제가 없으면 요청을 다시 보낼 수 있게 준비되어 있어야 한다.

### 6) `keep-alive`와 dumb 프락시

- 프락시는 Connection 헤더를 이해하지 못해 해당 헤더를 삭제하지 않고 요청 그대로를 다음 프락시에 전달한다. 클라이언트는 웹 서버가 아닌 프록시와 `keep-alive`로 맺어졌다고 이해한다. 실제로는 클라이언트와 웹 서버가 맺어진 것. 이 경우 프락시에 또 다른 요청을 보내게 되도 프락시는 이를 무시하고 브라우저는 로드를 기다려야 한다. -> 타임아웃되거나 커넥션이 끊겨야 함

### 7) Proxy-Connection 살펴보기

- 클라이언트의 요청이 중개서버를 통해 이어지는 경우 모든 헤더를 무조건 전달하는 문제를 해결하기 위해 Proxy-Connection 헤더를 사용하는 것이 차선책. (현대 브라우저 지원)
- 영리한 프락시는 Proxy-Connection을 Connection 헤더로 바꾼다.
  - '보이지 않는' 프락시인 경우 해당 헤더를 보내지 못할 수도 있고, 영리한 프락시 이후 멍청한 프락시가 오면 다시 문제가 발생 😡

### 8) HTTP/1.1의 지속 커넥션

- HTTP/1.1은 지속 커넥션은 기본으로 활성화
- 트랜잭션이 끝난 후 커넥션을 끊으려면 `Connection: close` 헤더 명시
- 하지만 클라이언트와 서버가 언제든지 커넥션을 끊을 수 있음