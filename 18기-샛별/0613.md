# 26장. ES6 함수의 추가 기능

## 26.1 함수의 구분

- ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다. ▶️ `callable` && `constructor` ▶️ 사용 목적에 따른 구분이 없음


## 26.2 메서드

> ES6 사양에서 메서드는 **메서드 축약 표현으로 정의된 함수**만을 의미한다.

- ES6 메서드는 인스턴스를 생성할 수 없는 non-constructor 이므로 생성자 함수로서 호출 X


## 26.3 화살표 함수

- `fucntion` 키워드 대신 화살표를 사용하여 기존의 함수 정의 방식보다 간략하게 함수 정의
- 표현뿐만 아니라 내부 동작 또한 기존 함수보다 간략함

### 화살표 함수 정의

```jsx
const multiply = (x, y) => x * y; // 하나의 표현식으로 구성할 경우 중괄호 생략
multiply(2, 3);

const multiplyByTwo = x => x * 2; // 매개변수가 1개일 때 소괄호 생략
const getString = () => 'Hi!'; // 매개변수가 없을 때 생략 불가

const create = (id, content) => ({ id, content }); // 객체 리터럴 반환하는 경우 소괄호로 감싸주어야 함
// const create = (id, content) => { return { id, content } };
```

- 즉시 실행 함수로 사용할 수 있음
- 화살표 함수도 일급 객체이므로 고차 함수에 인수로 전달할 수 있음

```jsx
const person = (name => ({
	sayHi() { return `Hi? My name is ${name`; }
}))('Ahn');
```

### 화살표 함수와 일반 함수의 차이

1. **화살표 함수는 인스턴스를 생성할 수 없는 non-constructor**
    - prototype 프로퍼티 없음
    - 프로토타입 생성하지 않음

2. **중복된 매개변수 이름을 선언할 수 없음**
    - strict mode가 아닌 일반 함수는 중복된 매개변수 이름 선언해도 에러 X

3. **함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않음**
    - 스코프 체인을 통해 화살표 함수가 아닌 상위 스코프 참조

### this

- this 바인딩은 함수의 호출 방식에 의해 동적으로 결정됨
- 주의할 점은 일반 함수로서 호출되는 콜백 함수의 경우!
    - 일반 함수로 호출되는 모둔 함수 내부의 this = 전역 객체
- 화살표 함수는 함수 자체의 this 바인딩을 갖지 않으므로 상위 스코프의 this를 그대로 참조
⇒ `**lexical this**`
    - call, apply, bind 메서드를 사용해도 화살표 함수 내부의 this 교체 불가
    - 메서드를 정의할 때는 ES6 메서드를 사용하는 것이 좋음

### super

- 화살표 함수는 함수 자체의 super 바인딩을 갖지 않는다.
- 참조 시 에러가 발생하지 않고 상위 스코프인 constructor의 super 바인딩을 참조

### arguments

- 함수 자체의 arguments 바인딩을 갖지 않음
- 화살표 함수 자신에게 전달된 인수 목록을 확인할 수 없으므로 도움이 되지 않음

## 26.4 Rest 파라미터

- 매개변수 이름 앞에 세개의 점 `...` 을 붙여서 정의한 매개변수를 의미
- Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받으며 반드시 마지막 파라미터
- Rest 파라미터는 단 하나만 선언할 수 있음
- 매개변수 개수를 나타내는 함수 객체의 `length` 프로퍼티에 영향을 주지 않음

## 26.5 매개변수 기본값

- 인수가 전달되지 않은 매개변수의 값은 undefined
- 매개변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크, 초기화를 간소화할 수 있음
- Rest 파라미터에는 기본값을 지정할 수 없음